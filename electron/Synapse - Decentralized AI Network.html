<!DOCTYPE html>
<!-- saved from url=(0052)file:///C:/Users/barry/projects/synapse/synapse.html -->
<html lang="en" style="--vh: 7.4px; font-size: 18px;"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover, shrink-to-fit=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="format-detection" content="telephone=no">
    <meta name="msapplication-tap-highlight" content="no">
    <title>Synapse - Decentralized AI Network</title>
    <style>
        /* Reset and Base Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            height: 100vh;
            height: calc(var(--vh, 1vh) * 100); /* iOS Safari fix */
            height: -webkit-fill-available; /* iOS Safari backup */
            overflow: hidden;
            position: relative;
            -webkit-text-size-adjust: 100%;
            -ms-text-size-adjust: 100%;
            text-size-adjust: 100%;
            -webkit-overflow-scrolling: touch;
        }

        /* Futuristic Grid Background */
        body::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(circle at 1px 1px, rgba(255,255,255,0.1) 1px, transparent 0);
            background-size: 50px 50px;
            opacity: 0.3;
            pointer-events: none;
        }

        /* Main Layout Container */
        .synapse-container {
            display: grid;
            grid-template-columns: 1fr;
            grid-template-rows: 60px 1fr;
            height: 100vh;
            height: calc(var(--vh, 1vh) * 100); /* iOS Safari fix */
            height: -webkit-fill-available; /* iOS Safari backup */
            min-height: 100vh;
            min-height: calc(var(--vh, 1vh) * 100);
            gap: 1px;
            background: rgba(255,255,255,0.05);
            position: relative;
            z-index: 1;
        }
        
        /* Ensure main content is always accessible */
        .main-chat {
            position: relative;
            z-index: 2;
            pointer-events: auto;
        }
        
        .header-bar {
            position: relative;
            z-index: 10;
            pointer-events: auto;
        }
        
        /* Dynamic responsive design with container queries */
        .synapse-container {
            container-type: size;
        }
        
        /* Ultra-small screens (phones in portrait) */
        @media (max-width: 480px) {
            .synapse-container {
                grid-template-rows: 45px 1fr;
            }
            
            .header-bar {
                padding: 0 10px;
            }
            
            .logo {
                font-size: 16px;
            }
            
            .sidebar {
                width: 85vw;
                left: -85vw;
            }
            
            .status-indicator {
                right: 10px;
                font-size: 12px;
            }
        }
        
        /* Small screens (phones in landscape, small tablets) */
        @media (max-width: 768px) and (min-width: 481px) {
            .synapse-container {
                grid-template-rows: 50px 1fr;
            }
            
            .header-bar {
                padding: 0 15px;
            }
            
            .logo {
                font-size: 18px;
            }
            
            .sidebar {
                width: 320px;
                left: -320px;
            }
        }
        
        /* Medium screens (tablets) */
        @media (max-width: 1024px) and (min-width: 769px) {
            .synapse-container {
                grid-template-rows: 55px 1fr;
            }
            
            .logo {
                font-size: 22px;
            }
            
            .sidebar {
                width: 350px;
                left: -350px;
            }
        }
        
        /* Large screens (desktops) */
        @media (min-width: 1025px) {
            .synapse-container {
                grid-template-rows: 60px 1fr;
            }
            
            .logo {
                font-size: 24px;
            }
            
            .sidebar {
                width: 380px;
                left: -380px;
            }
        }

        /* Header Bar */
        .header-bar {
            grid-column: 1 / -1;
            background: rgba(0,0,0,0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(64,224,208,0.3);
            display: flex;
            align-items: center;
            padding: 0 20px;
            position: relative;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(45deg, #40E0D0, #48CAE4, #0077BE);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .status-indicator {
            position: absolute;
            right: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00ff00;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Collapsible Sidebar */
        .sidebar {
            position: fixed;
            top: 0;
            left: -320px;
            width: 320px;
            height: 100vh;
            height: calc(var(--vh, 1vh) * 100); /* iOS Safari fix */
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            border-right: 1px solid rgba(64,224,208,0.3);
            transition: left 0.25s cubic-bezier(0.4, 0.0, 0.2, 1);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            will-change: left;
            transform: translateZ(0); /* Force hardware acceleration */
        }
        
        .sidebar.open {
            left: 0;
        }
        
        .sidebar-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.5);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.25s cubic-bezier(0.4, 0.0, 0.2, 1), visibility 0.25s cubic-bezier(0.4, 0.0, 0.2, 1);
            z-index: 999;
            pointer-events: none;
            will-change: opacity;
            transform: translateZ(0); /* Force hardware acceleration */
        }
        
        .sidebar-overlay.active {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }
        
        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid rgba(64,224,208,0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .sidebar-title {
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(45deg, #40E0D0, #48CAE4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .sidebar-close {
            background: none;
            border: none;
            color: #40E0D0;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.3s ease;
        }
        
        .sidebar-close:hover {
            background: rgba(64,224,208,0.1);
            transform: rotate(90deg);
        }
        
        .sidebar-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(64,224,208,0.4) rgba(0,0,0,0.2);
        }
        
        .sidebar-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .sidebar-content::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2);
            border-radius: 4px;
        }
        
        .sidebar-content::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, rgba(64,224,208,0.6), rgba(72,202,228,0.6));
            border-radius: 4px;
            border: 1px solid rgba(64,224,208,0.2);
        }
        
        .sidebar-content::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, rgba(64,224,208,0.8), rgba(72,202,228,0.8));
        }
        
        /* Menu Toggle Button */
        .menu-toggle {
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            padding: 8px;
            margin-left: 2px;
            transition: all 0.3s ease;
        }
        
        .menu-toggle:hover .hamburger span {
            background: #48CAE4;
        }
        
        .hamburger {
            width: 20px;
            height: 14px;
            position: relative;
            transform: rotate(0deg);
            transition: .2s cubic-bezier(0.4, 0.0, 0.2, 1);
            will-change: transform;
        }
        
        .hamburger span {
            display: block;
            position: absolute;
            height: 2px;
            width: 100%;
            background: #40E0D0;
            border-radius: 1px;
            opacity: 1;
            left: 0;
            transform: rotate(0deg);
            transition: .2s cubic-bezier(0.4, 0.0, 0.2, 1);
            will-change: transform, opacity;
        }
        
        .hamburger span:nth-child(1) {
            top: 0px;
        }
        
        .hamburger span:nth-child(2) {
            top: 6px;
        }
        
        .hamburger span:nth-child(3) {
            top: 12px;
        }
        
        .hamburger.open span:nth-child(1) {
            top: 6px;
            transform: rotate(135deg);
        }
        
        .hamburger.open span:nth-child(2) {
            opacity: 0;
            left: -20px;
        }
        
        .hamburger.open span:nth-child(3) {
            top: 6px;
            transform: rotate(-135deg);
        }

        .panel-section {
            margin-bottom: 30px;
        }

        .panel-title {
            font-size: 14px;
            font-weight: 600;
            color: #40E0D0;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            transition: all 0.3s ease;
        }
        
        .panel-title:hover {
            color: #48CAE4;
        }
        
        .panel-content {
            max-height: 500px;
            overflow: hidden;
            transition: max-height 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        
        .panel-content.collapsed {
            max-height: 0;
            margin-bottom: 0;
        }
        
        .collapse-arrow {
            font-size: 12px;
            transition: transform 0.3s ease;
        }
        
        .collapse-arrow.collapsed {
            transform: rotate(-90deg);
        }

        .menu-item {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px;
            margin-bottom: 8px;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .menu-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(64,224,208,0.1), transparent);
            transition: left 0.6s ease;
        }

        .menu-item:hover {
            background: rgba(64,224,208,0.1);
            border-color: rgba(64,224,208,0.3);
            transform: translateX(5px);
        }
        
        .menu-item:hover::before {
            left: 100%;
        }
        
        /* Swipe-to-Delete Pathway Items */
        .pathway-swipe-container {
            position: relative;
            margin-bottom: 6px;
            border-radius: 6px;
            overflow: hidden;
            background: rgba(255,68,68,0.1);
        }
        
        .pathway-item-sidebar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background: rgba(64,224,208,0.05);
            border: 1px solid rgba(64,224,208,0.1);
            border-radius: 6px;
            cursor: pointer;
            transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            font-size: 14px;
            position: relative;
            z-index: 2;
            touch-action: pan-x;
        }
        
        .pathway-item-sidebar:hover {
            background: rgba(64,224,208,0.15);
            border-color: rgba(64,224,208,0.3);
        }
        
        .pathway-item-sidebar.swiping {
            transition: none;
        }
        
        .pathway-actions-revealed {
            position: absolute;
            top: 0;
            right: 0;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 20px;
            z-index: 1;
            font-size: 18px;
            color: white;
            opacity: 0;
            transition: opacity 0.6s ease-in-out;
        }
        
        .pathway-item-sidebar.swiping + .pathway-actions-revealed {
            opacity: 1;
        }
        
        .pathway-info {
            display: flex;
            flex-direction: column;
            flex: 1;
        }
        
        .pathway-name-sidebar {
            font-weight: 600;
            color: #40E0D0;
        }
        
        .pathway-status-sidebar {
            font-size: 11px;
            color: rgba(255,255,255,0.6);
            margin-top: 2px;
        }
        
        .pathway-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00ff00;
            animation: pulse 2s infinite;
            margin-left: 8px;
        }

        .menu-icon {
            font-size: 18px;
        }

        /* Main Chat Area */
        .main-chat {
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(5px);
            display: flex;
            flex-direction: column;
            position: relative;
            height: 100%;
            overflow: hidden;
        }

        .chat-header {
            padding: 15px 70px 15px 20px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .chat-title {
            font-size: 16px;
            font-weight: 500;
            color: rgba(255,255,255,0.8);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-badge {
            font-size: 12px;
            padding: 4px 8px;
            background: rgba(0,255,0,0.1);
            border: 1px solid rgba(0,255,0,0.3);
            border-radius: 12px;
            color: #00ff00;
        }

        .chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(64,224,208,0.3) rgba(0,0,0,0.3);
            min-height: 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
            position: relative;
        }
        
        .synapse-watermark {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 8vw;
            font-weight: 900;
            color: rgba(64,224,208,0.02);
            pointer-events: none;
            z-index: 0;
            user-select: none;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            transition: opacity 1s ease-out;
        }
        
        .synapse-watermark.fade-out {
            opacity: 0;
        }

        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }

        .chat-messages::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.3);
        }

        .chat-messages::-webkit-scrollbar-thumb {
            background: rgba(64,224,208,0.3);
            border-radius: 3px;
        }

        .message {
            padding: 15px;
            border-radius: 12px;
            animation: fadeIn 0.3s ease;
            flex-shrink: 0;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .message.user {
            background: linear-gradient(135deg, rgba(64,224,208,0.2), rgba(72,202,228,0.2));
            border: 1px solid rgba(64,224,208,0.3);
            margin-left: 15%;
        }

        .message.ai {
            background: linear-gradient(135deg, rgba(255,255,255,0.05), rgba(255,255,255,0.1));
            border: 1px solid rgba(255,255,255,0.2);
            margin-right: 15%;
        }

        .message-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 600;
        }

        .message-content {
            line-height: 1.6;
        }

        /* Chat Input */
        .chat-input-area {
            padding: 20px;
            border-top: 1px solid rgba(255,255,255,0.1);
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .chat-input {
            flex: 1;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 25px;
            padding: 12px 20px;
            color: white;
            font-size: 14px;
            outline: none;
            transition: all 0.3s ease;
        }

        .chat-input:focus {
            border-color: rgba(64,224,208,0.5);
            background: rgba(255,255,255,0.15);
        }

        .chat-input::placeholder {
            color: rgba(255,255,255,0.5);
        }

        .send-button {
            background: linear-gradient(135deg, rgba(64,224,208,0.1), rgba(72,202,228,0.1));
            border: 1px solid rgba(64,224,208,0.3);
            border-radius: 50%;
            width: 45px;
            height: 45px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .send-button::before {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: linear-gradient(45deg, #40E0D0, #48CAE4);
            clip-path: polygon(0 0, 100% 50%, 0 100%, 25% 50%);
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            filter: drop-shadow(0 0 4px rgba(64,224,208,0.4));
        }
        
        .send-button::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at center, transparent 60%, rgba(64,224,208,0.1) 100%);
            border-radius: 50%;
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        }

        .send-button:hover {
            border-color: rgba(64,224,208,0.6);
            background: linear-gradient(135deg, rgba(64,224,208,0.2), rgba(72,202,228,0.2));
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(64,224,208,0.3);
        }
        
        .send-button:hover::before {
            transform: scale(1.1);
            filter: drop-shadow(0 0 8px rgba(64,224,208,0.6));
            background: linear-gradient(45deg, #48CAE4, #00ff88);
        }
        
        .send-button:hover::after {
            opacity: 1;
        }
        
        .send-button:active {
            transform: scale(0.95);
            background: linear-gradient(135deg, rgba(64,224,208,0.3), rgba(72,202,228,0.3));
        }

        /* Right Panel - Hidden by default */
        .right-panel {
            display: none;
        }

        .pathway-item {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .pathway-item:hover {
            background: rgba(64,224,208,0.1);
            border-color: rgba(64,224,208,0.3);
        }

        .pathway-name {
            font-weight: 600;
            margin-bottom: 5px;
        }

        .pathway-status {
            font-size: 12px;
            color: rgba(255,255,255,0.7);
        }

        /* Buttons */
        .btn {
            background: linear-gradient(45deg, rgba(64,224,208,0.2), rgba(72,202,228,0.2));
            border: 1px solid rgba(64,224,208,0.5);
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .btn:hover {
            background: linear-gradient(45deg, rgba(64,224,208,0.3), rgba(72,202,228,0.3));
            transform: translateY(-1px);
        }

        /* Blur Shield */
        .blur-shield {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            backdrop-filter: blur(10px);
            background: rgba(0,0,0,0.8);
            z-index: 9999;
            display: none;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            font-weight: 600;
        }

        /* MOBILE-FIRST RESPONSIVE DESIGN */
        
        /* iPhone and small devices */
        @media (max-width: 480px) {
            .synapse-container {
                grid-template-rows: 50px 1fr;
            }
            
            .header-bar {
                padding: 0 12px;
            }
            
            .logo {
                font-size: 18px;
            }
            
            .sidebar {
                width: 90vw !important;
                left: -90vw !important;
                transition: left 0.2s cubic-bezier(0.4, 0.0, 0.2, 1) !important;
                -webkit-transition: left 0.2s cubic-bezier(0.4, 0.0, 0.2, 1) !important;
            }
            
            .sidebar.open {
                left: 0 !important;
            }
            
            .sidebar-overlay {
                transition: opacity 0.2s cubic-bezier(0.4, 0.0, 0.2, 1) !important;
                -webkit-transition: opacity 0.2s cubic-bezier(0.4, 0.0, 0.2, 1) !important;
            }
            
            .pathway-chat-window {
                width: 95vw !important;
                height: 85vh !important;
                top: 7.5vh !important;
                left: 2.5vw !important;
                max-width: none !important;
                max-height: none !important;
                transform: none !important;
                border-radius: 12px;
            }
            
            .chat-input, .pathway-input {
                font-size: 16px !important;
                padding: 14px 18px !important;
                min-height: 50px !important;
            }
            
            .send-button, .pathway-send-btn {
                width: 50px !important;
                height: 50px !important;
                min-width: 50px !important;
                min-height: 50px !important;
            }
            
            .menu-item, .pathway-item-sidebar {
                padding: 18px 14px !important;
                min-height: 54px !important;
                font-size: 16px !important;
            }
            
            .pathway-close-btn, .sidebar-close {
                width: 50px !important;
                height: 50px !important;
                min-width: 50px !important;
                min-height: 50px !important;
                font-size: 22px !important;
            }
        }
        
        /* Medium mobile devices */
        @media (max-width: 768px) and (min-width: 481px) {
            .sidebar {
                width: 85vw;
                left: -85vw;
            }
            
            .sidebar.open {
                left: 0;
            }
            
            .pathway-chat-window {
                width: 92%;
                height: 80%;
                top: 8%;
                left: 4%;
                transform: none;
            }
            
            .menu-item {
                padding: 16px 12px;
                font-size: 16px;
                min-height: 52px;
            }
            
            .pathway-item-sidebar {
                padding: 16px 12px;
                font-size: 15px;
                min-height: 52px;
            }
            
            .pathway-close-btn,
            .sidebar-close {
                width: 48px;
                height: 48px;
                font-size: 20px;
            }
            
            .pathway-send-btn {
                width: 48px;
                height: 48px;
            }
        }
        
        /* ENHANCED TOUCH DEVICE OPTIMIZATIONS */
        @media (hover: none) and (pointer: coarse) {
            /* Disable hover effects on touch devices */
            .menu-item:hover,
            .pathway-item-sidebar:hover,
            .btn:hover,
            .pathway-close-btn:hover,
            .pathway-send-btn:hover::before,
            .pathway-send-btn:hover::after {
                transform: none !important;
                background: initial !important;
                border-color: initial !important;
                box-shadow: initial !important;
            }
            
            /* Add proper touch feedback */
            .menu-item:active,
            .pathway-item-sidebar:active {
                background: rgba(64,224,208,0.2) !important;
                transform: scale(0.96);
                transition: all 0.1s ease;
            }
            
            button:active,
            .btn:active,
            [onclick]:active {
                transform: scale(0.95);
                background: rgba(64,224,208,0.3) !important;
                transition: all 0.1s ease;
            }
        }

        /* Pathway Chat Window */
        .pathway-chat-window {
            position: fixed;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 800px;
            height: 70%;
            background: rgba(0,0,0,0.95);
            backdrop-filter: blur(15px);
            border: 2px solid #40E0D0;
            border-radius: 15px;
            z-index: 2000;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .pathway-chat-header {
            background: linear-gradient(135deg, rgba(64,224,208,0.2), rgba(72,202,228,0.2));
            padding: 15px 20px;
            border-bottom: 1px solid rgba(64,224,208,0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .pathway-chat-title {
            font-size: 16px;
            font-weight: 600;
            color: #40E0D0;
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            position: relative;
        }
        
        .pathway-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            background: rgba(0,0,0,0.95);
            border: 2px solid #40E0D0;
            border-radius: 8px;
            min-width: 200px;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 20px rgba(64,224,208,0.3);
        }
        
        .pathway-dropdown.show {
            display: block;
        }
        
        .pathway-dropdown > div {
            padding: 12px 16px;
            color: white;
            cursor: pointer;
            border-bottom: 1px solid rgba(64,224,208,0.1);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .pathway-dropdown > div:last-child {
            border-bottom: none;
        }
        
        .pathway-dropdown > div:hover {
            background: rgba(64,224,208,0.1);
        }
        
        .pathway-close-btn {
            background: none;
            border: none;
            color: #40E0D0;
            font-size: 24px;
            cursor: pointer;
            padding: 5px;
            border-radius: 50%;
            transition: all 0.3s ease;
        }
        
        .pathway-close-btn:hover {
            background: rgba(64,224,208,0.1);
            transform: rotate(90deg);
        }
        
        .pathway-chat-messages {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .pathway-message {
            padding: 12px 16px;
            border-radius: 12px;
            max-width: 80%;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .pathway-message.own {
            align-self: flex-end;
            background: linear-gradient(135deg, rgba(64,224,208,0.3), rgba(72,202,228,0.3));
            border: 1px solid rgba(64,224,208,0.4);
        }
        
        .pathway-message.peer {
            align-self: flex-start;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        .pathway-message-header {
            font-size: 12px;
            opacity: 0.7;
            margin-bottom: 5px;
        }
        
        .pathway-input-area {
            padding: 15px 20px;
            border-top: 1px solid rgba(64,224,208,0.3);
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .pathway-input {
            flex: 1;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 20px;
            padding: 10px 16px;
            color: white;
            outline: none;
            transition: all 0.3s ease;
        }
        
        .pathway-input:focus {
            border-color: rgba(64,224,208,0.5);
            background: rgba(255,255,255,0.15);
        }
        
        .pathway-send-btn {
            background: none;
            border: none;
            width: 44px;
            height: 44px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            position: relative;
            padding: 8px;
        }
        
        .pathway-send-btn::before {
            content: '';
            position: absolute;
            width: 22px;
            height: 22px;
            background: linear-gradient(45deg, #40E0D0, #48CAE4);
            clip-path: polygon(0 0, 100% 50%, 0 100%, 25% 50%);
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            filter: drop-shadow(0 0 4px rgba(64,224,208,0.4));
        }
        
        .pathway-send-btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at center, rgba(64,224,208,0.1) 0%, transparent 70%);
            opacity: 0;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
            border-radius: 50%;
        }
        
        .pathway-send-btn:hover {
            transform: scale(1.05);
        }
        
        .pathway-send-btn:hover::before {
            transform: scale(1.15);
            filter: drop-shadow(0 0 8px rgba(64,224,208,0.6));
            background: linear-gradient(45deg, #48CAE4, #00ff88);
        }
        
        .pathway-send-btn:hover::after {
            opacity: 1;
        }
        
        .pathway-send-btn:active {
            transform: scale(0.95);
        }
        
        .pathway-send-btn:active::before {
            filter: drop-shadow(0 0 12px rgba(64,224,208,0.8));
        }
        
        /* Mobile Responsive Improvements */
        @media (max-width: 768px) {
            .pathway-chat-window {
                width: 95vw !important;
                height: 80vh !important;
                left: 2.5vw !important;
                top: 10vh !important;
                max-width: none !important;
                max-height: none !important;
            }
            
            .pathway-dropdown {
                min-width: 150px !important;
                font-size: 14px !important;
            }
            
            .pathway-dropdown > div {
                padding: 12px 16px !important;
                font-size: 14px !important;
                touch-action: manipulation;
            }
            
            .sidebar {
                width: 85% !important;
                max-width: 320px !important;
            }
            
            .pathway-item-sidebar {
                padding: 16px 12px !important;
                font-size: 16px !important;
            }
            
            .pathway-name-sidebar {
                font-size: 16px !important;
            }
            
            .pathway-status-sidebar {
                font-size: 13px !important;
            }
        }
        
        /* ULTIMATE TOUCH-FRIENDLY OPTIMIZATION */
        @media (hover: none) and (pointer: coarse) {
            /* Ensure all interactive elements have proper touch targets */
            .menu-item, 
            .pathway-item-sidebar {
                min-height: 52px !important;
                display: flex !important;
                align-items: center !important;
                padding: 18px 14px !important;
                font-size: 16px !important;
                touch-action: manipulation !important;
                -webkit-tap-highlight-color: rgba(64,224,208,0.4) !important;
                position: relative !important;
                z-index: 1 !important;
            }
            
            button, 
            .button, 
            [onclick], 
            [role="button"] {
                min-height: 48px !important;
                min-width: 48px !important;
                padding: 14px 18px !important;
                font-size: 16px !important;
                touch-action: manipulation !important;
                -webkit-tap-highlight-color: rgba(64,224,208,0.4) !important;
                cursor: pointer !important;
                user-select: none !important;
                -webkit-user-select: none !important;
                -moz-user-select: none !important;
                -ms-user-select: none !important;
                border: none !important;
                outline: none !important;
                position: relative !important;
                z-index: 1 !important;
            }
            
            .pathway-dropdown > div {
                min-height: 52px !important;
                display: flex !important;
                align-items: center !important;
                padding: 18px 22px !important;
                font-size: 16px !important;
                touch-action: manipulation !important;
                -webkit-tap-highlight-color: rgba(64,224,208,0.4) !important;
                position: relative !important;
                z-index: 1 !important;
            }
            
            .pathway-input, 
            .chat-input, 
            input[type="text"], 
            input {
                font-size: 16px !important;
                padding: 16px 20px !important;
                min-height: 52px !important;
                -webkit-appearance: none !important;
                border-radius: 14px !important;
                touch-action: manipulation !important;
                -webkit-tap-highlight-color: transparent !important;
                position: relative !important;
                z-index: 1 !important;
                border: 2px solid rgba(64,224,208,0.3) !important;
            }
            
            .pathway-input:focus,
            .chat-input:focus,
            input:focus {
                border-color: rgba(64,224,208,0.8) !important;
                outline: none !important;
                box-shadow: 0 0 0 3px rgba(64,224,208,0.2) !important;
            }
            
            .pathway-send-btn, 
            .send-button {
                width: 52px !important;
                height: 52px !important;
                min-width: 52px !important;
                min-height: 52px !important;
                font-size: 20px !important;
                touch-action: manipulation !important;
                -webkit-tap-highlight-color: rgba(64,224,208,0.4) !important;
                cursor: pointer !important;
                user-select: none !important;
                position: relative !important;
                z-index: 1 !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
            }
            
            .pathway-close-btn,
            .sidebar-close {
                min-width: 52px !important;
                min-height: 52px !important;
                width: 52px !important;
                height: 52px !important;
                touch-action: manipulation !important;
                -webkit-tap-highlight-color: rgba(64,224,208,0.4) !important;
                font-size: 24px !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                position: relative !important;
                z-index: 1 !important;
            }
            
            /* Fix hamburger menu */
            .menu-toggle {
                width: 52px !important;
                height: 52px !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                touch-action: manipulation !important;
                -webkit-tap-highlight-color: rgba(64,224,208,0.4) !important;
                position: relative !important;
                z-index: 1 !important;
            }
            
            .hamburger span {
                touch-action: none !important;
                pointer-events: none !important;
            }
        }
        
        /* UNIVERSAL TOUCH SUPPORT - iPhone and Android Compatible */
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        button, 
        .button, 
        [onclick], 
        [role="button"],
        .menu-item,
        .pathway-item-sidebar {
            touch-action: manipulation !important;
            -webkit-tap-highlight-color: rgba(64,224,208,0.4) !important;
            -webkit-touch-callout: none !important;
            -webkit-user-select: none !important;
            -moz-user-select: none !important;
            -ms-user-select: none !important;
            user-select: none !important;
            cursor: pointer !important;
            position: relative !important;
            z-index: 1 !important;
        }
        
        input, 
        textarea, 
        select,
        .chat-input,
        .pathway-input {
            touch-action: manipulation !important;
            -webkit-tap-highlight-color: transparent !important;
            -webkit-user-select: text !important;
            -moz-user-select: text !important;
            -ms-user-select: text !important;
            user-select: text !important;
            -webkit-appearance: none !important;
            border-radius: 12px !important;
        }
        
        /* Ensure clickable elements respond properly to touch */
        .menu-item, 
        .pathway-item-sidebar, 
        .pathway-dropdown > div {
            touch-action: manipulation !important;
            -webkit-tap-highlight-color: rgba(64,224,208,0.4) !important;
            user-select: none !important;
            cursor: pointer !important;
            display: flex !important;
            align-items: center !important;
            position: relative !important;
            z-index: 1 !important;
        }
        
        /* Fix send button for touch */
        .pathway-send-btn,
        .send-button {
            touch-action: manipulation !important;
            -webkit-tap-highlight-color: rgba(64,224,208,0.4) !important;
            user-select: none !important;
            pointer-events: auto !important;
            position: relative !important;
            z-index: 1 !important;
            cursor: pointer !important;
            border: none !important;
            outline: none !important;
        }
        
        /* Ensure pseudo-elements don't interfere with touch */
        .pathway-send-btn::before,
        .pathway-send-btn::after,
        .send-button::before,
        .send-button::after {
            pointer-events: none !important;
            touch-action: none !important;
            z-index: 0 !important;
        }
        
        /* Prevent background elements from stealing touch events */
        .synapse-container::before,
        body::before {
            pointer-events: none !important;
            touch-action: none !important;
        }
        
        /* Fix hamburger menu touch */
        .menu-toggle {
            touch-action: manipulation !important;
            -webkit-tap-highlight-color: rgba(64,224,208,0.4) !important;
            cursor: pointer !important;
            position: relative !important;
            z-index: 10 !important;
        }
        
        .hamburger,
        .hamburger span {
            pointer-events: none !important;
            touch-action: none !important;
        }
        
        /* Utility Classes */
        .hidden { display: none; }
        .active { opacity: 1; }
        .inactive { opacity: 0.5; }
    </style>
    
    <!-- Socket.IO Client (for P2P signaling) -->
    <script src="./Synapse - Decentralized AI Network_files/socket.io.min.js.download" integrity="sha384-mZLF4UVrpi/QTWPA7BjNPEnkIfRFn9ZAC2021hsANZJlQ4qzNJJMSpGMKZINKHkV" crossorigin="anonymous"></script>
    
    <!-- QR Code Generation Library -->
<link id="cyberpunkFonts" href="./Synapse - Decentralized AI Network_files/css2" rel="stylesheet"><style>
                @keyframes neuralBoot {
                    0% { 
                        transform: scale(0.3) rotateY(180deg); 
                        opacity: 0; 
                        filter: blur(20px) hue-rotate(180deg);
                    }
                    30% { 
                        transform: scale(1.1) rotateY(0deg); 
                        opacity: 0.7; 
                        filter: blur(5px) hue-rotate(90deg);
                    }
                    100% { 
                        transform: scale(1) rotateY(0deg); 
                        opacity: 1; 
                        filter: blur(0px) hue-rotate(0deg);
                    }
                }
                
                @keyframes gradientShift {
                    0%, 100% { background-position: 0% 50%; }
                    50% { background-position: 100% 50%; }
                }
                
                @keyframes logoGlow {
                    0% { filter: drop-shadow(0 0 20px rgba(64,224,208,0.8)); }
                    100% { filter: drop-shadow(0 0 40px rgba(64,224,208,1)) drop-shadow(0 0 80px rgba(0,255,136,0.5)); }
                }
                
                @keyframes logoScale {
                    0%, 100% { transform: scale(1); }
                    50% { transform: scale(1.02); }
                }
                
                @keyframes subtitleGlow {
                    0% { text-shadow: 0 0 10px rgba(64,224,208,0.5); }
                    100% { text-shadow: 0 0 20px rgba(64,224,208,0.8), 0 0 40px rgba(64,224,208,0.4); }
                }
                
                @keyframes textGlow {
                    0% { text-shadow: 0 0 5px rgba(0,0,0,0.5); }
                    100% { text-shadow: 0 0 5px rgba(0,0,0,0.5), 0 0 15px rgba(64,224,208,0.3); }
                }
                
                @keyframes shimmer {
                    0% { transform: translateX(-100%) translateY(-100%); }
                    100% { transform: translateX(200%) translateY(200%); }
                }
                
                @keyframes dataStream {
                    0% { transform: translateX(-100%); opacity: 0; }
                    20% { opacity: 1; }
                    80% { opacity: 1; }
                    100% { transform: translateX(100%); opacity: 0; }
                }
                
                @keyframes warningPulse {
                    0%, 100% { 
                        border-color: rgba(255,20,147,0.6);
                        box-shadow: 0 0 10px rgba(255,20,147,0.3);
                    }
                    50% { 
                        border-color: rgba(255,20,147,1);
                        box-shadow: 0 0 25px rgba(255,20,147,0.6), inset 0 0 20px rgba(255,20,147,0.1);
                    }
                }
                
                @keyframes warningSwipe {
                    0% { left: -100%; }
                    100% { left: 100%; }
                }
                
                @keyframes buttonGlow {
                    0% { 
                        box-shadow: 
                            0 0 30px rgba(64,224,208,0.6),
                            0 0 60px rgba(64,224,208,0.3),
                            inset 0 0 30px rgba(255,255,255,0.1);
                    }
                    100% { 
                        box-shadow: 
                            0 0 50px rgba(64,224,208,0.9),
                            0 0 100px rgba(64,224,208,0.5),
                            0 0 150px rgba(0,255,136,0.3),
                            inset 0 0 50px rgba(255,255,255,0.2);
                    }
                }
                
                @keyframes buttonShine {
                    0% { left: -100%; }
                    100% { left: 100%; }
                }
                
                @keyframes statusBlink {
                    0%, 90% { opacity: 0.6; }
                    95% { opacity: 1; }
                }
                
                @keyframes scanShift {
                    0% { transform: translateY(0px); }
                    100% { transform: translateY(50px); }
                }
                
                @keyframes matrixRain {
                    0% { transform: translateY(-100vh); opacity: 1; }
                    100% { transform: translateY(100vh); opacity: 0; }
                }
                
                /* ENHANCED MATRIX CHARACTERS */
                .matrix-char {
                    color: rgba(64,224,208,0.8);
                    text-shadow: 0 0 5px rgba(64,224,208,0.5);
                    font-weight: bold;
                }
                
                .matrix-char:nth-child(odd) {
                    color: rgba(0,255,136,0.6);
                    text-shadow: 0 0 3px rgba(0,255,136,0.4);
                }
                
                .matrix-char:nth-child(3n) {
                    color: rgba(72,202,228,0.4);
                    text-shadow: 0 0 2px rgba(72,202,228,0.3);
                }
            </style></head>
<body>
    <!-- Blur Shield for Privacy -->
    <div class="blur-shield" id="blurShield" style="display: none;">
        <!-- Blank screen for privacy -->
    </div>

    <!-- Sidebar Overlay -->
    <div class="sidebar-overlay" id="sidebarOverlay" onclick="closeSidebar()" style="display: none; pointer-events: none; touch-action: manipulation; cursor: pointer;" data-touch-enhanced="true"></div>
    
    <!-- Collapsible Sidebar -->
    <aside class="sidebar" id="sidebar">
        <div class="sidebar-header">
            <div class="sidebar-title"> SYNAPSE</div>
            <button class="sidebar-close" onclick="closeSidebar()" data-touch-enhanced="true" style="touch-action: manipulation; cursor: pointer;"></button>
        </div>
        
        <div class="sidebar-content">
            <div class="panel-section">
                <div class="panel-title">System Status</div>
                <div style="background: rgba(255,255,255,0.05); border-radius: 8px; padding: 12px; margin-bottom: 15px;">
                    <div style="font-size: 14px; font-weight: 600; color: #40E0D0; margin-bottom: 8px; display: flex; align-items: center; gap: 8px;">
                        <span>Neural Interface</span>
                    </div>
                    <div class="status-indicator" style="display: flex; align-items: center;">
                        <span id="statusText">Offline Ready</span>
                        <div class="status-dot" id="statusDot" style="margin-left: 10px;"></div>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title">Active Pathways</div>
                <button onclick="promptJoinPathway()" style="width: 100%; background: rgba(64, 224, 208, 0.1); border: 1px solid rgba(64, 224, 208, 0.3); color: rgb(64, 224, 208); padding: 10px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; display: flex; align-items: center; justify-content: center; gap: 6px; margin-bottom: 12px; touch-action: manipulation;" data-touch-enhanced="true">
                    Join with Code
                </button>
                <div id="sidebarPathwaysList"><div class="pathway-swipe-container"><div class="pathway-item-sidebar" data-pathway-id="pw_si0uo0ijuo" style="transform: translateX(0px);">
                            <div class="pathway-info">
                                <div class="pathway-name-sidebar">Demo Pathway</div>
                                <div class="pathway-status-sidebar"> 1 peer</div>
                            </div>
                            <div class="pathway-indicator"></div>
                        </div><div class="pathway-actions-revealed"></div></div></div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title" onclick="toggleSection(&#39;ai-brain&#39;)" data-touch-enhanced="true" style="touch-action: manipulation; cursor: pointer;">
                    <span>AI Brain</span>
                    <span class="collapse-arrow collapsed" id="arrow-ai-brain"></span>
                </div>
                <div class="panel-content collapsed" id="content-ai-brain">
                    <div class="menu-item" onclick="toggleAISettings(); closeSidebar();" data-touch-enhanced="true" style="touch-action: manipulation; cursor: pointer;">
                        <span>Settings</span>
                    </div>
                    <div class="menu-item" onclick="showMemoryTools(); closeSidebar();" data-touch-enhanced="true" style="touch-action: manipulation; cursor: pointer;">
                        <span>Memory (FCS)</span>
                    </div>
                    <div class="menu-item" onclick="toggleAPIConfig(); closeSidebar();" data-touch-enhanced="true" style="touch-action: manipulation; cursor: pointer;">
                        <span>API Config</span>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title" onclick="toggleSection(&#39;network&#39;)" data-touch-enhanced="true" style="touch-action: manipulation; cursor: pointer;">
                    <span>Network</span>
                    <span class="collapse-arrow collapsed" id="arrow-network"></span>
                </div>
                <div class="panel-content collapsed" id="content-network">
                    <div class="menu-item" onclick="createPathway(); closeSidebar();" data-touch-enhanced="true" style="touch-action: manipulation; cursor: pointer;">
                        <span>Create Pathway</span>
                    </div>
                    <div class="menu-item" onclick="joinPathway(); closeSidebar();" data-touch-enhanced="true" style="touch-action: manipulation; cursor: pointer;">
                        <span>Join Pathway</span>
                    </div>
                    <div class="menu-item" onclick="toggleBlurShield(); closeSidebar();" data-touch-enhanced="true" style="touch-action: manipulation; cursor: pointer;">
                        <span>Blur Shield</span>
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title" onclick="toggleSection(&#39;tools&#39;)" data-touch-enhanced="true" style="touch-action: manipulation; cursor: pointer;">
                    <span>Tools</span>
                    <span class="collapse-arrow collapsed" id="arrow-tools"></span>
                </div>
                <div class="panel-content collapsed" id="content-tools">
                    <div class="menu-item" onclick="exportMemory(); closeSidebar();" data-touch-enhanced="true" style="touch-action: manipulation; cursor: pointer;">
                        <span>Export Seeds</span>
                    </div>
                    <div class="menu-item" onclick="importMemory(); closeSidebar();" data-touch-enhanced="true" style="touch-action: manipulation; cursor: pointer;">
                        <span>Import Seeds</span>
                    </div>
                    <div class="menu-item" onclick="clearMemory(); closeSidebar();" data-touch-enhanced="true" style="touch-action: manipulation; cursor: pointer;">
                        <span>Clear Memory</span>
                    </div>
                </div>
            </div>
        </div>
    </aside>
    
    <div class="synapse-container">
        <!-- Header Bar -->
        <header class="header-bar">
            <div class="menu-toggle" id="menuToggle" onclick="toggleSidebar()" data-touch-enhanced="true" style="touch-action: manipulation; cursor: pointer;">
                <div class="hamburger" id="hamburger">
                    <span></span>
                    <span></span>
                    <span></span>
                </div>
            </div>
            <div class="logo"> SYNAPSE</div>
        </header>

        <!-- Main Chat Area -->
        <main class="main-chat">
            <div class="chat-header" style="display: none;">
                <!-- Hidden header for cleaner interface -->
            </div>

            <div class="chat-messages" id="chatMessages">
                <div class="synapse-watermark" id="synapseWatermark">SYNAPSE</div>
            </div>

            <div class="chat-input-area">
                <input type="text" class="chat-input" id="chatInput" placeholder="Ask me anything..." onkeypress="handleKeyPress(event)">
                <button class="send-button" onclick="sendMessage()" data-touch-enhanced="true" style="cursor: pointer; touch-action: manipulation;"></button>
            </div>
        </main>

        <!-- Right Panel - Pathways -->
        <aside class="right-panel">
            <div class="panel-section">
                <div class="panel-title"> Active Pathways</div>
                <div id="pathwaysList"><div class="pathway-item">
                            <div class="pathway-name">Demo Pathway</div>
                            <div class="pathway-status"> 1 peer</div>
                        </div></div>
                <div class="btn" onclick="createPathway()" style="width: 100%; text-align: center; margin-top: 10px; touch-action: manipulation; cursor: pointer;" data-touch-enhanced="true">
                    + New Pathway
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title"> Connected Peers</div>
                <div id="peersList">
                    <div style="text-align: center; opacity: 0.5; padding: 20px;">
                        No active connections
                    </div>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-title"> Network Stats</div>
                <div style="font-size: 12px; opacity: 0.7;">
                    <div>Memory Nodes: <span id="memoryNodes">0</span></div>
                    <div>Pathways: <span id="pathwayCount">1</span></div>
                    <div>Total Peers: <span id="peerCount">0</span></div>
                </div>
            </div>
        </aside>
    </div>

    <script>
        // ============================================================================
        // SYNAPSE - DECENTRALIZED AI SYSTEM
        // Core JavaScript Implementation
        // ============================================================================

        // Global State Management
        const SynapseCore = {
            config: {
                apiProviders: {
                    offline: { enabled: true, name: 'Local AI' },
                    openai: { enabled: false, apiKey: null, name: 'OpenAI GPT' },
                    gemini: { enabled: false, apiKey: null, name: 'Google Gemini' },
                    other: { enabled: false, apiKey: null, name: 'Custom API', endpoint: null }
                },
                activeAgent: 'offline',
                multiAgentMode: false,
                blurShieldEnabled: false,
                nickname: 'Node_' + Math.random().toString(36).substr(2, 6)
            },
            
            memory: {
                concepts: new Map(),
                embeddings: new Map(),
                experiences: []
            },
            
            pathways: new Map(),
            peers: new Map(),
            
            // WebRTC Connection Management
            rtcConnections: new Map(),
            dataChannels: new Map(),
            
            // Initialize the system
            init() {
                this.loadMemoryFromStorage();
                this.setupBlurShield();
                this.initializeOfflineAI();
                console.log(' Synapse Core initialized');
            }
        };

        // ============================================================================
        // FRACTAL COMPRESSION SYSTEM (FCS) - Memory Management
        // ============================================================================
        
        class FractalMemory {
            constructor() {
                this.concepts = new Map();
                this.embeddings = new Map();
                this.associations = new Map();
            }
            
            // Simple embedding generation (TF-IDF style)
            generateEmbedding(text) {
                const words = text.toLowerCase().match(/\w+/g) || [];
                const embedding = new Array(100).fill(0);
                
                words.forEach((word, index) => {
                    const hash = this.simpleHash(word);
                    embedding[hash % 100] += 1 / Math.sqrt(words.length);
                });
                
                return this.normalizeVector(embedding);
            }
            
            simpleHash(str) {
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return Math.abs(hash);
            }
            
            normalizeVector(vector) {
                const magnitude = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));
                return magnitude > 0 ? vector.map(val => val / magnitude) : vector;
            }
            
            // Cosine similarity calculation
            cosineSimilarity(a, b) {
                if (a.length !== b.length) return 0;
                
                let dotProduct = 0;
                let normA = 0;
                let normB = 0;
                
                for (let i = 0; i < a.length; i++) {
                    dotProduct += a[i] * b[i];
                    normA += a[i] * a[i];
                    normB += b[i] * b[i];
                }
                
                return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));
            }
            
            // Store concept with embedding
            storeConcept(text, context = {}) {
                const embedding = this.generateEmbedding(text);
                const conceptId = 'concept_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6);
                
                this.concepts.set(conceptId, {
                    text,
                    context,
                    embedding,
                    timestamp: Date.now(),
                    relevance: 1.0
                });
                
                return conceptId;
            }
            
            // Find similar concepts
            findSimilarConcepts(text, threshold = 0.7, limit = 5) {
                const queryEmbedding = this.generateEmbedding(text);
                const similarities = [];
                
                for (const [id, concept] of this.concepts) {
                    const similarity = this.cosineSimilarity(queryEmbedding, concept.embedding);
                    if (similarity >= threshold) {
                        similarities.push({ id, concept, similarity });
                    }
                }
                
                return similarities
                    .sort((a, b) => b.similarity - a.similarity)
                    .slice(0, limit);
            }
            
            // Reinforce concept relevance
            reinforceConcept(conceptId, feedback = 1) {
                if (this.concepts.has(conceptId)) {
                    const concept = this.concepts.get(conceptId);
                    concept.relevance = Math.min(2.0, concept.relevance + feedback * 0.1);
                    concept.lastAccessed = Date.now();
                }
            }
        }

        // ============================================================================
        // API INTEGRATION SYSTEM
        // ============================================================================
        
        class APIIntegration {
            constructor() {
                this.providers = {
                    openai: {
                        endpoint: 'https://api.openai.com/v1/chat/completions',
                        headers: (apiKey) => ({
                            'Authorization': `Bearer ${apiKey}`,
                            'Content-Type': 'application/json'
                        }),
                        formatRequest: (messages) => ({
                            model: 'gpt-3.5-turbo',
                            messages: messages,
                            max_tokens: 500,
                            temperature: 0.7
                        })
                    },
                    gemini: {
                        endpoint: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent',
                        headers: (apiKey) => ({
                            'Content-Type': 'application/json'
                        }),
                        formatRequest: (messages) => ({
                            contents: [{
                                parts: [{ text: messages[messages.length - 1].content }]
                            }],
                            generationConfig: {
                                temperature: 0.7,
                                topK: 1,
                                topP: 1,
                                maxOutputTokens: 500
                            }
                        }),
                        formatUrl: (apiKey) => `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${apiKey}`
                    }
                };
            }
            
            async callAPI(provider, messages, apiKey) {
                if (!this.providers[provider]) {
                    throw new Error(`Unsupported provider: ${provider}`);
                }
                
                const config = this.providers[provider];
                const url = config.formatUrl ? config.formatUrl(apiKey) : config.endpoint;
                
                try {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: config.headers(apiKey),
                        body: JSON.stringify(config.formatRequest(messages))
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({}));
                        throw new Error(`API Error: ${response.status} - ${errorData.error?.message || 'Unknown error'}`);
                    }
                    
                    const data = await response.json();
                    return this.extractResponse(provider, data);
                    
                } catch (error) {
                    console.error(`${provider} API error:`, error);
                    throw error;
                }
            }
            
            extractResponse(provider, data) {
                switch (provider) {
                    case 'openai':
                        return data.choices?.[0]?.message?.content || 'No response generated';
                    case 'gemini':
                        return data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response generated';
                    default:
                        return 'Unknown provider response format';
                }
            }
        }
        
        // ============================================================================
        // QR CODE AND DOWNLOAD FUNCTIONS
        // ============================================================================
        
        function showPathwayQR(pathwayId) {
            const pathway = pathwayNetwork.pathways.get(pathwayId);
            if (!pathway) {
                alert(' Pathway not found');
                return;
            }
            const inviteCode = pathwayNetwork.generateInviteCode(pathwayId, pathway.name);
            const baseUrl = window.location.origin;
            const joinLink = `${baseUrl}/join/${pathwayId}?i=${encodeURIComponent(inviteCode)}`;
            
            // QR disabled: just copy link to clipboard
            try {
                copyToClipboard(joinLink);
                alert(' Join link copied to clipboard');
            } catch (e) {
                alert(`Join link:\n${joinLink}`);
            }
        }
        
        async function showMagicCardModal(pathwayName, joinLink, inviteCode) {
            // QR disabled: copy link as a fallback
            try {
                copyToClipboard(joinLink);
                alert(' Join link copied to clipboard');
            } catch (e) {
                alert(`Join link:\n${joinLink}`);
            }
        }
        
        // QR disabled: no modal implementation
        async function showSimpleQRModal(pathwayName, joinLink, inviteCode) {
            try {
                copyToClipboard(joinLink);
                alert(' Join link copied to clipboard');
            } catch (e) {
                alert(`Join link:\n${joinLink}`);
            }
        }
        // Test QR generation function (for debugging)
        async function testQRGeneration() {
            try {
                const testData = 'https://example.com/test';
                console.log('Testing QR generation...');
                const result = await qrGenerator.generateQR(testData, 300);
                console.log('QR Test Result:', result);
                
                if (result.success) {
                    console.log(' QR generation test passed!');
                    
                    // Create a test modal to show the QR
                    const testModal = document.createElement('div');
                    testModal.style.cssText = `
                        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                        background: rgba(0,0,0,0.9); z-index: 15000;
                        display: flex; align-items: center; justify-content: center;
                    `;
                    testModal.innerHTML = `
                        <div style="background: white; padding: 20px; border-radius: 10px; text-align: center;">
                            <h3>QR Test - Success!</h3>
                            <img src="${result.dataUrl}" style="max-width: 300px;" />
                            <br><br>
                            <button onclick="this.parentElement.parentElement.remove()" 
                                    style="padding: 10px 20px; background: #40E0D0; border: none; border-radius: 5px; cursor: pointer;">
                                Close Test
                            </button>
                        </div>
                    `;
                    document.body.appendChild(testModal);
                } else {
                    console.error(' QR generation test failed:', result.error);
                }
            } catch (error) {
                console.error(' QR test error:', error);
            }
        }
        
        
        function downloadSynapse() {
            appDownloader.generateDownloadPackage().then(success => {
                if (success) {
                    alert(' Synapse app downloaded!\n\nShare this file with others so they can join your pathways.');
                } else {
                    alert(' Download failed. Please try again.');
                }
            });
        }
        
        // ============================================================================
        // ENHANCED AI BRAIN WITH API INTEGRATION
        // ============================================================================
        
        class OfflineAI {
            constructor(memory) {
                this.memory = memory;
                this.apiIntegration = new APIIntegration();
                this.messageHistory = [];
                this.responsePatterns = [
                    { pattern: /hello|hi|hey/i, responses: ["Hello! What can I help you with?", "Hi there! What's on your mind?", "Hey! What would you like to explore?"] },
                    { pattern: /how are you/i, responses: ["I'm doing well, thanks for asking! How can I assist you?", "All systems running smoothly! What brings you here today?", "I'm ready to help! What's your question?"] },
                    { pattern: /what.*synapse/i, responses: ["Synapse is a decentralized AI that learns from our conversations and connects through secure pathways.", "I'm an AI that operates locally on your device and can connect with other nodes securely."] },
                    { pattern: /pathways?/i, responses: ["Pathways let you chat securely with others through encrypted peer-to-peer connections.", "Think of pathways as private chat rooms with end-to-end encryption."] },
                    { pattern: /memory|remember/i, responses: ["I learn from our conversations to provide better responses over time.", "My memory helps me understand context and give more relevant answers."] },
                    { pattern: /help|what.*do/i, responses: ["I can answer questions, have conversations, help with tasks, or connect you with others through pathways. What interests you?", "I'm here to chat, answer questions, or help with whatever you need. What's on your mind?"] },
                    { pattern: /thanks|thank you/i, responses: ["You're welcome!", "Happy to help!", "Anytime!"] },
                    { pattern: /bye|goodbye/i, responses: ["See you later!", "Take care!", "Goodbye! Feel free to come back anytime."] }
                ];
            }
            
            async generateResponse(input, context = {}) {
                // Store the input as a concept
                const conceptId = this.memory.storeConcept(input, { type: 'user_input', ...context });
                
                // Add to message history for API context
                this.messageHistory.push({ role: 'user', content: input });
                if (this.messageHistory.length > 10) {
                    this.messageHistory = this.messageHistory.slice(-10);
                }
                
                // Find similar past concepts
                const similarConcepts = this.memory.findSimilarConcepts(input, 0.5, 3);
                
                // Multi-agent mode: try all enabled providers
                if (SynapseCore.config.multiAgentMode) {
                    return await this.generateMultiAgentResponse(input, similarConcepts);
                }
                
                // Single agent mode: use active agent
                const activeProvider = SynapseCore.config.activeAgent;
                const providerConfig = SynapseCore.config.apiProviders[activeProvider];
                
                if (activeProvider !== 'offline' && providerConfig?.enabled && providerConfig?.apiKey) {
                    try {
                        const apiResponse = await this.generateAPIResponse(input, similarConcepts, activeProvider);
                        if (apiResponse) {
                            this.memory.storeConcept(apiResponse, { type: 'ai_response', provider: activeProvider });
                            this.messageHistory.push({ role: 'assistant', content: apiResponse });
                            return apiResponse;
                        }
                    } catch (error) {
                        console.warn(`${activeProvider} API call failed, falling back to offline mode:`, error);
                    }
                }
                
                // Fallback to offline processing
                return await this.generateOfflineResponse(input, similarConcepts);
            }
            
            async generateAPIResponse(input, similarConcepts, provider = null) {
                const activeProvider = provider || SynapseCore.config.activeAgent;
                const providerConfig = SynapseCore.config.apiProviders[activeProvider];
                
                if (!providerConfig?.enabled || !providerConfig?.apiKey) {
                    throw new Error(`Provider ${activeProvider} not configured`);
                }
                
                try {
                    let contextPrompt = `You are ${providerConfig.name}, part of the Synapse decentralized AI network. `;
                    
                    if (similarConcepts.length > 0) {
                        contextPrompt += "Based on previous conversations, I recall: ";
                        contextPrompt += similarConcepts.map(c => c.concept.text.substring(0, 100)).join("; ");
                        contextPrompt += ". ";
                    }
                    
                    contextPrompt += "Please provide a thoughtful, helpful response that acknowledges this context where relevant.";
                    
                    const messages = [
                        { role: 'system', content: contextPrompt },
                        ...this.messageHistory.slice(-5),
                        { role: 'user', content: input }
                    ];
                    
                    const response = await this.apiIntegration.callAPI(
                        activeProvider,
                        messages,
                        providerConfig.apiKey
                    );
                    
                    return `[${providerConfig.name}] ${response}`;
                    
                } catch (error) {
                    console.error(`${activeProvider} API response generation failed:`, error);
                    throw error;
                }
            }
            
            async generateMultiAgentResponse(input, similarConcepts) {
                const enabledProviders = Object.entries(SynapseCore.config.apiProviders)
                    .filter(([key, config]) => config.enabled && (key === 'offline' || config.apiKey))
                    .map(([key]) => key);
                
                if (enabledProviders.length <= 1) {
                    // Fallback to single agent if only one enabled
                    return await this.generateOfflineResponse(input, similarConcepts);
                }
                
                const responses = [];
                
                // Get responses from all enabled agents
                for (const provider of enabledProviders) {
                    try {
                        if (provider === 'offline') {
                            const response = await this.generateOfflineResponse(input, similarConcepts);
                            responses.push(`[Local AI] ${response}`);
                        } else {
                            const response = await this.generateAPIResponse(input, similarConcepts, provider);
                            responses.push(response);
                        }
                    } catch (error) {
                        console.warn(`Agent ${provider} failed:`, error);
                        responses.push(`[${SynapseCore.config.apiProviders[provider]?.name || provider}] (Agent unavailable)`);
                    }
                }
                
                // Combine responses from multiple agents
                const combinedResponse = ` Multi-Agent Response:\n\n${responses.join('\n\n---\n\n')}`;
                this.messageHistory.push({ role: 'assistant', content: combinedResponse });
                return combinedResponse;
            }
            
            async generateOfflineResponse(input, similarConcepts) {
                // Try pattern matching first
                for (const pattern of this.responsePatterns) {
                    if (pattern.pattern.test(input)) {
                        const response = pattern.responses[Math.floor(Math.random() * pattern.responses.length)];
                        
                // Keep responses clean without memory notes
                this.messageHistory.push({ role: 'assistant', content: response });
                return response;
                        
                        this.messageHistory.push({ role: 'assistant', content: response });
                        return response;
                    }
                }
                
                // Generate contextual response based on memory
                if (similarConcepts.length > 0) {
                    const response = this.generateContextualResponse(input, similarConcepts);
                    this.messageHistory.push({ role: 'assistant', content: response });
                    return response;
                }
                
                // Enhanced fallback responses
                const fallbacks = [
                    "That's interesting! Can you tell me more about what you're thinking?",
                    "I'd like to understand better. What specific aspect interests you most?",
                    "Good point. What would you like to explore about this topic?",
                    "I'm curious to hear your perspective. What brought this to mind?",
                    "That's worth discussing. What questions do you have about it?",
                    "Interesting topic. What would be most helpful for me to address?",
                    "I can help with that. What particular angle are you considering?",
                    "Tell me more - what aspect of this is most important to you?"
                ];
                
                const response = fallbacks[Math.floor(Math.random() * fallbacks.length)];
                this.messageHistory.push({ role: 'assistant', content: response });
                return response;
            }
            
            generateMemoryInsight(similarConcepts) {
                // Skip memory insights to keep responses cleaner
                return null;
            }
            
            generateContextualResponse(input, similarConcepts) {
                const responses = [
                    "That's an interesting topic. What specifically would you like to know?",
                    "I can help with that. What aspect are you most curious about?",
                    "Good question! What particular angle interests you most?",
                    "Let me think about that. What would be most helpful for you to know?"
                ];
                
                return responses[Math.floor(Math.random() * responses.length)];
            }
        }

        // ============================================================================
        // ENCRYPTION & SECURITY SYSTEM
        // ============================================================================
        
        class CryptoSystem {
            constructor() {
                this.keyPairs = new Map();
            }
            
            // Generate AES key for symmetric encryption
            async generateAESKey() {
                return await crypto.subtle.generateKey(
                    { name: 'AES-GCM', length: 256 },
                    true,
                    ['encrypt', 'decrypt']
                );
            }
            
            // Encrypt message with AES-GCM
            async encryptMessage(message, key) {
                const encoder = new TextEncoder();
                const data = encoder.encode(message);
                const iv = crypto.getRandomValues(new Uint8Array(12));
                
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    data
                );
                
                return {
                    encrypted: Array.from(new Uint8Array(encrypted)),
                    iv: Array.from(iv),
                    timestamp: Date.now()
                };
            }
            
            // Decrypt message with AES-GCM
            async decryptMessage(encryptedData, key) {
                const encrypted = new Uint8Array(encryptedData.encrypted);
                const iv = new Uint8Array(encryptedData.iv);
                
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    key,
                    encrypted
                );
                
                const decoder = new TextDecoder();
                return decoder.decode(decrypted);
            }
            
            // Simple key derivation from pathway ID
            async derivePathwayKey(pathwayId) {
                const encoder = new TextEncoder();
                const data = encoder.encode(pathwayId + 'synapse_pathway_salt');
                
                const hashBuffer = await crypto.subtle.digest('SHA-256', data);
                return await crypto.subtle.importKey(
                    'raw',
                    hashBuffer,
                    { name: 'AES-GCM' },
                    false,
                    ['encrypt', 'decrypt']
                );
            }
        }
        
        // ============================================================================
        // ENHANCED WEBRTC P2P NETWORKING
        // ============================================================================
        
        class PathwayNetwork {
            constructor() {
                this.localId = SynapseCore.config.nickname;
                this.pathways = new Map();
                this.peers = new Map();
                this.rtcConnections = new Map();
                this.dataChannels = new Map();
                this.cryptoSystem = new CryptoSystem();
                this.messageQueue = new Map(); // For ephemeral messages
                this.socket = null;
                this.isConnected = false;
                
                // WebRTC configuration with multiple STUN servers
                this.rtcConfig = {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' },
                        { urls: 'stun:stun3.l.google.com:19302' },
                        { urls: 'stun:stun4.l.google.com:19302' },
                        // OpenRelay STUN servers (free)
                        { urls: 'stun:openrelay.metered.ca:80' },
                        // Cloudflare STUN servers
                        { urls: 'stun:stun.cloudflare.com:3478' }
                    ],
                    iceCandidatePoolSize: 10
                };
                
                // Initialize socket connection
                this.initSocketConnection();
                
                // Start message cleanup for ephemeral messages
                this.startMessageCleanup();
            }
            
            initSocketConnection() {
                try {
                    // Try to connect to local server, fallback to offline mode
                    if (typeof io !== 'undefined') {
                        this.socket = io('http://localhost:3000');
                        
                        this.socket.on('connect', () => {
                            console.log(' Connected to signaling server');
                            this.isConnected = true;
                            
                            // Register with server
                            this.socket.emit('register', {
                                nickname: this.localId
                            });
                            
                            this.updateStatusIndicator('Connected');
                        });
                        
                        this.socket.on('disconnect', () => {
                            console.log(' Disconnected from signaling server');
                            this.isConnected = false;
                            this.updateStatusIndicator('Offline Ready');
                        });
                        
                        this.socket.on('pathway-created', (data) => {
                            console.log(` Pathway created on server: ${data.name}`);
                        });
                        
                        this.socket.on('pathway-joined', (data) => {
                            console.log(` Joined pathway: ${data.name}`);
                            this.updatePathwaysUI();
                        });
                        
                        this.socket.on('peer-joined', (data) => {
                            console.log(` Peer joined: ${data.nickname}`);
                            const pathway = this.pathways.get(data.pathwayId);
                            if (pathway) {
                                pathway.peers.add(data.peerId);
                                this.updatePathwaysUI();
                                
                                // Initiate P2P connection with new peer
                                if (data.peerId !== this.socket.id && pathway.isHost) {
                                    setTimeout(() => {
                                        this.establishP2PConnection(data.pathwayId, data.peerId, true);
                                    }, 1000);
                                }
                            }
                        });
                        
                        this.socket.on('peer-left', (data) => {
                            console.log(` Peer left: ${data.peerId}`);
                            const pathway = this.pathways.get(data.pathwayId);
                            if (pathway) {
                                pathway.peers.delete(data.peerId);
                                this.updatePathwaysUI();
                            }
                        });
                        
                        this.socket.on('pathway-message', (data) => {
                            this.handleServerMessage(data);
                        });
                        
                        this.socket.on('join-error', (data) => {
                            alert(` Error joining pathway: ${data.message}`);
                        });
                        
                        // Handle WebRTC signaling
                        this.socket.on('webrtc-offer', (data) => {
                            this.handleWebRTCOffer(data);
                        });
                        
                        this.socket.on('webrtc-answer', (data) => {
                            this.handleWebRTCAnswer(data);
                        });
                        
                        this.socket.on('webrtc-ice-candidate', (data) => {
                            this.handleICECandidate(data);
                        });
                        
                    } else {
                        console.log(' Running in offline mode - Socket.IO not available');
                        this.updateStatusIndicator('Offline Ready');
                    }
                } catch (error) {
                    console.log(' Running in offline mode:', error);
                    this.updateStatusIndicator('Offline Ready');
                }
            }
            
            updateStatusIndicator(status) {
                const statusText = document.getElementById('statusText');
                if (statusText) {
                    const p2pCount = this.dataChannels.size;
                    let displayStatus = status;
                    
                    if (p2pCount > 0) {
                        displayStatus += ` (${p2pCount} P2P)`;
                    }
                    
                    statusText.textContent = displayStatus;
                }
            }
            
            // Start ephemeral message cleanup (24h auto-expire)
            startMessageCleanup() {
                setInterval(() => {
                    const now = Date.now();
                    const twentyFourHours = 24 * 60 * 60 * 1000;
                    
                    for (const [pathwayId, messages] of this.messageQueue) {
                        const validMessages = messages.filter(msg => 
                            (now - msg.timestamp) < twentyFourHours
                        );
                        
                        if (validMessages.length !== messages.length) {
                            this.messageQueue.set(pathwayId, validMessages);
                            console.log(` Cleaned ${messages.length - validMessages.length} expired messages from ${pathwayId}`);
                        }
                    }
                }, 60000); // Check every minute
            }
            
            async createPathway(name = 'Pathway_' + Date.now()) {
                const pathwayId = this.generatePathwayId();
                const encryptionKey = await this.cryptoSystem.derivePathwayKey(pathwayId);
                
                const pathway = {
                    id: pathwayId,
                    name: name,
                    created: Date.now(),
                    peers: new Set([this.localId]),
                    messages: [],
                    encrypted: true,
                    encryptionKey: encryptionKey,
                    isHost: true
                };
                
                this.pathways.set(pathwayId, pathway);
                this.messageQueue.set(pathwayId, []);
                
                // If connected to server, create pathway on server
                if (this.socket && this.isConnected) {
                    this.socket.emit('create-pathway', {
                        pathwayId: pathwayId,
                        name: name,
                        creatorId: this.localId
                    });
                }
                
                this.updatePathwaysUI();
                
                return { pathwayId, inviteCode: this.generateInviteCode(pathwayId, name) };
            }
            
            generatePathwayId() {
                return 'pw_' + Math.random().toString(36).substr(2, 12);
            }
            
            generateInviteCode(pathwayId, name) {
                return btoa(JSON.stringify({ pathwayId, name, nodeId: this.localId, timestamp: Date.now() }));
            }
            
            async joinPathway(inviteCode) {
                try {
                    const invite = JSON.parse(atob(inviteCode));
                    const { pathwayId, name, nodeId, timestamp } = invite;
                    
                    // Check if invite is not too old (24 hours)
                    if (Date.now() - timestamp > 24 * 60 * 60 * 1000) {
                        throw new Error('Invite code has expired');
                    }
                    
                    // Create pathway locally
                    const encryptionKey = await this.cryptoSystem.derivePathwayKey(pathwayId);
                    const pathway = {
                        id: pathwayId,
                        name: name || `Pathway ${pathwayId.substring(3, 8)}`,
                        created: timestamp,
                        peers: new Set([this.localId]),
                        messages: [],
                        encrypted: true,
                        encryptionKey: encryptionKey,
                        isHost: false,
                        hostNodeId: nodeId
                    };
                    
                    this.pathways.set(pathwayId, pathway);
                    this.messageQueue.set(pathwayId, []);
                    
                    // If connected to server, join pathway on server
                    if (this.socket && this.isConnected) {
                        this.socket.emit('join-pathway', {
                            pathwayId: pathwayId,
                            inviteCode: inviteCode
                        });
                    }
                    
                    this.updatePathwaysUI();
                    return true;
                    
                } catch (error) {
                    console.error('Failed to join pathway:', error);
                    return false;
                }
            }
            
            async establishP2PConnection(pathwayId, targetPeerId, isOffering = true) {
                try {
                    console.log(` Establishing P2P connection with ${targetPeerId} (offering: ${isOffering})`);
                    
                    // Create RTC Peer Connection
                    const peerConnection = new RTCPeerConnection(this.rtcConfig);
                    
                    // Store connection reference
                    this.rtcConnections.set(targetPeerId, peerConnection);
                    
                    let dataChannel;
                    
                    if (isOffering) {
                        // Create data channel for messaging (offering peer)
                        dataChannel = peerConnection.createDataChannel('pathway-messages', {
                            ordered: true
                        });
                        this.setupDataChannel(dataChannel, pathwayId, targetPeerId);
                    }
                    
                    // Handle incoming data channels (answering peer)
                    peerConnection.ondatachannel = (event) => {
                        console.log(' Received data channel from peer');
                        dataChannel = event.channel;
                        this.setupDataChannel(dataChannel, pathwayId, targetPeerId);
                    };
                    
                    // Handle ICE candidates
                    peerConnection.onicecandidate = (event) => {
                        if (event.candidate && this.socket) {
                            console.log(' Sending ICE candidate to peer');
                            this.socket.emit('webrtc-ice-candidate', {
                                pathwayId: pathwayId,
                                targetPeer: targetPeerId,
                                candidate: event.candidate
                            });
                        }
                    };
                    
                    // Handle connection state changes
                    peerConnection.onconnectionstatechange = () => {
                        console.log(` Connection state: ${peerConnection.connectionState}`);
                        if (peerConnection.connectionState === 'connected') {
                            console.log(` P2P connection established with ${targetPeerId}`);
                        } else if (peerConnection.connectionState === 'disconnected') {
                            this.onPeerDisconnected(pathwayId, targetPeerId);
                        }
                    };
                    
                    if (isOffering) {
                        // Create and send offer
                        const offer = await peerConnection.createOffer();
                        await peerConnection.setLocalDescription(offer);
                        
                        if (this.socket) {
                            console.log(' Sending WebRTC offer');
                            this.socket.emit('webrtc-offer', {
                                pathwayId: pathwayId,
                                targetPeer: targetPeerId,
                                offer: offer
                            });
                        }
                    }
                    
                    return true;
                    
                } catch (error) {
                    console.error('Failed to establish P2P connection:', error);
                    return false;
                }
            }
            
            setupDataChannel(dataChannel, pathwayId, peerId) {
                this.dataChannels.set(peerId, dataChannel);
                
                dataChannel.onopen = () => {
                    console.log(` Data channel opened with ${peerId}`);
                    this.onPeerConnected(pathwayId, peerId);
                };
                
                dataChannel.onmessage = (event) => {
                    this.handleIncomingMessage(pathwayId, event.data);
                };
                
                dataChannel.onclose = () => {
                    console.log(` Data channel closed with ${peerId}`);
                    this.onPeerDisconnected(pathwayId, peerId);
                };
                
                dataChannel.onerror = (error) => {
                    console.error(` Data channel error with ${peerId}:`, error);
                };
            }
            
            async handleWebRTCOffer(data) {
                try {
                    const { pathwayId, fromPeer, offer } = data;
                    console.log(` Received WebRTC offer from ${fromPeer}`);
                    
                    // Start P2P connection as answering peer
                    await this.establishP2PConnection(pathwayId, fromPeer, false);
                    
                    const peerConnection = this.rtcConnections.get(fromPeer);
                    if (peerConnection) {
                        // Set remote description
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                        
                        // Create and send answer
                        const answer = await peerConnection.createAnswer();
                        await peerConnection.setLocalDescription(answer);
                        
                        if (this.socket) {
                            console.log(' Sending WebRTC answer');
                            this.socket.emit('webrtc-answer', {
                                pathwayId: pathwayId,
                                targetPeer: fromPeer,
                                answer: answer
                            });
                        }
                    }
                } catch (error) {
                    console.error('Failed to handle WebRTC offer:', error);
                }
            }
            
            async handleWebRTCAnswer(data) {
                try {
                    const { pathwayId, fromPeer, answer } = data;
                    console.log(` Received WebRTC answer from ${fromPeer}`);
                    
                    const peerConnection = this.rtcConnections.get(fromPeer);
                    if (peerConnection) {
                        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                        console.log(' WebRTC answer processed');
                    }
                } catch (error) {
                    console.error('Failed to handle WebRTC answer:', error);
                }
            }
            
            async handleICECandidate(data) {
                try {
                    const { pathwayId, fromPeer, candidate } = data;
                    
                    const peerConnection = this.rtcConnections.get(fromPeer);
                    if (peerConnection) {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                        console.log(` ICE candidate added from ${fromPeer}`);
                    }
                } catch (error) {
                    console.error('Failed to handle ICE candidate:', error);
                }
            }
            
            async sendPathwayMessage(pathwayId, message) {
                const pathway = this.pathways.get(pathwayId);
                if (!pathway) return false;
                
                try {
                    // Encrypt the message
                    const encryptedMessage = await this.cryptoSystem.encryptMessage(
                        JSON.stringify({
                            content: message,
                            sender: this.localId,
                            timestamp: Date.now(),
                            id: 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6)
                        }),
                        pathway.encryptionKey
                    );
                    
                    // Store in local message queue (ephemeral)
                    const messages = this.messageQueue.get(pathwayId) || [];
                    messages.push({
                        encrypted: encryptedMessage,
                        timestamp: Date.now(),
                        sender: this.localId
                    });
                    this.messageQueue.set(pathwayId, messages);
                    
                    // Try direct P2P first, then fallback to server
                    let sentViaP2P = false;
                    
                    // Send via WebRTC P2P if available
                    for (const peerId of pathway.peers) {
                        if (peerId !== this.localId && this.dataChannels.has(peerId)) {
                            const channel = this.dataChannels.get(peerId);
                            if (channel.readyState === 'open') {
                                console.log(` Sending message via P2P to ${peerId}`);
                                channel.send(JSON.stringify(encryptedMessage));
                                sentViaP2P = true;
                            }
                        }
                    }
                    
                    // Fallback to server relay if P2P not available
                    if (!sentViaP2P && this.socket && this.isConnected) {
                        console.log(' Sending message via server relay');
                        this.socket.emit('pathway-message', {
                            pathwayId: pathwayId,
                            encryptedMessage: encryptedMessage
                        });
                    }
                    
                    return true;
                    
                } catch (error) {
                    console.error('Failed to send pathway message:', error);
                    return false;
                }
            }
            
            async handleServerMessage(data) {
                try {
                    const { pathwayId, fromPeer, encryptedMessage } = data;
                    const pathway = this.pathways.get(pathwayId);
                    if (!pathway) return;
                    
                    const decryptedContent = await this.cryptoSystem.decryptMessage(
                        encryptedMessage,
                        pathway.encryptionKey
                    );
                    
                    const messageData = JSON.parse(decryptedContent);
                    
                    // Add to local message queue
                    const messages = this.messageQueue.get(pathwayId) || [];
                    messages.push({
                        encrypted: encryptedMessage,
                        decrypted: messageData,
                        timestamp: messageData.timestamp,
                        sender: messageData.sender
                    });
                    this.messageQueue.set(pathwayId, messages);
                    
                    // Update pathway chat window if open
                    if (typeof addPathwayMessage === 'function') {
                        addPathwayMessage(pathwayId, messageData.content, 'peer', messageData.sender, messageData.timestamp);
                    }
                    
                    console.log(` Received pathway message from ${messageData.sender}: ${messageData.content}`);
                    
                } catch (error) {
                    console.error('Failed to handle server message:', error);
                }
            }
            
            async handleIncomingMessage(pathwayId, encryptedData) {
                try {
                    const pathway = this.pathways.get(pathwayId);
                    if (!pathway) return;
                    
                    const encryptedMessage = JSON.parse(encryptedData);
                    const decryptedContent = await this.cryptoSystem.decryptMessage(
                        encryptedMessage,
                        pathway.encryptionKey
                    );
                    
                    const messageData = JSON.parse(decryptedContent);
                    
                    // Add to local message queue
                    const messages = this.messageQueue.get(pathwayId) || [];
                    messages.push({
                        encrypted: encryptedMessage,
                        decrypted: messageData,
                        timestamp: messageData.timestamp,
                        sender: messageData.sender
                    });
                    this.messageQueue.set(pathwayId, messages);
                    
                    // Update pathway chat window if open
                    if (typeof addPathwayMessage === 'function') {
                        addPathwayMessage(pathwayId, messageData.content, 'peer', messageData.sender, messageData.timestamp);
                    }
                    
                    console.log(` Received pathway message from ${messageData.sender}: ${messageData.content}`);
                    
                } catch (error) {
                    console.error('Failed to handle incoming message:', error);
                }
            }
            
            onPeerConnected(pathwayId, peerId) {
                const pathway = this.pathways.get(pathwayId);
                if (pathway) {
                    pathway.peers.add(peerId);
                    this.updatePathwaysUI();
                    console.log(` Peer ${peerId} joined pathway ${pathwayId}`);
                }
            }
            
            onPeerDisconnected(pathwayId, peerId) {
                const pathway = this.pathways.get(pathwayId);
                if (pathway) {
                    pathway.peers.delete(peerId);
                    this.updatePathwaysUI();
                    console.log(` Peer ${peerId} left pathway ${pathwayId}`);
                }
                
                // Clean up connections
                this.rtcConnections.delete(peerId);
                this.dataChannels.delete(peerId);
            }
            
            updatePathwaysUI() {
                // Update right panel (if exists)
                const pathwaysList = document.getElementById('pathwaysList');
                if (pathwaysList) {
                    pathwaysList.innerHTML = '';
                    
                    for (const [id, pathway] of this.pathways) {
                        const pathwayElement = document.createElement('div');
                        pathwayElement.className = 'pathway-item';
                        pathwayElement.onclick = () => selectPathway(id);
                        pathwayElement.innerHTML = `
                            <div class="pathway-name">${pathway.name}</div>
                            <div class="pathway-status"> ${pathway.peers.size} peer${pathway.peers.size !== 1 ? 's' : ''}</div>
                        `;
                        pathwaysList.appendChild(pathwayElement);
                    }
                }
                
                // Update sidebar pathways list
                const sidebarPathwaysList = document.getElementById('sidebarPathwaysList');
                if (sidebarPathwaysList) {
                    sidebarPathwaysList.innerHTML = '';
                    
                    for (const [id, pathway] of this.pathways) {
                        const swipeContainer = document.createElement('div');
                        swipeContainer.className = 'pathway-swipe-container';
                        
                        const pathwayElement = document.createElement('div');
                        pathwayElement.className = 'pathway-item-sidebar';
                        pathwayElement.setAttribute('data-pathway-id', id);
                        pathwayElement.onclick = () => { selectPathway(id); closeSidebar(); };
                        pathwayElement.innerHTML = `
                            <div class="pathway-info">
                                <div class="pathway-name-sidebar">${pathway.name}</div>
                                <div class="pathway-status-sidebar"> ${pathway.peers.size} peer${pathway.peers.size !== 1 ? 's' : ''}</div>
                            </div>
                            <div class="pathway-indicator"></div>
                        `;
                        
                        const actionsElement = document.createElement('div');
                        actionsElement.className = 'pathway-actions-revealed';
                        actionsElement.innerHTML = ``;
                        
                        swipeContainer.appendChild(pathwayElement);
                        swipeContainer.appendChild(actionsElement);
                        sidebarPathwaysList.appendChild(swipeContainer);
                    }
                }
                
                // Update pathway count (if exists)
                const pathwayCount = document.getElementById('pathwayCount');
                if (pathwayCount) {
                    pathwayCount.textContent = this.pathways.size;
                }
            }
        }

        // ============================================================================
        // QR CODE GENERATION SYSTEM
        // ============================================================================
        
        class QRCodeGenerator {
            constructor() {
                this.isLibraryLoaded = false;
                this.checkLibraryLoaded();
            }
            
            checkLibraryLoaded() {
                // Check if QRCode library is available
                if (typeof QRCode !== 'undefined') {
                    this.isLibraryLoaded = true;
                    console.log(' QRCode library loaded successfully');
                } else {
                    console.log(' Waiting for QRCode library...');
                    setTimeout(() => this.checkLibraryLoaded(), 100);
                }
            }
            
            async generateQR(data, size = 300) {
                try {
                    // Wait for library to load
                    while (!this.isLibraryLoaded) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    
                    console.log(` Generating QR code for: ${data.substring(0, 50)}...`);
                    
                    // Create canvas element
                    const canvas = document.createElement('canvas');
                    
                    // Generate QR code
                    await QRCode.toCanvas(canvas, data, {
                        width: size,
                        margin: 2,
                        color: {
                            dark: '#000000',
                            light: '#ffffff'
                        },
                        errorCorrectionLevel: 'M'
                    });
                    
                    // Convert canvas to data URL
                    const dataUrl = canvas.toDataURL('image/png');
                    
                    console.log(' QR code generated successfully (client-side)');
                    
                    return {
                        dataUrl: dataUrl,
                        canvas: canvas,
                        success: true,
                        service: 'Client-side QRCode.js'
                    };
                    
                } catch (error) {
                    console.error(' QR generation failed:', error);
                    
                    // Fallback: try to use a simple web service as last resort
                    const fallbackUrl = `https://api.qrserver.com/v1/create-qr-code/?size=${size}x${size}&data=${encodeURIComponent(data)}`;
                    
                    return {
                        dataUrl: fallbackUrl,
                        canvas: null,
                        success: false,
                        service: 'Fallback Web Service',
                        error: error.message
                    };
                }
            }
            
            // Legacy method for compatibility
            async generateQRWithFallback(data, size = 300) {
                const result = await this.generateQR(data, size);
                return {
                    url: result.dataUrl,
                    service: result.service,
                    success: result.success,
                    error: result.error
                };
            }
        }
        
        // ============================================================================
        // APP DOWNLOAD SYSTEM  
        // ============================================================================
        
        class AppDownloader {
            constructor() {
                this.appName = 'Synapse';
            }
            
            async generateDownloadPackage() {
                try {
                    // Get the current HTML content
                    const htmlContent = document.documentElement.outerHTML;
                    
                    // Create a cleaned version without any user data
                    const cleanHTML = this.cleanHTMLForDistribution(htmlContent);
                    
                    // Create blob and download
                    const blob = new Blob([cleanHTML], { type: 'text/html' });
                    const url = window.URL.createObjectURL(blob);
                    
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'synapse-chat.html';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                    
                    return true;
                } catch (error) {
                    console.error('Failed to generate download package:', error);
                    return false;
                }
            }
            
            cleanHTMLForDistribution(html) {
                // Remove any user-specific content and reset to default state
                let cleanedHTML = html;
                
                // Reset chat messages to empty state
                cleanedHTML = cleanedHTML.replace(
                    /<div class="chat-messages"[^>]*>.*?<\/div>/s,
                    '<div class="chat-messages" id="chatMessages"><div class="synapse-watermark" id="synapseWatermark">SYNAPSE</div></div>'
                );
                
                // Add download info comment
                const downloadComment = `\n<!-- Downloaded from Synapse P2P Chat Network -->\n<!-- Generated: ${new Date().toISOString()} -->\n<!-- To use: Open this file in any modern web browser -->\n`;
                cleanedHTML = cleanedHTML.replace('<html', downloadComment + '<html');
                
                return cleanedHTML;
            }
        }
        
        // ============================================================================
        // CORE SYSTEM INITIALIZATION
        // ============================================================================
        
        let fractalMemory, offlineAI, pathwayNetwork, qrGenerator, appDownloader;
        
        function initializeSynapse() {
            fractalMemory = new FractalMemory();
            offlineAI = new OfflineAI(fractalMemory);
            pathwayNetwork = new PathwayNetwork();
            // QR disabled
            qrGenerator = null;
            appDownloader = new AppDownloader();
            
            SynapseCore.init();
            
            // Initialize sidebar state and ensure overlay is properly hidden
            initializeSidebarState();
            
            // Initialize iOS-specific fixes first
            initializeiOSTouchFixes();
            
            // Initialize dynamic screen adjustment
            initDynamicAdjustment();
            
            // Initialize touch support
            initTouchSupport();
            
            // Initialize swipe gestures
            initSwipeGestures();
            
            // Create initial demo pathway
            pathwayNetwork.createPathway('Demo Pathway');
            
            // Show welcome popup after a brief delay
            setTimeout(showWelcomePopup, 500);
        }
        
        function initializeSidebarState() {
            console.log(' Initializing sidebar state...');
            
            // Ensure sidebar is properly closed and overlay is hidden on load
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebarOverlay');
            const hamburger = document.getElementById('hamburger');
            
            if (sidebar) {
                sidebar.classList.remove('open');
            }
            
            if (overlay) {
                overlay.classList.remove('active');
                overlay.style.display = 'none';
                overlay.style.pointerEvents = 'none';
            }
            
            if (hamburger) {
                hamburger.classList.remove('open');
            }
            
            // Add click handler to ensure overlay closes sidebar
            if (overlay) {
                overlay.addEventListener('click', closeSidebar);
            }
            
            console.log(' Sidebar state initialized');
        }
        
        function initializeiOSTouchFixes() {
            console.log(' Initializing iOS touch fixes...');
            
            // Fix iOS viewport height issues
            function setViewportHeight() {
                const vh = window.innerHeight * 0.01;
                document.documentElement.style.setProperty('--vh', `${vh}px`);
            }
            
            setViewportHeight();
            window.addEventListener('resize', setViewportHeight);
            window.addEventListener('orientationchange', () => {
                setTimeout(setViewportHeight, 100);
            });
            
            // Prevent iOS bounce scrolling on main body
            document.addEventListener('touchmove', function(e) {
                // Allow scrolling on specific scrollable elements
                if (e.target.closest('input') || e.target.closest('textarea') || 
                    e.target.closest('.chat-messages') || e.target.closest('.pathway-chat-messages') ||
                    e.target.closest('.sidebar-content') || e.target.closest('.panel-content')) {
                    return; // Allow scrolling on these elements
                }
                e.preventDefault();
            }, { passive: false });
            
            // Fix double-tap zoom on iOS
            let lastTouchEnd = 0;
            document.addEventListener('touchend', function (event) {
                const now = (new Date()).getTime();
                if (now - lastTouchEnd <= 300) {
                    event.preventDefault();
                }
                lastTouchEnd = now;
            }, false);
            
            // Fix iOS Safari keyboard issues
            const allInputs = document.querySelectorAll('input, textarea');
            allInputs.forEach(input => {
                input.addEventListener('blur', function() {
                    // Scroll back to top after keyboard closes
                    setTimeout(() => {
                        window.scrollTo(0, 0);
                        document.body.scrollTop = 0;
                    }, 100);
                });
                
                // Prevent zoom on input focus
                input.addEventListener('touchstart', function(e) {
                    if (input.style.fontSize !== '16px') {
                        input.style.fontSize = '16px';
                    }
                });
            });
            
            // Enhanced touch feedback for iOS
            document.addEventListener('touchstart', function(e) {
                const target = e.target;
                const clickableElement = target.closest('button, .button, [onclick], .menu-item, .pathway-item-sidebar, .send-button, .pathway-send-btn');
                
                if (clickableElement) {
                    clickableElement.style.transform = 'scale(0.95)';
                    clickableElement.style.transition = 'transform 0.1s ease';
                }
            }, { passive: true });
            
            document.addEventListener('touchend', function(e) {
                const target = e.target;
                const clickableElement = target.closest('button, .button, [onclick], .menu-item, .pathway-item-sidebar, .send-button, .pathway-send-btn');
                
                if (clickableElement) {
                    setTimeout(() => {
                        clickableElement.style.transform = 'scale(1)';
                    }, 150);
                }
            }, { passive: true });
            
            console.log(' iOS touch fixes initialized');
        }
        
        function initDynamicAdjustment() {
            console.log(' Initializing dynamic screen adjustment...');
            
            // Adjust on initial load
            adjustToScreen();
            
            // Adjust on resize
            window.addEventListener('resize', debounce(adjustToScreen, 250));
            
            // Adjust on orientation change
            window.addEventListener('orientationchange', () => {
                setTimeout(adjustToScreen, 100);
            });
            
            // Adjust when entering/exiting fullscreen
            document.addEventListener('fullscreenchange', adjustToScreen);
        }
        
        function adjustToScreen() {
            const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
            const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
            const dpr = window.devicePixelRatio || 1;
            
            console.log(` Screen: ${vw}x${vh}, DPR: ${dpr}`);
            
            // Dynamic font scaling based on screen size and DPI
            const baseFontSize = Math.min(Math.max(vw / 80, 12), 18);
            document.documentElement.style.fontSize = baseFontSize + 'px';
            
            // Adjust chat window size based on screen
            const chatWindows = document.querySelectorAll('.pathway-chat-window');
            chatWindows.forEach(window => {
                if (vw < 768) {
                    // Mobile: full width minus small margin
                    window.style.width = '95vw';
                    window.style.left = '2.5vw';
                    window.style.height = '80vh';
                    window.style.top = '10vh';
                } else if (vw < 1024) {
                    // Tablet: 90% width
                    window.style.width = '90vw';
                    window.style.left = '5vw';
                    window.style.height = '75vh';
                    window.style.top = '12.5vh';
                } else {
                    // Desktop: fixed max width
                    window.style.width = '80%';
                    window.style.left = '50%';
                    window.style.transform = 'translateX(-50%)';
                    window.style.height = '70%';
                    window.style.top = '10%';
                    window.style.maxWidth = '800px';
                }
            });
            
            // Adjust welcome popup size
            const welcomePopup = document.querySelector('[style*="z-index: 10000"]');
            if (welcomePopup) {
                const terminal = welcomePopup.querySelector('[style*="max-width: 650px"]');
                if (terminal && vw < 768) {
                    terminal.style.maxWidth = '95vw';
                    terminal.style.width = '95vw';
                }
            }
            
            // Log current responsive state
            let screenType = 'desktop';
            if (vw <= 480) screenType = 'phone-portrait';
            else if (vw <= 768) screenType = 'phone-landscape';
            else if (vw <= 1024) screenType = 'tablet';
            
            console.log(` Adjusted for: ${screenType} (${vw}x${vh})`);
        }
        
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        function initTouchSupport() {
            console.log(' Initializing touch support...');
            
            // Immediate touch support (don't wait for DOMContentLoaded)
            setupTouchEvents();
            
            // Also setup after DOM loads for dynamically created elements
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', setupTouchEvents);
            }
            
            function setupTouchEvents() {
                console.log(' Setting up touch events...');
                
                // Universal touch event delegation
                document.addEventListener('touchstart', handleTouchStart, { passive: false });
                document.addEventListener('touchend', handleTouchEnd, { passive: false });
                
                // Fix for iOS Safari input focus
                document.addEventListener('touchstart', function(e) {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                        e.target.focus();
                    }
                }, { passive: true });
                
                // Add touch support to existing elements
                enhanceExistingElements();
            }
            
            function handleTouchStart(e) {
                const clickableElement = findClickableParent(e.target);
                if (clickableElement) {
                    clickableElement.style.opacity = '0.7';
                    clickableElement.style.transform = 'scale(0.95)';
                    console.log(' Touch start on:', clickableElement.tagName, clickableElement.className);
                }
            }
            
            function handleTouchEnd(e) {
                const clickableElement = findClickableParent(e.target);
                if (clickableElement) {
                    clickableElement.style.opacity = '1';
                    clickableElement.style.transform = 'scale(1)';
                    
                    // Trigger click event if it has onclick or is a button
                    if (clickableElement.onclick || clickableElement.tagName === 'BUTTON') {
                        console.log(' Triggering click on:', clickableElement.tagName, clickableElement.className);
                        clickableElement.click();
                    }
                }
            }
            
            function findClickableParent(element) {
                const clickableSelectors = [
                    'button',
                    '[onclick]',
                    '[role="button"]',
                    '.menu-item',
                    '.pathway-item-sidebar',
                    '.pathway-dropdown > div',
                    '.pathway-send-btn',
                    '.send-button',
                    '.pathway-close-btn'
                ];
                
                let current = element;
                while (current && current !== document.body) {
                    for (let selector of clickableSelectors) {
                        if (current.matches && current.matches(selector)) {
                            return current;
                        }
                    }
                    current = current.parentElement;
                }
                return null;
            }
            
            function enhanceExistingElements() {
                // Add explicit touch handling to send buttons
                document.querySelectorAll('.pathway-send-btn, .send-button').forEach(btn => {
                    if (!btn.dataset.touchEnhanced) {
                        btn.dataset.touchEnhanced = 'true';
                        btn.style.cursor = 'pointer';
                        btn.style.touchAction = 'manipulation';
                        console.log(' Enhanced send button for touch');
                    }
                });
                
                // Add touch handling to all buttons
                document.querySelectorAll('button, [onclick]').forEach(element => {
                    if (!element.dataset.touchEnhanced) {
                        element.dataset.touchEnhanced = 'true';
                        element.style.touchAction = 'manipulation';
                        element.style.cursor = 'pointer';
                    }
                });
            }
        }

        // ============================================================================
        // PATHWAY WINDOW FUNCTIONS
        // ============================================================================
        
        function togglePathwayDropdown(pathwayId) {
            const dropdown = document.getElementById(`pathway-dropdown-${pathwayId}`);
            if (dropdown) {
                const isVisible = dropdown.style.display === 'block';
                
                // Hide all other dropdowns first
                document.querySelectorAll('.pathway-dropdown').forEach(d => {
                    d.style.display = 'none';
                });
                
                dropdown.style.display = isVisible ? 'none' : 'block';
                
                // Close when clicking outside
                if (!isVisible) {
                    setTimeout(() => {
                        document.addEventListener('click', function closeDropdown(e) {
                            if (!dropdown.contains(e.target) && !e.target.matches(`[onclick*="togglePathwayDropdown('${pathwayId}')"]`)) {
                                dropdown.style.display = 'none';
                                document.removeEventListener('click', closeDropdown);
                            }
                        });
                    }, 10);
                }
            }
        }
        
        function hidePathwayDropdown(pathwayId) {
            const dropdown = document.getElementById(`pathway-dropdown-${pathwayId}`);
            if (dropdown) {
                dropdown.style.display = 'none';
            }
        }
        
        function showPathwayInviteQR(pathwayId) {
            showPathwayQR(pathwayId);
        }
        
        function closePathwayWindow(pathwayId) {
            const window = openPathwayWindows.get(pathwayId);
            if (window) {
                window.remove();
                openPathwayWindows.delete(pathwayId);
            }
        }
        
        function changeUsername() {
            const currentName = SynapseCore.config.nickname;
            const newName = prompt(` Change Username\n\nCurrent: ${currentName}\n\nEnter new username:`, currentName);
            
            if (newName && newName.trim() !== '' && newName !== currentName) {
                const cleanName = newName.trim().substring(0, 20); // Limit length
                SynapseCore.config.nickname = cleanName;
                
                // Save to localStorage
                try {
                    localStorage.setItem('synapse_config', JSON.stringify(SynapseCore.config));
                } catch (error) {
                    console.warn('Could not save username to storage:', error);
                }
                
                // Update pathway network local ID
                if (pathwayNetwork) {
                    pathwayNetwork.localId = cleanName;
                }
                
                alert(` Username changed to: ${cleanName}\n\nThis will be visible to others in future messages.`);
            }
        }
        
        function updatePathwayReadyMessage(pathwayId) {
            const pathway = pathwayNetwork.pathways.get(pathwayId);
            const readyDetails = document.getElementById(`pathway-ready-details-${pathwayId}`);
            
            if (pathway && readyDetails) {
                const expiration = pathway.messageExpiration || 86400000; // 24h default
                let expirationText;
                
                if (expiration === 0) {
                    expirationText = 'read once';
                } else if (expiration === -1) {
                    expirationText = 'never';
                } else {
                    // Convert milliseconds to readable format
                    const minutes = Math.round(expiration / (60 * 1000));
                    
                    if (minutes < 60) {
                        expirationText = `${minutes} min${minutes !== 1 ? 's' : ''}`;
                    } else if (minutes < 1440) {
                        const hours = Math.floor(minutes / 60);
                        const remainingMins = minutes % 60;
                        if (remainingMins === 0) {
                            expirationText = `${hours} hour${hours !== 1 ? 's' : ''}`;
                        } else {
                            expirationText = `${hours}h ${remainingMins}m`;
                        }
                    } else {
                        const days = Math.floor(minutes / 1440);
                        const remainingHours = Math.floor((minutes % 1440) / 60);
                        if (remainingHours === 0) {
                            expirationText = `${days} day${days !== 1 ? 's' : ''}`;
                        } else {
                            expirationText = `${days}d ${remainingHours}h`;
                        }
                    }
                }
                
                readyDetails.textContent = `Encrypted  Messages expire: ${expirationText}  ${pathway.peers.size} peer${pathway.peers.size !== 1 ? 's' : ''} connected`;
            }
        }
        
        function removePathwayReadyMessage(pathwayId) {
            const readyMessage = document.getElementById(`pathway-ready-${pathwayId}`);
            if (readyMessage) {
                // Fade out animation
                readyMessage.style.transition = 'all 0.5s ease-out';
                readyMessage.style.opacity = '0';
                readyMessage.style.transform = 'translateY(-10px)';
                
                setTimeout(() => {
                    readyMessage.remove();
                }, 500);
            }
        }
        
        
        function showPathwayQRFromDropdown(pathwayId) {
            togglePathwayDropdown(pathwayId); // Close dropdown
            showPathwayQR(pathwayId);
        }
        
        function showPathwaySettings(pathwayId) {
            togglePathwayDropdown(pathwayId); // Close dropdown
            
            const pathway = pathwayNetwork.pathways.get(pathwayId);
            if (!pathway) return;
            
            alert(` Pathway Settings\n\nName: ${pathway.name}\nID: ${pathwayId}\nPeers: ${pathway.peers.size}\nCreated: ${new Date(pathway.created).toLocaleString()}\nEncrypted:  Yes\n\nMessage Expiration: 24 hours`);
        }
        
        // Enhanced join with code function
        function promptJoinPathway() {
            const input = prompt(" Join Pathway\n\nEnter invite code or join link:");
            
            if (!input || input.trim() === '') {
                return;
            }
            
            let inviteCode = input.trim();
            
            // Check if it's a full join link
            if (inviteCode.includes('/join/')) {
                try {
                    const url = new URL(inviteCode);
                    // Check both 'invite' and 'i' parameters
                    const urlInviteCode = url.searchParams.get('invite') || url.searchParams.get('i');
                    if (urlInviteCode) {
                        inviteCode = urlInviteCode;
                    }
                } catch (e) {
                    // If URL parsing fails, try to extract manually
                    const inviteMatch = inviteCode.match(/[?&]invite=([^&]+)/);
                    const iMatch = inviteCode.match(/[?&]i=([^&]+)/);
                    const match = inviteMatch || iMatch;
                    if (match) {
                        inviteCode = decodeURIComponent(match[1]);
                    }
                }
            }
            
            // Try to join
            pathwayNetwork.joinPathway(inviteCode).then(success => {
                if (success) {
                    alert(" Successfully joined pathway!");
                    closeSidebar();
                } else {
                    alert(" Failed to join pathway. Please check your invite code.");
                }
            });
        }
        
        // ============================================================================
        // SIDEBAR FUNCTIONALITY
        // ============================================================================
        
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebarOverlay');
            const hamburger = document.getElementById('hamburger');
            
            if (sidebar && sidebar.classList.contains('open')) {
                closeSidebar();
            } else {
                // Open sidebar with immediate response
                if (sidebar) sidebar.classList.add('open');
                if (overlay) {
                    overlay.style.display = 'block';
                    overlay.style.pointerEvents = 'auto';
                    // Force reflow for immediate transition start
                    overlay.offsetHeight;
                    overlay.classList.add('active');
                }
                if (hamburger) hamburger.classList.add('open');
            }
        }
        
        function closeSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.getElementById('sidebarOverlay');
            const hamburger = document.getElementById('hamburger');
            
            // Remove classes immediately for instant response
            if (sidebar) sidebar.classList.remove('open');
            if (overlay) overlay.classList.remove('active');
            if (hamburger) hamburger.classList.remove('open');
            
            // Clean up overlay after transition completes
            if (overlay) {
                overlay.addEventListener('transitionend', function hideOverlay() {
                    if (!overlay.classList.contains('active')) {
                        overlay.style.display = 'none';
                        overlay.style.pointerEvents = 'none';
                    }
                    overlay.removeEventListener('transitionend', hideOverlay);
                }, { once: true });
                
                // Fallback cleanup in case transitionend doesn't fire
                setTimeout(() => {
                    if (!overlay.classList.contains('active')) {
                        overlay.style.display = 'none';
                        overlay.style.pointerEvents = 'none';
                    }
                }, 250);
            }
        }
        
        // Close sidebar on escape key
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                closeSidebar();
            }
        });
        
        // Collapsible menu sections
        function toggleSection(sectionId) {
            const content = document.getElementById(`content-${sectionId}`);
            const arrow = document.getElementById(`arrow-${sectionId}`);
            
            if (content && arrow) {
                const isCollapsed = content.classList.contains('collapsed');
                
                if (isCollapsed) {
                    content.classList.remove('collapsed');
                    arrow.classList.remove('collapsed');
                } else {
                    content.classList.add('collapsed');
                    arrow.classList.add('collapsed');
                }
            }
        }
        
        // Apple-style swipe-to-delete functionality
        let swipeStartX = 0;
        let swipeStartY = 0;
        let currentSwipeElement = null;
        let isSwipeActive = false;
        
        function initSwipeGestures() {
            document.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd, { passive: false });
            document.addEventListener('mousedown', handleMouseStart);
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseEnd);
        }
        
        function handleTouchStart(e) {
            handleSwipeStart(e.touches[0].clientX, e.touches[0].clientY, e.target);
        }
        
        function handleMouseStart(e) {
            handleSwipeStart(e.clientX, e.clientY, e.target);
        }
        
        function handleSwipeStart(x, y, target) {
            const pathwayItem = target.closest('.pathway-item-sidebar');
            if (!pathwayItem) return;
            
            swipeStartX = x;
            swipeStartY = y;
            currentSwipeElement = pathwayItem;
            isSwipeActive = false;
            
            // Reset any other swiped items
            document.querySelectorAll('.pathway-item-sidebar').forEach(item => {
                if (item !== pathwayItem) {
                    item.style.transform = 'translateX(0)';
                    item.classList.remove('swiping');
                }
            });
        }
        
        function handleTouchMove(e) {
            if (currentSwipeElement) {
                e.preventDefault();
                handleSwipeMove(e.touches[0].clientX, e.touches[0].clientY);
            }
        }
        
        function handleMouseMove(e) {
            if (currentSwipeElement && e.buttons === 1) {
                handleSwipeMove(e.clientX, e.clientY);
            }
        }
        
        function handleSwipeMove(x, y) {
            if (!currentSwipeElement) return;
            
            const deltaX = x - swipeStartX;
            const deltaY = y - swipeStartY;
            
            // Only activate swipe if horizontal movement is greater than vertical
            if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
                isSwipeActive = true;
                currentSwipeElement.classList.add('swiping');
                
                // Only allow left swipe (negative deltaX)
                const translateX = Math.min(0, Math.max(-100, deltaX));
                currentSwipeElement.style.transform = `translateX(${translateX}px)`;
            }
        }
        
        function handleTouchEnd(e) {
            handleSwipeEnd();
        }
        
        function handleMouseEnd(e) {
            handleSwipeEnd();
        }
        
        function handleSwipeEnd() {
            if (!currentSwipeElement) return;
            
            const currentTransform = currentSwipeElement.style.transform;
            const translateX = currentTransform ? parseInt(currentTransform.match(/-?\d+/)?.[0] || '0') : 0;
            
            currentSwipeElement.classList.remove('swiping');
            
            // If swiped more than 80px left, delete; otherwise snap back
            if (translateX < -80) {
                const pathwayId = currentSwipeElement.getAttribute('data-pathway-id');
                if (pathwayId) {
                    deletePathway(pathwayId);
                }
            } else {
                currentSwipeElement.style.transform = 'translateX(0)';
            }
            
            // Reset swipe state after a delay
            setTimeout(() => {
                currentSwipeElement = null;
                isSwipeActive = false;
            }, 100);
        }
        
        // Prevent default click behavior when swiping
        document.addEventListener('click', function(e) {
            const pathwayItem = e.target.closest('.pathway-item-sidebar');
            if (pathwayItem && isSwipeActive) {
                e.preventDefault();
                e.stopPropagation();
            }
        }, true);
        
        
        // ============================================================================
        // UI EVENT HANDLERS
        // ============================================================================
        
        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }
        
        async function sendMessage() {
            const input = document.getElementById('chatInput');
            const messages = document.getElementById('chatMessages');
            
            if (input.value.trim() === '') return;
            
            // Add user message
            addMessage(input.value, 'user');
            
            const userInput = input.value;
            input.value = '';
            
            try {
                // Generate AI response
                const response = await offlineAI.generateResponse(userInput);
                
                // Add thoughtful delay (1-2 seconds)
                const delay = Math.random() * 1000 + 1000; // 1-2 seconds
                await new Promise(resolve => setTimeout(resolve, delay));
                
                // Add AI response
                addMessage(response, 'ai');
                
            } catch (error) {
                addMessage('Sorry, I encountered an error processing your request.', 'ai');
                console.error('AI response error:', error);
            }
        }
        
        function addMessage(content, sender, isTemporary = false) {
            const messages = document.getElementById('chatMessages');
            const messageId = 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 6);
            
            const messageElement = document.createElement('div');
            messageElement.className = `message ${sender}`;
            messageElement.id = messageId;
            
            const senderName = sender === 'user' ? 'You' : 'Synapse';
            
            messageElement.innerHTML = `
                <div class="message-header">
                    <span>${senderName}</span>
                </div>
                <div class="message-content">${content}</div>
            `;
            
            messages.appendChild(messageElement);
            messages.scrollTop = messages.scrollHeight;
            
            return messageId;
        }
        
        function clearChat() {
            const chatMessages = document.getElementById('chatMessages');
            
            chatMessages.innerHTML = `
                <div class="synapse-watermark" id="synapseWatermark">SYNAPSE</div>
            `;
        }
        
        // ULTIMATE CYBERPUNK NEURAL INTERFACE - DIALED TO 1000!
        function showWelcomePopup() {
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: radial-gradient(circle at center, rgba(0,20,30,0) 0%, rgba(0,5,10,0.9) 100%);
                z-index: 10000; display: flex; align-items: center; justify-content: center;
                color: #40E0D0; font-family: 'Courier Prime', monospace;
                overflow: hidden; opacity: 0; transition: all 1.2s ease-in;
                backdrop-filter: blur(0px);
            `;
            
            // Add ultimate cyberpunk fonts
            if (!document.getElementById('cyberpunkFonts')) {
                const fontLink = document.createElement('link');
                fontLink.id = 'cyberpunkFonts';
                fontLink.href = 'https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Courier+Prime:wght@400;700&family=Rajdhani:wght@300;400;700&display=swap';
                fontLink.rel = 'stylesheet';
                document.head.appendChild(fontLink);
            }
            
            modal.innerHTML = `
                <!-- HEXAGON GRID OVERLAY -->
                <div id="hexGrid" style="
                    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
                    background-image: 
                        radial-gradient(circle at 25% 25%, rgba(64,224,208,0.03) 2px, transparent 2px),
                        radial-gradient(circle at 75% 75%, rgba(0,255,136,0.03) 2px, transparent 2px);
                    background-size: 50px 50px;
                    z-index: 1; opacity: 0.4;
                "></div>
                
                <!-- SCANNING LINES -->
                <div id="scanLines" style="
                    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
                    background: repeating-linear-gradient(
                        0deg,
                        transparent 0px,
                        transparent 2px,
                        rgba(64,224,208,0.03) 2px,
                        rgba(64,224,208,0.03) 4px
                    );
                    z-index: 1; animation: scanShift 20s linear infinite;
                "></div>
                
                <!-- NEURAL INTERFACE TERMINAL -->
                <div style="
                    background: linear-gradient(145deg, rgba(0,15,20,0.98) 0%, rgba(0,25,35,0.98) 100%);
                    border: 3px solid rgba(64,224,208,0.8);
                    border-radius: 15px;
                    max-width: 650px; width: 90%;
                    max-height: 85vh;
                    overflow-y: auto;
                    position: relative; z-index: 2;
                    box-shadow: 
                        0 0 60px rgba(64,224,208,0.6),
                        0 0 120px rgba(64,224,208,0.3),
                        inset 0 0 80px rgba(64,224,208,0.08);
                    animation: neuralBoot 2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
                    overflow: hidden;
                ">
                    <!-- GLITCH OVERLAY -->
                    <div style="
                        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
                        background: linear-gradient(90deg, transparent 0%, rgba(64,224,208,0.1) 50%, transparent 100%);
                        animation: dataStream 3s ease-in-out infinite;
                        z-index: 1;
                    "></div>
                    
                    <!-- TERMINAL HEADER -->
                    <div style="
                        background: linear-gradient(135deg, #40E0D0 0%, #00ff88 100%);
                        color: #000; padding: 12px 20px;
                        font-family: 'Orbitron', monospace; font-weight: 900;
                        font-size: 12px; letter-spacing: 2px;
                        text-shadow: 0 0 5px rgba(0,0,0,0.5);
                        position: relative; z-index: 2;
                        border-bottom: 2px solid rgba(64,224,208,0.5);
                    ">
                        <span style="animation: textGlow 2s ease-in-out infinite alternate;">
                             SYNAPSE NEURAL MESH INTERFACE v3.14.159 
                        </span>
                    </div>
                    
                    <!-- MAIN INTERFACE -->
                    <div style="padding: 30px; position: relative; z-index: 2;">
                        <!-- MASSIVE LOGO -->
                        <div style="
                            text-align: center; margin: 20px 0;
                            font-family: 'Orbitron', monospace; font-size: clamp(28px, 8vw, 42px); font-weight: 900;
                            background: linear-gradient(45deg, #40E0D0, #00ff88, #48CAE4, #40E0D0);
                            background-size: 400% 400%;
                            -webkit-background-clip: text;
                            -webkit-text-fill-color: transparent;
                            animation: gradientShift 3s ease-in-out infinite,
                                       logoGlow 2s ease-in-out infinite alternate,
                                       logoScale 4s ease-in-out infinite;
                            letter-spacing: 8px;
                            filter: drop-shadow(0 0 20px rgba(64,224,208,0.8));
                        ">
                            SYNAPSE
                        </div>
                        
                        <!-- SUBTITLE -->
                        <div style="
                            text-align: center; font-size: clamp(11px, 3vw, 14px); 
                            color: rgba(64,224,208,0.8);
                            margin-bottom: 20px; font-family: 'Rajdhani', monospace;
                            letter-spacing: clamp(1px, 0.5vw, 3px); font-weight: 700;
                            text-shadow: 0 0 10px rgba(64,224,208,0.5);
                            animation: subtitleGlow 3s ease-in-out infinite alternate;
                        ">
                             QUANTUM ENCRYPTED P2P NEURAL NETWORK 
                        </div>
                        
                        <!-- SYSTEM STATUS GRID -->
                        <div style="
                            display: grid; grid-template-columns: 1fr;
                            gap: 10px; margin: 20px 0;
                            
                            /* Desktop: 2 columns */
                            @media (min-width: 500px) {
                                grid-template-columns: 1fr 1fr;
                                gap: 15px;
                            }
                        ">
                            <div id="neuralCoreBox" style="
                                background: linear-gradient(135deg, rgba(64,224,208,0.1) 0%, rgba(64,224,208,0.03) 100%);
                                border: 2px solid rgba(64,224,208,0.4);
                                border-radius: 10px; padding: 15px;
                                position: relative; overflow: hidden;
                            ">
                                <div style="
                                    position: absolute; top: -50%; right: -50%;
                                    width: 100%; height: 100%;
                                    background: linear-gradient(45deg, transparent, rgba(64,224,208,0.1), transparent);
                                    animation: shimmer 2s linear infinite;
                                "></div>
                                <!-- Neural Core Matrix -->
                                <div class="neural-matrix" style="
                                    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
                                    z-index: 0; opacity: 0.15; font-size: 8px; overflow: hidden;
                                    pointer-events: none;
                                "></div>
                                <div style="color: #40E0D0; font-weight: bold; margin-bottom: 8px; font-size: 11px; position: relative; z-index: 2;"> NEURAL CORE</div>
                                <div id="neuralBootSequence" style="font-size: 10px; color: rgba(64,224,208,0.8); line-height: 1.4; position: relative; z-index: 2; font-family: 'Courier Prime', monospace; min-height: 50px; font-weight: 500;"></div>
                            </div>
                            
                            <div id="meshNetworkBox" style="
                                background: linear-gradient(135deg, rgba(0,255,136,0.1) 0%, rgba(0,255,136,0.03) 100%);
                                border: 2px solid rgba(0,255,136,0.4);
                                border-radius: 10px; padding: 15px;
                                position: relative; overflow: hidden;
                            ">
                                <div style="
                                    position: absolute; top: -50%; right: -50%;
                                    width: 100%; height: 100%;
                                    background: linear-gradient(45deg, transparent, rgba(0,255,136,0.1), transparent);
                                    animation: shimmer 2.5s linear infinite;
                                "></div>
                                <!-- Mesh Network Matrix -->
                                <div class="mesh-matrix" style="
                                    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
                                    z-index: 0; opacity: 0.12; font-size: 8px; overflow: hidden;
                                    pointer-events: none;
                                "></div>
                                <div style="color: #00ff88; font-weight: bold; margin-bottom: 8px; font-size: 11px; position: relative; z-index: 2;"> MESH NETWORK</div>
                                <div id="meshBootSequence" style="font-size: 10px; color: rgba(0,255,136,0.8); line-height: 1.4; position: relative; z-index: 2; font-family: 'Courier Prime', monospace; min-height: 50px; font-weight: 500;"></div>
                            </div>
                        </div>
                        
                        <!-- SECURITY WARNING -->
                        <div style="
                            border: 2px solid rgba(255,20,147,0.6);
                            background: linear-gradient(135deg, rgba(255,20,147,0.1) 0%, rgba(255,0,128,0.05) 100%);
                            padding: 12px; margin: 20px 0;
                            border-radius: 8px;
                            font-size: 10px; color: #ff1493;
                            text-align: center;
                            animation: warningPulse 2s ease-in-out infinite;
                            position: relative; overflow: hidden;
                        ">
                            <div style="
                                position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
                                background: linear-gradient(90deg, transparent, rgba(255,20,147,0.2), transparent);
                                animation: warningSwipe 3s linear infinite;
                            "></div>
                             QUANTUM ENCRYPTED  ZERO DATA RETENTION  NEURAL MESH ACTIVE 
                        </div>
                        
                        <!-- ACTIVATION ZONE -->
                        <div style="text-align: center; margin: 30px 0;">
                            <button id="jackInBtn" onclick="activateNeuralInterface()" style="
                                background: linear-gradient(135deg, #40E0D0 0%, #00ff88 50%, #48CAE4 100%);
                                background-size: 200% 200%;
                                color: #000; border: none; 
                                padding: 18px 40px;
                                font-family: 'Orbitron', monospace; font-weight: 900;
                                font-size: 16px; text-transform: uppercase; letter-spacing: 3px;
                                cursor: pointer; position: relative; overflow: hidden;
                                border-radius: 25px;
                                transition: all 0.3s ease;
                                animation: buttonGlow 2s ease-in-out infinite alternate;
                                box-shadow: 
                                    0 0 30px rgba(64,224,208,0.6),
                                    0 0 60px rgba(64,224,208,0.3),
                                    inset 0 0 30px rgba(255,255,255,0.1);
                            " 
                            onmouseover="this.style.transform='scale(1.1)'; this.style.animation='buttonGlow 0.5s ease-in-out infinite alternate'" 
                            onmouseout="this.style.transform='scale(1)'; this.style.animation='buttonGlow 2s ease-in-out infinite alternate'">
                                <span style="position: relative; z-index: 2;"> INITIATE NEURAL LINK </span>
                                <div style="
                                    position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
                                    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
                                    animation: buttonShine 3s linear infinite;
                                "></div>
                            </button>
                        </div>
                        
                        <div style="
                            text-align: center; margin-top: 20px; font-size: 10px;
                            color: rgba(64,224,208,0.6); font-family: 'Courier Prime', monospace;
                            animation: statusBlink 3s ease-in-out infinite;
                        ">
                             ESC TO BYPASS  AUTO-INIT IN <span id="countdown" style="color: #40E0D0; font-weight: bold;">15</span>s 
                        </div>
                    </div>
                </div>
            `;
            
            // Add ULTIMATE CYBERPUNK ANIMATIONS!
            const style = document.createElement('style');
            style.textContent = `
                @keyframes neuralBoot {
                    0% { 
                        transform: scale(0.3) rotateY(180deg); 
                        opacity: 0; 
                        filter: blur(20px) hue-rotate(180deg);
                    }
                    30% { 
                        transform: scale(1.1) rotateY(0deg); 
                        opacity: 0.7; 
                        filter: blur(5px) hue-rotate(90deg);
                    }
                    100% { 
                        transform: scale(1) rotateY(0deg); 
                        opacity: 1; 
                        filter: blur(0px) hue-rotate(0deg);
                    }
                }
                
                @keyframes gradientShift {
                    0%, 100% { background-position: 0% 50%; }
                    50% { background-position: 100% 50%; }
                }
                
                @keyframes logoGlow {
                    0% { filter: drop-shadow(0 0 20px rgba(64,224,208,0.8)); }
                    100% { filter: drop-shadow(0 0 40px rgba(64,224,208,1)) drop-shadow(0 0 80px rgba(0,255,136,0.5)); }
                }
                
                @keyframes logoScale {
                    0%, 100% { transform: scale(1); }
                    50% { transform: scale(1.02); }
                }
                
                @keyframes subtitleGlow {
                    0% { text-shadow: 0 0 10px rgba(64,224,208,0.5); }
                    100% { text-shadow: 0 0 20px rgba(64,224,208,0.8), 0 0 40px rgba(64,224,208,0.4); }
                }
                
                @keyframes textGlow {
                    0% { text-shadow: 0 0 5px rgba(0,0,0,0.5); }
                    100% { text-shadow: 0 0 5px rgba(0,0,0,0.5), 0 0 15px rgba(64,224,208,0.3); }
                }
                
                @keyframes shimmer {
                    0% { transform: translateX(-100%) translateY(-100%); }
                    100% { transform: translateX(200%) translateY(200%); }
                }
                
                @keyframes dataStream {
                    0% { transform: translateX(-100%); opacity: 0; }
                    20% { opacity: 1; }
                    80% { opacity: 1; }
                    100% { transform: translateX(100%); opacity: 0; }
                }
                
                @keyframes warningPulse {
                    0%, 100% { 
                        border-color: rgba(255,20,147,0.6);
                        box-shadow: 0 0 10px rgba(255,20,147,0.3);
                    }
                    50% { 
                        border-color: rgba(255,20,147,1);
                        box-shadow: 0 0 25px rgba(255,20,147,0.6), inset 0 0 20px rgba(255,20,147,0.1);
                    }
                }
                
                @keyframes warningSwipe {
                    0% { left: -100%; }
                    100% { left: 100%; }
                }
                
                @keyframes buttonGlow {
                    0% { 
                        box-shadow: 
                            0 0 30px rgba(64,224,208,0.6),
                            0 0 60px rgba(64,224,208,0.3),
                            inset 0 0 30px rgba(255,255,255,0.1);
                    }
                    100% { 
                        box-shadow: 
                            0 0 50px rgba(64,224,208,0.9),
                            0 0 100px rgba(64,224,208,0.5),
                            0 0 150px rgba(0,255,136,0.3),
                            inset 0 0 50px rgba(255,255,255,0.2);
                    }
                }
                
                @keyframes buttonShine {
                    0% { left: -100%; }
                    100% { left: 100%; }
                }
                
                @keyframes statusBlink {
                    0%, 90% { opacity: 0.6; }
                    95% { opacity: 1; }
                }
                
                @keyframes scanShift {
                    0% { transform: translateY(0px); }
                    100% { transform: translateY(50px); }
                }
                
                @keyframes matrixRain {
                    0% { transform: translateY(-100vh); opacity: 1; }
                    100% { transform: translateY(100vh); opacity: 0; }
                }
                
                /* ENHANCED MATRIX CHARACTERS */
                .matrix-char {
                    color: rgba(64,224,208,0.8);
                    text-shadow: 0 0 5px rgba(64,224,208,0.5);
                    font-weight: bold;
                }
                
                .matrix-char:nth-child(odd) {
                    color: rgba(0,255,136,0.6);
                    text-shadow: 0 0 3px rgba(0,255,136,0.4);
                }
                
                .matrix-char:nth-child(3n) {
                    color: rgba(72,202,228,0.4);
                    text-shadow: 0 0 2px rgba(72,202,228,0.3);
                }
            `;
            document.head.appendChild(style);
            
            document.body.appendChild(modal);
            
            // EPIC FADE-IN WITH CYBERPUNK COLORS
            setTimeout(() => {
                modal.style.background = 'radial-gradient(circle at center, rgba(0,20,30,0.95) 0%, rgba(0,10,15,0.98) 100%)';
                modal.style.backdropFilter = 'blur(15px) saturate(1.2)';
                modal.style.opacity = '1';
            }, 100);
            
            // Create matrix rain effects in status boxes
            setTimeout(() => createStatusBoxMatrix(), 200);
            
            // Boot sequence animation
            setTimeout(() => animateBootSequence(), 500);
            
            // Countdown timer
            let countdown = 15;
            const countdownInterval = setInterval(() => {
                const countdownEl = document.getElementById('countdown');
                if (countdownEl && countdown > 0) {
                    countdownEl.textContent = --countdown;
                } else {
                    clearInterval(countdownInterval);
                    if (document.contains(modal)) {
                        activateNeuralInterface();
                    }
                }
            }, 1000);
            
            // ESC key to close
            function handleWelcomeEsc(e) {
                if (e.key === 'Escape' && document.contains(modal)) {
                    clearInterval(countdownInterval);
                    activateNeuralInterface();
                    document.removeEventListener('keydown', handleWelcomeEsc);
                }
            }
            document.addEventListener('keydown', handleWelcomeEsc);
        }
        
        function createStatusBoxMatrix() {
            // Create matrix effects in both status boxes
            createMatrixInBox('neural-matrix', 'rgba(64,224,208,0.6)', 6);
            createMatrixInBox('mesh-matrix', 'rgba(0,255,136,0.4)', 8);
        }
        
        function createMatrixInBox(className, color, columnCount) {
            const containers = document.querySelectorAll(`.${className}`);
            const chars = '01010';
            
            containers.forEach(container => {
                for (let i = 0; i < columnCount; i++) {
                    const column = document.createElement('div');
                    column.style.cssText = `
                        position: absolute;
                        left: ${Math.random() * 100}%;
                        top: 0;
                        animation: matrixRain ${Math.random() * 4 + 3}s linear infinite;
                        animation-delay: ${Math.random() * 3}s;
                        font-size: ${Math.random() * 2 + 6}px;
                        color: ${color};
                        text-shadow: 0 0 2px ${color};
                        font-family: 'Courier Prime', monospace;
                        line-height: 1;
                        z-index: 1;
                    `;
                    
                    let text = '';
                    for (let j = 0; j < 12; j++) {
                        text += chars[Math.floor(Math.random() * chars.length)] + '<br>';
                    }
                    column.innerHTML = text;
                    container.appendChild(column);
                }
            });
        }
        
        function animateBootSequence() {
            const neuralBootEl = document.getElementById('neuralBootSequence');
            const meshBootEl = document.getElementById('meshBootSequence');
            
            if (!neuralBootEl || !meshBootEl) return;
            
            const neuralMessages = [
                ' QUANTUM CORE INITIATED',
                ' AI AGENTS LOADING...',
                ' MEMORY CORES ACTIVE',
                ' LEARNING PROTOCOLS ON'
            ];
            
            const meshMessages = [
                ' P2P ROUTES SCANNING',
                ' AES-256 ENCRYPTION OK',
                ' PATHWAYS SYNCHRONIZING',
                ' MESH NETWORK READY'
            ];
            
            // Animate neural core messages
            let neuralIndex = 0;
            function typeNeuralMessage() {
                if (neuralIndex < neuralMessages.length) {
                    neuralBootEl.innerHTML += neuralMessages[neuralIndex] + '<br>';
                    neuralIndex++;
                    setTimeout(typeNeuralMessage, 400);
                }
            }
            
            // Animate mesh network messages (with slight delay)
            let meshIndex = 0;
            function typeMeshMessage() {
                if (meshIndex < meshMessages.length) {
                    meshBootEl.innerHTML += meshMessages[meshIndex] + '<br>';
                    meshIndex++;
                    setTimeout(typeMeshMessage, 450);
                }
            }
            
            // Start both sequences
            setTimeout(typeNeuralMessage, 200);
            setTimeout(typeMeshMessage, 600);
        }
        
        function activateNeuralInterface() {
            const modal = document.querySelector('[style*="position: fixed"][style*="z-index: 10000"]');
            if (modal) {
                // Fade both the backdrop and terminal together
                modal.style.opacity = '0';
                modal.style.transition = 'opacity 0.8s ease-out';
                
                setTimeout(() => {
                    modal.remove();
                    document.getElementById('chatInput')?.focus();
                }, 800);
            }
        }
        
        function showQRFallback() {
            const qrContainer = document.getElementById('qrContainer');
            const qrLoading = document.getElementById('qrLoading');
            
            if (qrContainer && qrLoading) {
                qrLoading.style.display = 'none';
                qrContainer.innerHTML = `
                    <div style="
                        padding: 20px; background: rgba(255,68,68,0.1);
                        border: 1px solid rgba(255,68,68,0.3); border-radius: 10px;
                        color: #ff6666; text-align: center;
                    ">
                        <div style="margin-bottom: 10px;"> QR Code Unavailable</div>
                        <div style="font-size: 12px; opacity: 0.8;">
                            Network issue detected<br>
                            Use the link below instead
                        </div>
                    </div>
                `;
            }
        }

        // ============================================================================
        // MENU FUNCTIONS
        // ============================================================================
        
        function toggleAISettings() {
            alert(' AI Settings panel - Coming soon!\n\nFeatures:\n Response creativity level\n Memory retention settings\n Learning rate adjustment\n Concept association strength');
        }
        
        function showMemoryTools() {
            // Create memory visualizer modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.9); z-index: 10000;
                display: flex; align-items: center; justify-content: center;
                color: white; font-family: inherit;
            `;
            
            const concepts = Array.from(fractalMemory.concepts.entries());
            const recentConcepts = concepts
                .sort((a, b) => b[1].timestamp - a[1].timestamp)
                .slice(0, 10);
            
            const conceptList = recentConcepts.length > 0 
                ? recentConcepts.map(([id, concept]) => `
                    <div style="background: rgba(64,224,208,0.1); margin: 5px 0; padding: 8px; border-radius: 5px; border-left: 3px solid #40E0D0;">
                        <div style="font-size: 12px; opacity: 0.7;">${new Date(concept.timestamp).toLocaleString()}</div>
                        <div style="margin: 5px 0;">${concept.text.substring(0, 100)}${concept.text.length > 100 ? '...' : ''}</div>
                        <div style="font-size: 11px; opacity: 0.6;">Relevance: ${concept.relevance.toFixed(2)} | Context: ${concept.context.type || 'general'}</div>
                    </div>
                `).join('')
                : '<p style="opacity: 0.7; text-align: center; padding: 20px;">No concepts stored yet. Start chatting to build memories!</p>';
            
            modal.innerHTML = `
                <div style="background: rgba(0,0,0,0.9); padding: 30px; border-radius: 15px; border: 1px solid #40E0D0; max-width: 80%; max-height: 80%; overflow-y: auto;">
                    <h3 style="color: #40E0D0; margin-bottom: 20px; text-align: center;"> Fractal Compression System</h3>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-bottom: 20px; text-align: center;">
                        <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 10px;">
                            <div style="font-size: 24px; color: #40E0D0;">${fractalMemory.concepts.size}</div>
                            <div style="font-size: 12px; opacity: 0.7;">Stored Concepts</div>
                        </div>
                        <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 10px;">
                            <div style="font-size: 24px; color: #48CAE4;">${fractalMemory.associations.size}</div>
                            <div style="font-size: 12px; opacity: 0.7;">Neural Links</div>
                        </div>
                        <div style="background: rgba(255,255,255,0.05); padding: 15px; border-radius: 10px;">
                            <div style="font-size: 24px; color: #0077BE;">${Math.round(concepts.reduce((sum, [_, c]) => sum + c.relevance, 0))}</div>
                            <div style="font-size: 12px; opacity: 0.7;">Total Relevance</div>
                        </div>
                    </div>
                    
                    <h4 style="color: #40E0D0; margin: 20px 0 10px 0;"> Recent Concepts</h4>
                    <div style="max-height: 300px; overflow-y: auto;">
                        ${conceptList}
                    </div>
                    
                    <div style="text-align: center; margin-top: 20px;">
                        <button onclick="exportMemory(); this.parentElement.parentElement.parentElement.remove();" 
                                style="background: #40E0D0; color: black; border: none; padding: 10px 20px; border-radius: 5px; margin: 5px; cursor: pointer;">
                             Export Memory
                        </button>
                        <button onclick="importMemory(); this.parentElement.parentElement.parentElement.remove();" 
                                style="background: #48CAE4; color: black; border: none; padding: 10px 20px; border-radius: 5px; margin: 5px; cursor: pointer;">
                             Import Memory
                        </button>
                        <button onclick="if(confirm('Clear all memories?')) { clearMemory(); } this.parentElement.parentElement.parentElement.remove();" 
                                style="background: #ff4444; color: white; border: none; padding: 10px 20px; border-radius: 5px; margin: 5px; cursor: pointer;">
                             Clear All
                        </button>
                        <button onclick="this.parentElement.parentElement.parentElement.remove();" 
                                style="background: #666; color: white; border: none; padding: 10px 20px; border-radius: 5px; margin: 5px; cursor: pointer;">
                            Close
                        </button>
                    </div>
                </div>
                `;
            
            document.body.appendChild(modal);
        }
        
        // Copy to clipboard helper
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                alert(' Copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy:', err);
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = text;
                textArea.style.position = 'fixed';
                textArea.style.left = '-999999px';
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                try {
                    document.execCommand('copy');
                    alert(' Copied to clipboard!');
                } catch (err) {
                    alert(' Failed to copy. Please copy manually.');
                }
                document.body.removeChild(textArea);
            });
        }
        
        // Close QR modal
        function closeQRModal() {
            const modal = document.getElementById('qrModal');
            if (modal) {
                modal.remove();
            }
        }
        
        // Legacy function for compatibility
        function closeMagicCardModal() {
            closeQRModal();
        }
        
        function toggleAPIConfig() {
            // Create API configuration modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.9); z-index: 10000;
                display: flex; align-items: center; justify-content: center;
                color: white; font-family: inherit;
            `;
            
            const providers = SynapseCore.config.apiProviders;
            const activeAgent = SynapseCore.config.activeAgent;
            const multiAgentMode = SynapseCore.config.multiAgentMode;
            
            const providerRows = Object.entries(providers).map(([key, config]) => {
                const isActive = key === activeAgent && !multiAgentMode;
                const statusColor = config.enabled ? '#00ff00' : '#666';
                
                return `
                    <div style="background: rgba(255,255,255,${isActive ? '0.1' : '0.05'}); margin: 8px 0; padding: 12px; border-radius: 8px; border: 1px solid ${isActive ? '#40E0D0' : 'rgba(255,255,255,0.1)'}; display: flex; align-items: center; justify-content: space-between;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <input type="checkbox" id="enable_${key}" ${config.enabled ? 'checked' : ''} onchange="updateProvider('${key}', 'enabled', this.checked)">
                            <div style="color: ${statusColor}; font-weight: 600;">${config.name}</div>
                            ${isActive ? '<span style="background: #40E0D0; color: black; padding: 2px 8px; border-radius: 10px; font-size: 11px;">ACTIVE</span>' : ''}
                        </div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            ${key !== 'offline' ? `
                                <input type="text" id="key_${key}" placeholder="API Key" value="${config.apiKey || ''}" 
                                       style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; padding: 4px 8px; border-radius: 4px; width: 120px;"
                                       onchange="updateProvider('${key}', 'apiKey', this.value)">
                            ` : ''}
                            ${key === 'other' ? `
                                <input type="text" id="endpoint_${key}" placeholder="API Endpoint" value="${config.endpoint || ''}" 
                                       style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; padding: 4px 8px; border-radius: 4px; width: 180px; margin-left: 4px;"
                                       onchange="updateProvider('${key}', 'endpoint', this.value)">
                                <input type="text" id="name_${key}" placeholder="Provider Name" value="${config.name}" 
                                       style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: white; padding: 4px 8px; border-radius: 4px; width: 100px; margin-left: 4px;"
                                       onchange="updateProvider('${key}', 'name', this.value)">
                            ` : ''}
                            ${key !== 'offline' ? `
                                <button onclick="setActiveAgent('${key}')" style="background: ${isActive ? '#40E0D0' : '#666'}; color: ${isActive ? 'black' : 'white'}; border: none; padding: 4px 8px; border-radius: 4px; cursor: pointer; font-size: 11px;">
                                    ${isActive ? 'ACTIVE' : 'SET ACTIVE'}
                                </button>
                            ` : ''}
                        </div>
                    </div>
                `;
            }).join('');
            
            modal.innerHTML = `
                <div style="background: rgba(0,0,0,0.9); padding: 30px; border-radius: 15px; border: 1px solid #40E0D0; max-width: 600px; width: 90%;">
                    <h3 style="color: #40E0D0; margin-bottom: 20px; text-align: center;"> AI Agent Configuration</h3>
                    
                    <div style="margin-bottom: 20px; text-align: center;">
                        <label style="display: flex; align-items: center; justify-content: center; gap: 10px; cursor: pointer;">
                            <input type="checkbox" id="multiAgentToggle" ${multiAgentMode ? 'checked' : ''} onchange="toggleMultiAgentMode(this.checked)">
                            <span style="font-weight: 600; color: ${multiAgentMode ? '#40E0D0' : '#666'};">Multi-Agent Mode</span>
                        </label>
                        <div style="font-size: 12px; opacity: 0.7; margin-top: 5px;">
                            ${multiAgentMode ? 'All enabled agents will respond simultaneously' : 'Only the active agent will respond'}
                        </div>
                    </div>
                    
                    <div style="max-height: 300px; overflow-y: auto;">
                        ${providerRows}
                    </div>
                    
                    <div style="text-align: center; margin-top: 20px;">
                        <button onclick="saveAPIConfig(); this.parentElement.parentElement.parentElement.remove();" 
                                style="background: #40E0D0; color: black; border: none; padding: 10px 20px; border-radius: 5px; margin: 5px; cursor: pointer;">
                            Save Configuration
                        </button>
                        <button onclick="this.parentElement.parentElement.parentElement.remove();" 
                                style="background: #666; color: white; border: none; padding: 10px 20px; border-radius: 5px; margin: 5px; cursor: pointer;">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function updateProvider(provider, field, value) {
            SynapseCore.config.apiProviders[provider][field] = value;
        }
        
        function setActiveAgent(provider) {
            SynapseCore.config.activeAgent = provider;
            SynapseCore.config.multiAgentMode = false;
        }
        
        function toggleMultiAgentMode(enabled) {
            SynapseCore.config.multiAgentMode = enabled;
        }
        
        function saveAPIConfig() {
            // Update status display
            const statusText = document.getElementById('statusText');
            if (SynapseCore.config.multiAgentMode) {
                const enabledCount = Object.values(SynapseCore.config.apiProviders)
                    .filter(config => config.enabled).length;
                statusText.textContent = `Multi-Agent (${enabledCount} active)`;
            } else {
                const activeConfig = SynapseCore.config.apiProviders[SynapseCore.config.activeAgent];
                statusText.textContent = `Connected: ${activeConfig.name}`;
            }
            
            // Save to localStorage
            localStorage.setItem('synapse_config', JSON.stringify(SynapseCore.config));
            
            alert(' API configuration saved successfully!');
        }
        
        // QR Code generation utility
        function generateQRCode(text) {
            const encodedText = encodeURIComponent(text);
            // Use QRServer.com - tested and working
            return `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodedText}`;
        }
        
        // Enhanced QR generation with fallback
        function generateQRCodeWithFallback(text, containerId) {
            const encodedText = encodeURIComponent(text);
            const services = [
                `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodedText}`,
                `https://chart.googleapis.com/chart?chs=200x200&cht=qr&chl=${encodedText}`,
                `https://qr-server.com/api/v1/create-qr-code/?size=200x200&data=${encodedText}`
            ];
            
            let currentService = 0;
            
            function tryNextService() {
                if (currentService >= services.length) {
                    showQRFallback();
                    return;
                }
                
                const img = document.getElementById('qrImage');
                if (img) {
                    img.src = services[currentService];
                    currentService++;
                }
            }
            
            // Override the error handler to try next service
            setTimeout(() => {
                const img = document.getElementById('qrImage');
                if (img) {
                    img.onerror = tryNextService;
                }
            }, 100);
            
            return services[0]; // Return first service URL
        }
        
        // Generate universal join link that works for anyone
        function generateUniversalJoinLink(pathwayId, pathwayName, inviteCode) {
            const serverUrl = window.location.origin; // Gets current server URL
            return `${serverUrl}/join/${pathwayId}?invite=${encodeURIComponent(inviteCode)}&name=${encodeURIComponent(pathwayName)}`;
        }
        
        function createPathway() {
            const name = prompt('Enter pathway name:', 'New Pathway');
            if (name) {
                const result = pathwayNetwork.createPathway(name);
                const pathway = pathwayNetwork.pathways.get(result.pathwayId);
                
                // Immediately open the pathway chat window
                createPathwayWindow(result.pathwayId, pathway, result.inviteCode);
            }
        }
        
        function joinPathway() {
            const inviteCode = prompt('Enter pathway invite code or paste join link:');
            if (inviteCode) {
                processJoinInput(inviteCode);
            }
        }
        
        function promptJoinPathway() {
            const input = prompt(
                'Join Pathway\n\n' +
                'Paste either:\n' +
                ' A join link (http://...)\n' +
                ' An invite code\n\n' +
                'Enter here:'
            );
            
            if (input && input.trim()) {
                processJoinInput(input.trim());
            }
        }
        
        function processJoinInput(input) {
            try {
                // Check if it's a URL (join link)
                if (input.startsWith('http')) {
                    // Extract invite code from URL
                    const url = new URL(input);
                    const inviteFromUrl = url.searchParams.get('invite');
                    const nameFromUrl = url.searchParams.get('name');
                    
                    if (inviteFromUrl) {
                        const success = pathwayNetwork.joinPathway(inviteFromUrl);
                        if (success) {
                            alert(` Successfully joined: ${nameFromUrl || 'Unknown Pathway'}!`);
                            return;
                        }
                    }
                    alert(' Invalid join link. Please check and try again.');
                    return;
                }
                
                // Try as direct invite code
                const success = pathwayNetwork.joinPathway(input);
                if (success) {
                    alert(' Successfully joined pathway!');
                } else {
                    alert(' Invalid invite code. Please check and try again.');
                }
                
            } catch (error) {
                console.error('Error processing join input:', error);
                alert(' Invalid format. Please check your invite code or link.');
            }
        }
        
        function deletePathway(pathwayId) {
            const pathway = pathwayNetwork.pathways.get(pathwayId);
            if (!pathway) return;
            
            const confirmDelete = confirm(`Delete "${pathway.name}"?\n\nThis will permanently remove the pathway and close any open chat windows.`);
            if (confirmDelete) {
                // Close pathway window if open
                closePathwayWindow(pathwayId);
                
                // Remove from network
                pathwayNetwork.pathways.delete(pathwayId);
                pathwayNetwork.messageQueue.delete(pathwayId);
                
                // Update UI
                pathwayNetwork.updatePathwaysUI();
                
                alert(' Pathway deleted successfully');
            }
        }
        
        function scanQRCode() {
            // Create QR scanner modal for joining pathways
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.95); z-index: 10000;
                display: flex; align-items: center; justify-content: center;
                color: white; font-family: inherit;
            `;
            
            modal.innerHTML = `
                <div style="background: rgba(0,0,0,0.9); padding: 30px; border-radius: 15px; border: 1px solid #40E0D0; text-align: center; max-width: 500px; width: 90%;">
                    <h3 style="color: #40E0D0; margin-bottom: 20px;"> Join Pathway</h3>
                    
                    <div id="qr-reader" style="width: 100%; margin: 20px 0; border-radius: 10px; overflow: hidden; background: #000; min-height: 200px; display: flex; align-items: center; justify-content: center; color: #666;">
                        <div>Camera will appear here</div>
                    </div>
                    
                    <div style="margin: 15px 0; font-size: 14px; opacity: 0.7;">
                        Scan a pathway QR code to join
                    </div>
                    
                    <div style="display: flex; gap: 10px; justify-content: center; margin: 15px 0;">
                        <button onclick="startQRScanner()" id="startScanBtn"
                                style="background: #40E0D0; color: black; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer;">
                             Start Camera
                        </button>
                        <button onclick="stopQRScanner(); this.parentElement.parentElement.parentElement.remove();" 
                                style="background: #666; color: white; border: none; padding: 8px 16px; border-radius: 5px; cursor: pointer;">
                            Cancel
                        </button>
                    </div>
                    
                    <div style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 15px;">
                        <div style="font-size: 12px; opacity: 0.5; margin-bottom: 8px;">
                            Or enter invite code manually:
                        </div>
                        <input type="text" id="manualCode" placeholder="Paste invite code here" 
                               style="width: 100%; margin: 8px 0; padding: 10px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3); border-radius: 5px; color: white; font-size: 12px;">
                        <button onclick="joinWithManualCode()" 
                                style="background: rgba(64,224,208,0.2); border: 1px solid rgba(64,224,208,0.4); color: #40E0D0; padding: 8px 16px; border-radius: 5px; cursor: pointer; font-size: 12px;">
                            Join Pathway
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            window.currentQRModal = modal;
        }
        
        let qrStream = null;
        
        function startQRScanner() {
            const video = document.createElement('video');
            const qrReader = document.getElementById('qr-reader');
            const startBtn = document.getElementById('startScanBtn');
            
            if (!qrReader) return;
            
            video.style.cssText = 'width: 100%; height: 250px; object-fit: cover;';
            qrReader.innerHTML = '';
            qrReader.appendChild(video);
            
            startBtn.textContent = ' Stop Camera';
            startBtn.onclick = () => { stopQRScanner(); startBtn.textContent = ' Start Camera'; startBtn.onclick = startQRScanner; };
            
            navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } })
                .then(stream => {
                    qrStream = stream;
                    video.srcObject = stream;
                    video.play();
                    
                    // Simple QR detection simulation (in a real app, use a QR library like jsQR)
                    qrReader.onclick = () => {
                        const code = prompt('QR Code detected! Enter the invite code:');
                        if (code) {
                            processQRCode(code);
                        }
                    };
                })
                .catch(err => {
                    console.error('Camera access denied:', err);
                    qrReader.innerHTML = `
                        <div style="padding: 20px; color: #ff4444;">
                             Camera access denied<br>
                            <small>Please use manual code entry below</small>
                        </div>
                    `;
                });
        }
        
        function stopQRScanner() {
            if (qrStream) {
                qrStream.getTracks().forEach(track => track.stop());
                qrStream = null;
            }
        }
        
        function processQRCode(code) {
            try {
                // Check if it's a URL (universal join link)
                if (code.startsWith('http')) {
                    stopQRScanner();
                    if (window.currentQRModal) {
                        window.currentQRModal.remove();
                    }
                    
                    // Open the join link directly
                    window.location.href = code;
                    return;
                }
                
                // Try to decode as pathway invite code
                const inviteData = JSON.parse(atob(code));
                
                if (inviteData.pathwayId) {
                    // Use the standard join pathway method
                    const success = pathwayNetwork.joinPathway(code);
                    
                    stopQRScanner();
                    if (window.currentQRModal) {
                        window.currentQRModal.remove();
                    }
                    
                    if (success) {
                        // Open the pathway chat directly
                        setTimeout(() => {
                            const pathway = pathwayNetwork.pathways.get(inviteData.pathwayId);
                            if (pathway) {
                                createPathwayWindow(inviteData.pathwayId, pathway);
                            }
                        }, 1000);
                        
                        alert(` Successfully joined pathway: ${inviteData.name || 'Unknown'}`);
                    } else {
                        alert(' Failed to join pathway. Please try again.');
                    }
                    return;
                }
            } catch (error) {
                console.log('Error processing QR code:', error);
            }
            
            // If all else fails, show error
            alert(' Invalid QR code format. Please make sure you\'re scanning a Synapse pathway invite.');
        }
        
        function joinWithManualCode() {
            const code = document.getElementById('manualCode')?.value.trim();
            if (code) {
                processQRCode(code);
            }
        }
        
        function applyExpiration(pathwayId) {
            const pathway = pathwayNetwork.pathways.get(pathwayId);
            if (!pathway || window.currentExpirationValue === undefined) return;
            
            pathway.messageExpiration = window.currentExpirationValue;
            
            // Get human-readable label
            const options = [
                'read once', '5 minutes', '1 hour', '24 hours', '7 days', 'never'
            ];
            const sliderValue = document.getElementById('expirationSlider')?.value || 3;
            const selectedOption = options[sliderValue];
            
            // Update ready message if pathway window is open
            updatePathwayReadyMessage(pathwayId);
            
            // Close modal silently
            const modal = document.querySelector('[style*="position: fixed"][style*="z-index: 10000"]');
            if (modal) modal.remove();
            
            console.log(` Message expiration set for pathway ${pathwayId}: ${selectedOption}`);
        }
        
        function toggleMessageExpiration(pathwayId) {
            const pathway = pathwayNetwork.pathways.get(pathwayId);
            if (!pathway) return;
            
            // Create futuristic expiration slider modal
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.95); z-index: 10000;
                display: flex; align-items: center; justify-content: center;
                color: white; font-family: 'Orbitron', monospace;
                backdrop-filter: blur(10px);
            `;
            
            const currentExpiration = pathway.messageExpiration || 86400000; // 24h default
            
            modal.innerHTML = `
                <div style="
                    background: linear-gradient(135deg, rgba(0,20,40,0.98), rgba(0,10,30,0.98));
                    border: 2px solid rgba(64,224,208,0.6);
                    border-radius: 15px;
                    padding: 40px;
                    max-width: 500px;
                    width: 90%;
                    text-align: center;
                    box-shadow: 
                        0 0 30px rgba(64,224,208,0.3),
                        inset 0 0 30px rgba(64,224,208,0.05);
                    position: relative;
                    overflow: hidden;
                ">
                    <!-- Scanning line effect -->
                    <div style="
                        position: absolute; top: 0; left: 0; width: 100%; height: 2px;
                        background: linear-gradient(90deg, transparent, #40E0D0, transparent);
                        animation: scanLine 2s linear infinite;
                    "></div>
                    
                    <div style="
                        font-size: 18px; font-weight: bold; color: #40E0D0;
                        margin-bottom: 10px; letter-spacing: 2px;
                        text-shadow: 0 0 10px rgba(64,224,208,0.5);
                    ">
                        MESSAGE EXPIRATION
                    </div>
                    
                    <div style="
                        font-size: 12px; color: rgba(255,255,255,0.7);
                        margin-bottom: 30px; font-family: 'Courier Prime', monospace;
                    ">
                        Configure auto-purge timer for enhanced security
                    </div>
                    
                    <!-- Futuristic Slider Container -->
                    <div style="
                        background: rgba(0,0,0,0.4);
                        border: 1px solid rgba(64,224,208,0.3);
                        border-radius: 25px;
                        padding: 25px;
                        margin: 25px 0;
                        position: relative;
                    ">
                        <div id="expirationDisplay" style="
                            font-size: 24px; font-weight: bold; color: #00ff88;
                            margin-bottom: 20px; font-family: 'Orbitron', monospace;
                            text-shadow: 0 0 15px rgba(0,255,136,0.6);
                        ">24 HOURS</div>
                        
                        <!-- Custom Slider -->
                        <div style="position: relative; height: 40px; margin: 20px 0;">
                            <div style="
                                position: absolute; top: 50%; left: 0; right: 0;
                                height: 4px; background: rgba(64,224,208,0.2);
                                border-radius: 2px; transform: translateY(-50%);
                            "></div>
                            
                            <div id="sliderProgress" style="
                                position: absolute; top: 50%; left: 0;
                                height: 4px; background: linear-gradient(90deg, #ff0080, #00ff88, #40E0D0);
                                border-radius: 2px; transform: translateY(-50%);
                                width: 60%; transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
                                box-shadow: 0 0 10px rgba(64,224,208,0.6);
                            "></div>
                            
                            <input type="range" id="expirationSlider" 
                                   min="0" max="122" value="60" step="1"
                                   style="
                                       position: absolute; top: 50%; left: 0; right: 0;
                                       transform: translateY(-50%); opacity: 0;
                                       cursor: pointer; height: 40px; width: 100%;
                                       -webkit-appearance: none; appearance: none;
                                   ">
                            
                            <div id="sliderThumb" style="
                                position: absolute; top: 50%; 
                                left: 60%; transform: translate(-50%, -50%);
                                width: 20px; height: 20px;
                                background: radial-gradient(circle, #40E0D0, #00ff88);
                                border: 2px solid #ffffff;
                                border-radius: 50%;
                                box-shadow: 0 0 15px rgba(64,224,208,0.8);
                                transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
                                pointer-events: none;
                            "></div>
                        </div>
                        
                        <!-- Options Display -->
                        <div style="
                            display: flex; justify-content: space-between;
                            font-size: 10px; color: rgba(255,255,255,0.5);
                            margin-top: 15px; font-family: 'Courier Prime', monospace;
                        ">
                            <span>read</span><span>5m</span><span>30m</span><span>1h</span><span>24h</span><span></span>
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 15px; justify-content: center; margin-top: 25px;">
                        <button onclick="applyExpiration('${pathwayId}')" style="
                            background: linear-gradient(45deg, #40E0D0, #00ff88);
                            color: #000012; border: none; padding: 12px 25px;
                            border-radius: 25px; font-family: 'Orbitron', monospace;
                            font-weight: bold; cursor: pointer; font-size: 12px;
                            text-transform: uppercase; letter-spacing: 1px;
                            box-shadow: 0 0 15px rgba(64,224,208,0.4);
                            transition: all 0.3s ease;
                        " onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                            Apply
                        </button>
                        
                        <button onclick="this.parentElement.parentElement.parentElement.remove()" style="
                            background: rgba(255,255,255,0.1); color: rgba(255,255,255,0.7);
                            border: 1px solid rgba(255,255,255,0.3); padding: 12px 25px;
                            border-radius: 25px; font-family: 'Orbitron', monospace;
                            cursor: pointer; font-size: 12px;
                            transition: all 0.3s ease;
                        " onmouseover="this.style.background='rgba(255,255,255,0.2)'" onmouseout="this.style.background='rgba(255,255,255,0.1)'">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // Add scan line animation
            if (!document.getElementById('scanLineStyle')) {
                const style = document.createElement('style');
                style.id = 'scanLineStyle';
                style.textContent = `
                    @keyframes scanLine {
                        0% { left: -100%; }
                        100% { left: 100%; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Initialize slider functionality immediately
            setTimeout(() => {
                const slider = document.getElementById('expirationSlider');
                const display = document.getElementById('expirationDisplay');
                const progress = document.getElementById('sliderProgress');
                const thumb = document.getElementById('sliderThumb');
                
                function getTimeFromSliderValue(value) {
                    if (value === 0) return { label: 'READ ONCE', ms: 0, color: '#ff0080' };
                    if (value === 122) return { label: 'NEVER', ms: -1, color: '#aa88ff' };
                    
                    // Convert 1-121 to minutes
                    const minutes = value;
                    const ms = minutes * 60 * 1000;
                    
                    let label, color;
                    if (minutes < 60) {
                        label = `${minutes} MIN${minutes !== 1 ? 'S' : ''}`;
                        color = minutes <= 10 ? '#ff4444' : minutes <= 30 ? '#ffaa00' : '#ff8800';
                    } else if (minutes < 1440) { // < 24 hours
                        const hours = Math.floor(minutes / 60);
                        const remainingMins = minutes % 60;
                        if (remainingMins === 0) {
                            label = `${hours} HOUR${hours !== 1 ? 'S' : ''}`;
                        } else {
                            label = `${hours}H ${remainingMins}M`;
                        }
                        color = '#00ff88';
                    } else { // >= 24 hours
                        const days = Math.floor(minutes / 1440);
                        const remainingHours = Math.floor((minutes % 1440) / 60);
                        if (remainingHours === 0) {
                            label = `${days} DAY${days !== 1 ? 'S' : ''}`;
                        } else {
                            label = `${days}D ${remainingHours}H`;
                        }
                        color = '#40E0D0';
                    }
                    
                    return { label, ms, color };
                }
                
                function updateSlider(value) {
                    const timeOption = getTimeFromSliderValue(value);
                    
                    // Animate text change
                    display.style.transition = 'all 0.2s cubic-bezier(0.25, 0.8, 0.25, 1)';
                    display.style.transform = 'scale(0.95)';
                    display.style.opacity = '0.8';
                    
                    setTimeout(() => {
                        display.textContent = timeOption.label;
                        display.style.color = timeOption.color;
                        display.style.textShadow = `0 0 15px ${timeOption.color}80`;
                        display.style.transform = 'scale(1.02)';
                        display.style.opacity = '1';
                        
                        setTimeout(() => {
                            display.style.transform = 'scale(1)';
                        }, 100);
                    }, 100);
                    
                    // Animate slider elements smoothly
                    const percentage = (value / 122) * 100;
                    progress.style.width = percentage + '%';
                    progress.style.background = `linear-gradient(90deg, #ff0080, ${timeOption.color}, #40E0D0)`;
                    
                    thumb.style.left = percentage + '%';
                    thumb.style.background = `radial-gradient(circle, ${timeOption.color}, #ffffff)`;
                    thumb.style.boxShadow = `0 0 15px ${timeOption.color}, 0 0 30px ${timeOption.color}40`;
                    
                    // Store the actual millisecond value
                    window.currentExpirationValue = timeOption.ms;
                }
                
                slider.addEventListener('input', (e) => {
                    updateSlider(parseInt(e.target.value));
                });
                
                // Set initial value based on current expiration
                let initialValue = 1440; // 24h default (1440 minutes)
                
                if (currentExpiration === 0) {
                    initialValue = 0; // read once
                } else if (currentExpiration === -1) {
                    initialValue = 122; // never
                } else if (currentExpiration > 0) {
                    // Convert milliseconds to minutes
                    const minutes = Math.round(currentExpiration / (60 * 1000));
                    initialValue = Math.min(121, Math.max(1, minutes));
                }
                
                slider.value = initialValue;
                updateSlider(initialValue);
                
                slider.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    updateSlider(value);
                    window.currentExpirationValue = options[value].value;
                });
            }, 10);
        }
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.pathway-dropdown') && !event.target.closest('button[onclick*="togglePathwayDropdown"]')) {
                document.querySelectorAll('.pathway-dropdown').forEach(dropdown => {
                    dropdown.style.display = 'none';
                });
            }
        });
        
        // Show QR code for specific pathway from chat window
        function showPathwayInviteQR(pathwayId) {
            const pathway = pathwayNetwork.pathways.get(pathwayId);
            if (!pathway) return;
            
            // Generate invite code using the PathwayNetwork method
            const inviteCode = pathwayNetwork.generateInviteCode(pathwayId, pathway.name);
            showInviteQR(pathwayId, inviteCode);
        }
        
        let openPathwayWindows = new Map();
        
        function selectPathway(pathwayId) {
            // Check if window already exists
            if (openPathwayWindows.has(pathwayId)) {
                const existingWindow = openPathwayWindows.get(pathwayId);
                if (document.contains(existingWindow)) {
                    existingWindow.style.zIndex = '2001'; // Bring to front
                    return;
                }
            }
            
            const pathway = pathwayNetwork.pathways.get(pathwayId);
            if (!pathway) {
                alert(`Pathway ${pathwayId} not found.`);
                return;
            }
            
            createPathwayWindow(pathwayId, pathway);
        }
        
        function createPathwayWindow(pathwayId, pathway, inviteCode = null) {
            // Create pathway chat window
            const window = document.createElement('div');
            window.className = 'pathway-chat-window';
            window.id = `pathway-${pathwayId}`;
            
            const qrUrl = inviteCode ? generateQRCode(inviteCode) : null;
            
            window.innerHTML = `
                <div class="pathway-chat-header">
                    <div class="pathway-chat-title">
                        <div style="position: relative; margin-right: 10px;">
                            <button onclick="togglePathwayDropdown('${pathwayId}')" 
                                    style="background: transparent; border: none; color: #40E0D0; padding: 4px; cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center; width: 24px; height: 24px; opacity: 0.7;" 
                                    title="Pathway Options"
                                    onmouseover="this.style.opacity='1'"
                                    onmouseout="this.style.opacity='0.7'">
                                
                            </button>
                            <div id="pathway-dropdown-${pathwayId}" class="pathway-dropdown" style="
                                position: absolute; 
                                top: 28px; 
                                left: -5px; 
                                background: rgba(0,0,0,0.95); 
                                border: 1px solid rgba(64,224,208,0.4); 
                                border-radius: 8px; 
                                min-width: 120px; 
                                padding: 4px 0; 
                                z-index: 10001;
                                display: none;
                                backdrop-filter: blur(10px);
                                box-shadow: 0 4px 12px rgba(0,0,0,0.8);">
                                <div onclick="showPathwayQR('${pathwayId}'); hidePathwayDropdown('${pathwayId}');" 
                                     style="padding: 8px 14px; cursor: pointer; font-size: 12px; color: #40E0D0; transition: all 0.2s ease;" 
                                     onmouseover="this.style.background='rgba(64,224,208,0.15)'" 
                                     onmouseout="this.style.background='transparent'">
                                    Share Link
                                </div>
                                <div onclick="changeUsername(); hidePathwayDropdown('${pathwayId}');" 
                                     style="padding: 8px 14px; cursor: pointer; font-size: 12px; color: #40E0D0; transition: all 0.2s ease;" 
                                     onmouseover="this.style.background='rgba(64,224,208,0.15)'" 
                                     onmouseout="this.style.background='transparent'">
                                    Edit Username
                                </div>
                                <div onclick="toggleMessageExpiration('${pathwayId}'); hidePathwayDropdown('${pathwayId}');" 
                                     style="padding: 8px 14px; cursor: pointer; font-size: 12px; color: #40E0D0; transition: all 0.2s ease;" 
                                     onmouseover="this.style.background='rgba(64,224,208,0.15)'" 
                                     onmouseout="this.style.background='transparent'">
                                    Message Timer
                                </div>
                            </div>
                        </div>
                        <span>${pathway.name}</span>
                        <span style="font-size: 12px; opacity: 0.7; margin-left: 10px;">${pathway.peers.size} peer${pathway.peers.size !== 1 ? 's' : ''}</span>
                    </div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <button class="pathway-close-btn" onclick="closePathwayWindow('${pathwayId}')"></button>
                    </div>
                </div>
                
                <div class="pathway-chat-messages" id="pathway-messages-${pathwayId}">
                    <div class="pathway-message peer pathway-ready-message" id="pathway-ready-${pathwayId}" style="align-self: center; background: rgba(64,224,208,0.1); color: #40E0D0; text-align: center; margin: 20px 0;">
                        <div style="font-weight: 600;"> Pathway Ready</div>
                        <div id="pathway-ready-details-${pathwayId}" style="font-size: 12px; opacity: 0.7; margin-top: 5px;">Encrypted  Messages expire in 24h ${inviteCode ? ' Click Invite to share' : ''}</div>
                    </div>
                </div>
                
                <div class="pathway-input-area">
                    <input type="text" class="pathway-input" id="pathway-input-${pathwayId}" 
                           placeholder="Send message..." 
                           onkeypress="handlePathwayKeyPress(event, '${pathwayId}')">
                    <button class="pathway-send-btn" onclick="sendPathwayMessage('${pathwayId}')"></button>
                </div>
            `;
            
            document.body.appendChild(window);
            openPathwayWindows.set(pathwayId, window);
            
            // Update ready message with actual expiration settings
            updatePathwayReadyMessage(pathwayId);
            
            // Focus the input
            setTimeout(() => {
                document.getElementById(`pathway-input-${pathwayId}`)?.focus();
            }, 100);
        }
        
        function showInviteQR(pathwayId, inviteCode) {
            const pathway = pathwayNetwork.pathways.get(pathwayId);
            const pathwayName = pathway ? pathway.name : 'Unknown Pathway';
            
            // Create universal join link that works for anyone
            const joinLink = generateUniversalJoinLink(pathwayId, pathwayName, inviteCode);
            const qrUrl = generateQRCodeWithFallback(joinLink, 'qrContainer');
            
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100%; height: 100%;
                background: rgba(0,0,0,0.9); z-index: 10000;
                display: flex; align-items: center; justify-content: center;
                color: white; font-family: inherit;
            `;
            
            modal.innerHTML = `
                <div style="background: rgba(0,0,0,0.9); padding: 30px; border-radius: 15px; border: 1px solid #40E0D0; text-align: center; max-width: 450px;">
                    <h3 style="color: #40E0D0; margin-bottom: 20px;">Invite to ${pathwayName}</h3>
                    
                    <!-- Invite Code Display (No QR) -->
                    <div style="
                        margin: 20px 0; text-align: center;
                        background: rgba(64,224,208,0.1); border-radius: 10px;
                        border: 1px solid rgba(64,224,208,0.3); padding: 20px;
                    ">
                        <div style="color: #40E0D0; margin-bottom: 10px; font-weight: 600;">
                            Share this link or code:
                        </div>
                        <div style="
                            background: rgba(0,0,0,0.4); padding: 12px; border-radius: 8px;
                            font-family: monospace; font-size: 11px; word-break: break-all;
                            border: 1px solid rgba(64,224,208,0.3); margin: 10px 0;
                            color: #ffffff;
                        ">
                            ${joinLink}
                        </div>
                        <div style="
                            background: rgba(0,0,0,0.4); padding: 12px; border-radius: 8px;
                            font-family: monospace; font-size: 11px; word-break: break-all;
                            border: 1px solid rgba(64,224,208,0.3); margin: 10px 0;
                            color: #cccccc;
                        ">
                            <strong>Invite Code:</strong><br>
                            ${inviteCode}
                        </div>
                    </div>
                    
                    <div style="margin: 15px 0; font-size: 13px; color: rgba(255,255,255,0.8);">
                        Anyone can scan this QR code to join - no app required!
                    </div>
                    
                    <div style="background: rgba(64,224,208,0.1); padding: 12px; border-radius: 8px; font-family: monospace; font-size: 10px; word-break: break-all; margin: 15px 0; border: 1px solid rgba(64,224,208,0.3); max-height: 80px; overflow-y: auto;">
                        ${joinLink}
                    </div>
                    
                    <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 15px;">
                        <button onclick="navigator.clipboard?.writeText('${joinLink}').then(() => { alert(' Join link copied!\n\nShare this link with anyone - they can join directly in their browser.'); });" 
                                style="background: #40E0D0; color: black; border: none; padding: 12px 20px; border-radius: 8px; cursor: pointer; font-size: 12px; font-weight: 600;">
                             Copy Link
                        </button>
                        <button onclick="navigator.clipboard?.writeText('${inviteCode}').then(() => { alert(' Invite code copied!\n\nShare this code - others can paste it in Join Pathway.'); });" 
                                style="background: rgba(64,224,208,0.2); color: #40E0D0; border: 1px solid rgba(64,224,208,0.5); padding: 12px 20px; border-radius: 8px; cursor: pointer; font-size: 12px; font-weight: 600;">
                             Copy Code
                        </button>
                        <button onclick="this.parentElement.parentElement.parentElement.remove();" 
                                style="background: #444; color: white; border: none; padding: 12px 20px; border-radius: 8px; cursor: pointer; font-size: 12px;">
                            Close
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
        }
        
        function handlePathwayKeyPress(event, pathwayId) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendPathwayMessage(pathwayId);
            }
        }
        
        function sendPathwayMessage(pathwayId) {
            const input = document.getElementById(`pathway-input-${pathwayId}`);
            const messagesContainer = document.getElementById(`pathway-messages-${pathwayId}`);
            
            if (!input || input.value.trim() === '') return;
            
            const message = input.value.trim();
            
            // Remove ready message on first real message
            removePathwayReadyMessage(pathwayId);
            
            // Add message to UI immediately
            addPathwayMessage(pathwayId, message, 'own', SynapseCore.config.nickname);
            
            // Send through pathway network
            pathwayNetwork.sendPathwayMessage(pathwayId, message);
            
            input.value = '';
        }
        
        function addPathwayMessage(pathwayId, content, type, sender, timestamp = null) {
            const messagesContainer = document.getElementById(`pathway-messages-${pathwayId}`);
            if (!messagesContainer) return;
            
            const messageElement = document.createElement('div');
            messageElement.className = `pathway-message ${type}`;
            
            messageElement.innerHTML = `
                <div class="pathway-message-header">
                    ${sender}
                </div>
                <div>${content}</div>
            `;
            
            messagesContainer.appendChild(messageElement);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        function toggleBlurShield() {
            SynapseCore.config.blurShieldEnabled = !SynapseCore.config.blurShieldEnabled;
            alert(` Blur Shield ${SynapseCore.config.blurShieldEnabled ? 'ENABLED' : 'DISABLED'}\n\n${SynapseCore.config.blurShieldEnabled ? 'Content will be blurred when window loses focus or screenshots are attempted.' : 'Privacy protection disabled.'}`);
        }
        
        function exportMemory() {
            const memoryData = {
                concepts: Array.from(fractalMemory.concepts.entries()),
                embeddings: Array.from(fractalMemory.embeddings.entries()),
                associations: Array.from(fractalMemory.associations.entries()),
                exported: new Date().toISOString(),
                nodeId: SynapseCore.config.nickname
            };
            
            const dataStr = JSON.stringify(memoryData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `synapse-memory-${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            alert(' Memory exported successfully!\nFile contains encrypted concept embeddings and associations.');
        }
        
        function importMemory() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const memoryData = JSON.parse(e.target.result);
                            
                            // Import concepts
                            memoryData.concepts.forEach(([id, concept]) => {
                                fractalMemory.concepts.set(id, concept);
                            });
                            
                            alert(` Memory imported successfully!\nImported ${memoryData.concepts.length} concepts from ${memoryData.nodeId || 'unknown node'}.`);
                            
                        } catch (error) {
                            alert(' Error importing memory file. Please check the file format.');
                            console.error('Import error:', error);
                        }
                    };
                    reader.readAsText(file);
                }
            };
            
            input.click();
        }
        
        function clearMemory() {
            if (confirm(' This will permanently clear all stored memories and learned associations.\n\nAre you sure you want to proceed?')) {
                fractalMemory.concepts.clear();
                fractalMemory.embeddings.clear();
                fractalMemory.associations.clear();
                alert(' Memory cleared successfully.\nThe AI will start learning fresh from new conversations.');
            }
        }

        // ============================================================================
        // SYSTEM UTILITIES
        // ============================================================================
        
        SynapseCore.loadMemoryFromStorage = function() {
            try {
                const stored = localStorage.getItem('synapse_memory');
                if (stored) {
                    const data = JSON.parse(stored);
                    // Load concepts into memory system
                    data.concepts?.forEach(([id, concept]) => {
                        fractalMemory?.concepts.set(id, concept);
                    });
                }
                
                // Load configuration
                const configStored = localStorage.getItem('synapse_config');
                if (configStored) {
                    const configData = JSON.parse(configStored);
                    SynapseCore.config = { ...SynapseCore.config, ...configData };
                }
            } catch (error) {
                console.warn('Could not load data from storage:', error);
            }
        };
        
        SynapseCore.saveMemoryToStorage = function() {
            try {
                const memoryData = {
                    concepts: Array.from(fractalMemory.concepts.entries()),
                    timestamp: Date.now()
                };
                localStorage.setItem('synapse_memory', JSON.stringify(memoryData));
            } catch (error) {
                console.warn('Could not save memory to storage:', error);
            }
        };
        
        SynapseCore.setupBlurShield = function() {
            let blurTimeout;
            
            // Detect when window loses focus
            window.addEventListener('blur', () => {
                if (SynapseCore.config.blurShieldEnabled) {
                    blurTimeout = setTimeout(() => {
                        document.getElementById('blurShield').style.display = 'flex';
                    }, 1000); // 1 second delay
                }
            });
            
            window.addEventListener('focus', () => {
                clearTimeout(blurTimeout);
                document.getElementById('blurShield').style.display = 'none';
            });
            
            // Detect screenshot attempts (limited browser support)
            document.addEventListener('keydown', (e) => {
                if (SynapseCore.config.blurShieldEnabled && 
                    ((e.ctrlKey && e.shiftKey && e.key === 'S') || // Chrome Dev Tools
                     (e.metaKey && e.shiftKey && ['3', '4', '5'].includes(e.key)))) { // macOS screenshots
                    document.getElementById('blurShield').style.display = 'flex';
                    setTimeout(() => {
                        document.getElementById('blurShield').style.display = 'none';
                    }, 2000);
                }
            });
        };
        
        SynapseCore.initializeOfflineAI = function() {
            // Set up periodic memory persistence
            setInterval(() => {
                SynapseCore.saveMemoryToStorage();
            }, 30000); // Save every 30 seconds
        };

        // ============================================================================
        // INITIALIZE ON PAGE LOAD
        // ============================================================================
        
        document.addEventListener('DOMContentLoaded', initializeSynapse);
        
        // Save memory before page unload
        window.addEventListener('beforeunload', () => {
            SynapseCore.saveMemoryToStorage();
        });
        
        // Make QR test available globally for debugging
        window.testQR = testQRGeneration;
        
        console.log(' Synapse Neural Network Loading...');
        console.log(' To test QR generation: testQR()');
    </script>


</body></html>