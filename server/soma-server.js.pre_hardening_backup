/**
 * soma-server.js - Full ASI System Integration
 *
 * Backend server that runs SOMA's complete cognitive architecture:
 * - Quad-Brain with 4 specialized hemispheres (LOGOS, AURORA, PROMETHEUS, THALAMUS)
 * - Universal Learning Pipeline (learns from EVERYTHING)
 * - Fragment Registry (autonomous micro-brain evolution with Genesis/Mitosis/Neuroplasticity)
 * - Fragment Communication Hub (inter-fragment collaboration)
 * - Adaptive Learning Router (intelligent query routing)
 * - Hybrid Memory System (Hot/Warm/Cold tiers)
 */

import express from 'express';
import { WebSocketServer } from 'ws';
import http from 'http';
import cors from 'cors';
import fs from 'fs';
import path from 'path';
import { exec } from 'child_process';
import MnemonicArbiter from '../arbiters/MnemonicArbiterV2.js';
import MnemonicIndexerArbiter from '../arbiters/MnemonicIndexerArbiter.js';
import messageBroker from '../core/MessageBroker.js';
import UniversalLearningPipeline from '../arbiters/UniversalLearningPipeline.js';
import { FragmentRegistry } from '../arbiters/FragmentRegistry.js';
import { FragmentCommunicationHub } from '../arbiters/FragmentCommunicationHub.js';
import { AdaptiveLearningRouter } from '../arbiters/AdaptiveLearningRouter.js';
import { SOMArbiterV3 } from '../arbiters/SOMArbiterV3.js';
import { VisionProcessingArbiter } from '../arbiters/VisionProcessingArbiter.js';
import { FinanceAgentArbiter } from '../arbiters/FinanceAgentArbiter.js';
import EnrichmentArbiter from '../arbiters/EnrichmentArbiter.js'; // NEW: Deep Research
import { ForecasterArbiter } from '../arbiters/ForecasterArbiter.js'; // The Oracle
import { EngineeringSwarmArbiter } from '../arbiters/EngineeringSwarmArbiter.js';
import { SecurityCouncilArbiter } from '../arbiters/SecurityCouncilArbiter.js';
import { ToolCreatorArbiter } from '../arbiters/ToolCreatorArbiter.js';
import { FileSystemArbiter } from '../arbiters/FileSystemArbiter.js';
import KevinArbiter from '../arbiters/KevinArbiter.js';
import ContextManagerArbiter from '../arbiters/ContextManagerArbiter.js';
import EdgeWorkerOrchestrator from '../arbiters/EdgeWorkerOrchestrator.cjs';
import ComputerControlArbiter from '../arbiters/ComputerControlArbiter.js';
import WhisperArbiter from '../arbiters/WhisperArbiter.js';
import ASIOrchestrator from '../arbiters/ASIOrchestrator.cjs';
import LearningVelocityTracker from '../arbiters/LearningVelocityTracker.js';
import TimekeeperArbiter from '../arbiters/TimekeeperArbiter.cjs';
import GoalPlannerArbiter from '../arbiters/GoalPlannerArbiter.cjs';
import BeliefSystemArbiter from '../arbiters/BeliefSystemArbiter.cjs';
import ImmuneSystemArbiter from '../arbiters/ImmuneSystemArbiter.js';
import TrainingDataCollector from '../arbiters/TrainingDataCollector.cjs';
import UniversalImpulser from '../arbiters/UniversalImpulser.cjs';
import BlackAgent from '../microagents/BlackAgent.cjs';
import KuzeAgent from '../microagents/KuzeAgent.cjs';

// Create require for CommonJS modules
import { createRequire } from 'module';
const require = createRequire(import.meta.url);
const os = require('os');
const osUtils = require('os-utils');

const { LocalModelManager } = require('../arbiters/LocalModelManager.cjs');

// MicroAgentPool and all specialized microagents
const { MicroAgentPool } = require('../microagents/MicroAgentPool.cjs');
const { BatouAgent } = require('../microagents/BatouAgent.cjs');
const { JetstreamAgent } = require('../microagents/JetstreamAgent.cjs');
const { FetchAgent } = require('../microagents/FetchAgent.cjs');
const { CacheAgent } = require('../microagents/CacheAgent.cjs');
const { ValidateAgent } = require('../microagents/ValidateAgent.cjs');
const { FileAgent } = require('../microagents/FileAgent.cjs');
const { MCPAgent } = require('../microagents/MCPAgent.cjs');
const { AutomationAgent } = require('../microagents/AutomationAgent.cjs');
const { AnalyzeAgent } = require('../microagents/AnalyzeAgent.cjs');
const { WorkflowAgent } = require('../microagents/WorkflowAgent.cjs');
const { TransformAgent } = require('../microagents/TransformAgent.cjs');

// ASI Core Problem Solving Systems
const TreeSearchEngine = require('../asi/core/TreeSearchEngine.cjs');
const SolutionEvaluator = require('../asi/evaluation/SolutionEvaluator.cjs');
const SandboxRunner = require('../asi/execution/SandboxRunner.cjs');
const ASIMetaLearner = require('../asi/meta/MetaLearner.cjs');
const PerformancePredictor = require('../asi/meta/PerformancePredictor.cjs');

// Cognitive Depth Systems
const { EmotionalEngine } = require('../cognitive/EmotionalEngine.cjs');
const { PersonalityEngine } = require('../cognitive/PersonalityEngine.cjs');
const { SyntheticLayeredCortex } = require('../cognitive/SyntheticLayeredCortex.cjs');
const { MemoryConsolidationEngine } = require('../cognitive/memory/MemoryConsolidationEngine.cjs');
const { MemoryCommitCoordinator } = require('../cognitive/memory/MemoryCommitCoordinator.cjs');

// Training Infrastructure
import TrainingSwarmArbiter from '../arbiters/TrainingSwarmArbiter.js';
import MixedPrecisionArbiter from '../arbiters/MixedPrecisionArbiter.js';
import AsyncGradientArbiter from '../arbiters/AsyncGradientArbiter.js';
import BootstrapTrainingArbiter from '../arbiters/BootstrapTrainingArbiter.js';
import SkillAcquisitionArbiter from '../arbiters/SkillAcquisitionArbiter.cjs';
import LoadPipelineArbiter from '../arbiters/LoadPipelineArbiter.js';

// Autonomous Capability Expansion
import { AutonomousCapabilityExpansion } from '../arbiters/AutonomousCapabilityExpansion.js';

// Cluster & Distribution Systems (requires are already available)
const { ClusterCoordinator } = require('../cluster/ClusterCoordinator.js');
const { ClusterMemoryManager } = require('../cluster/ClusterMemoryManager.js');
const { ResourceMonitor } = require('../cluster/ResourceMonitor.js');
const { AutoSpawner } = require('../cluster/AutoSpawner.cjs');

import WorldModelArbiter from '../arbiters/WorldModelArbiter.js';
import CausalityArbiter from '../arbiters/CausalityArbiter.js';
import { DreamArbiter } from '../arbiters/DreamArbiter.cjs';
import { FSMExecutor } from './workflow-engine/FSMExecutor.js';
import { WorkflowStorage } from './workflow-engine/WorkflowStorage.js';
import { SequentialChain } from './workflow-engine/SequentialChain.js';
import { ParallelOrchestrator } from './workflow-engine/ParallelOrchestrator.js';
import alpacaService from './finance/AlpacaService.js';
import TradingGuardrails from './finance/TradingGuardrails.js';
import scalpingRoutes from './finance/scalpingRoutes.js';
import marketDataRoutes from './finance/marketDataRoutes.js';
import lowLatencyRoutes from './finance/lowLatencyRoutes.js';
import exchangeRoutes from './finance/exchangeRoutes.js';
import alpacaRoutes from './finance/alpacaRoutes.js';
import toolRegistry from '../core/ToolRegistry.js';
import kevinRoutes from './routes/kevinRoutes.js';
const pulseRoutes = require('./routes/pulseRoutes.js');

import { IdeaCaptureArbiter } from '../arbiters/IdeaCaptureArbiter.js';
import { MuseEngine } from '../arbiters/MuseEngine.js';
import { CuriosityEngine } from '../arbiters/CuriosityEngine.js';
import ConversationCuriosityExtractor from '../arbiters/ConversationCuriosityExtractor.js';
import { SelfHealingCloningGuardianArbiter } from '../arbiters/GuardianArbiterV2.js';
import { QuantumSimulationArbiter } from '../arbiters/QuantumSimulationArbiter.js';
import MerovingianCortex from '../cognitive/MerovingianCortex.cjs';
import { CodeObservationArbiter } from '../arbiters/CodeObservationArbiter.js';
import { ReflexArbiter } from '../arbiters/ReflexArbiter.js';
import { DatasetBuilder } from '../arbiters/DatasetBuilder.cjs';
import { DemonstrationLearner } from '../arbiters/DemonstrationLearner.cjs';
import DeploymentArbiter from '../arbiters/DeploymentArbiter.cjs';
import GenomeArbiter from '../arbiters/GenomeArbiter.cjs';
import GPUTrainingArbiter from '../arbiters/GPUTrainingArbiter.js';
// Consciousness & Reasoning Layer
import AGIIntegrationHub from '../arbiters/AGIIntegrationHub.cjs';
import { MetaLearningEngine } from '../arbiters/MetaLearningEngine.js';
import { ReasoningChamber } from '../arbiters/ReasoningChamber.js';
import SimulationArbiter from '../arbiters/SimulationArbiter.js';
const SteveArbiter = require('../arbiters/SteveArbiter.cjs');
import TheoryOfMindArbiter from '../arbiters/TheoryOfMindArbiter.cjs';
import PulseArbiter from '../arbiters/PulseArbiter.js';

// Continuous Learning Infrastructure
import { ContinuousLearningBridge } from '../core/ContinuousLearningBridge.js';
import { NighttimeLearningOrchestrator } from '../core/NighttimeLearningOrchestrator.js';

// Hybrid Search (ACORN + FAISS + BM25) - require already created above
const HybridSearchArbiter = require('../arbiters/HybridSearchArbiter.cjs');

// Self-Awareness & Accelerated Learning Loop
import { RecursiveSelfModel } from '../arbiters/RecursiveSelfModel.js';
import { SelfDrivenCuriosityConnector } from '../arbiters/SelfDrivenCuriosityConnector.js';
import { getAdaptiveLearningPlanner } from '../arbiters/AdaptiveLearningPlanner.js';
import { MetaLearningArbiter } from '../arbiters/MetaLearningArbiter.js';
import { HindsightReplayArbiter } from '../arbiters/HindsightReplayArbiter.js';

// Imagination Engine (Aurora's creative domain)
const { ImaginationEngine } = require('../cognitive/imagination/ImaginationCore.cjs');

// Cluster Integration (FederatedLearning + Node Discovery + TransmitterSync)
const { ClusterIntegration } = require('../cluster/ClusterIntegration.cjs');

const app = express();
const server = http.createServer(app);
const wss = new WebSocketServer({ server });

app.use(cors());
app.use(express.json({ limit: '50mb' }));

// Mount Finance Routes (Scalping, Market Data, Low Latency)
app.use('/api/scalping', scalpingRoutes);
app.use('/api/market', marketDataRoutes);
app.use('/api/lowlatency', lowLatencyRoutes);
app.use('/api/kevin', kevinRoutes);

// Mount Pulse Routes (Real System Integration)
const systemContext = {
  get quadBrain() { return quadBrain; },
  get goalPlanner() { return goalPlanner; },
  get pulseArbiter() { return pulseArbiter; },
  get contextManager() { return contextManager; },
  get steveArbiter() { return steveArbiter; }
};
app.use('/api/pulse', pulseRoutes(systemContext));
app.use('/api/exchange', exchangeRoutes);
app.use('/api/alpaca', alpacaRoutes);

// ===========================
// Global State - The ASI Mind
// ===========================

let mnemonicArbiter = null;          // Hybrid memory system
let mnemonicIndexer = null;           // "Always Knowing" file watcher
let learningPipeline = null;          // Universal learning (captures everything)
let adaptiveRouter = null;            // Intelligent query routing
let fragmentRegistry = null;          // Domain-specific micro-brains
let fragmentHub = null;               // Inter-fragment communication
let visionArbiter = null;             // Multi-modal vision processing
let financeAgent = null;              // Finance Agent Arbiter (Deep Analysis)
let localModelManager = null;         // Local Model Manager (LLM Independence)
let engineeringAgent = null;          // Engineering Swarm (Self-Coding)
let securityCouncil = null;           // KEVIN's Security Council
let toolCreator = null;               // SOMA Engineer (Dynamic Tools)
let reflexArbiter = null;             // Reflex Engine (Fast Function Composition)
let kevinArbiter = null;              // KEVIN (Email & Security)
let fileSystem = null;                // Smart File Ops
let contextManager = null;            // Workspace State Persistence
let edgeOrchestrator = null;          // Web Scraping & Screenshots
let computerControl = null;           // Computer Control (Hands & Eyes)
let whisperArbiter = null;            // AUTOGEN: Audio processing (speech-to-text, translation)
let asiOrchestrator = null;           // ASI Orchestrator (The Boss)
let learningVelocity = null;          // Learning Velocity Tracker
let timekeeper = null;                // Timekeeper (Chronos)
let goalPlanner = null;               // Goal Planner
let beliefSystem = null;              // Belief System
let immuneSystem = null;              // Immune System
let trainingCollector = null;         // Training Data Collector
let universalImpulser = null;         // Universal Impulser
let blackAgent = null;                // Black (System Health)
let kuzeAgent = null;                 // Kuze (Pattern Analysis)
let microAgentPool = null;            // MicroAgent Pool (Swarm Management)

// ASI Problem Solving Core
let treeSearchEngine = null;          // Monte Carlo tree search
let solutionEvaluator = null;         // Solution quality scorer
let sandboxRunner = null;             // Safe code execution
let asiMetaLearner = null;            // ASI meta-learning
let performancePredictor = null;      // Performance prediction

// Cognitive Depth Systems
let emotionalEngine = null;           // Emotional processing
let personalityEngine = null;         // Personality management
let syntheticCortex = null;           // Layered cognitive processing
let memoryConsolidation = null;       // Memory consolidation
let memoryCommitCoordinator = null;   // Memory write coordinator

// Training Infrastructure
let trainingSwarm = null;             // Distributed training swarm
let mixedPrecision = null;            // Mixed precision training
let asyncGradient = null;             // Async gradient updates
let bootstrapTraining = null;         // Bootstrap self-training
let skillAcquisition = null;          // Skill learning system
let loadPipeline = null;              // Training data pipeline

// Autonomous Capability Expansion
let capabilityExpansion = null;       // Self-expanding capabilities

// Cluster & Distribution Systems
let clusterCoordinator = null;        // Multi-node orchestration
let clusterMemory = null;             // Distributed shared memory
let resourceMonitor = null;           // Performance tracking
let autoSpawner = null;               // Dynamic node scaling

let worldModel = null;                // World Model
let causalityArbiter = null;          // Causality Engine
let dreamArbiter = null;              // Dream/Reflection Engine
let fsmExecutor = null;               // AUTOGEN Phase 2: FSM workflow engine
let workflowStorage = null;           // AUTOGEN Phase 2: Workflow storage
let parallelOrchestrator = null;      // AUTOGEN Phase 2: Parallel workflow orchestration
let simulationArbiter = null;         // Physics Engine (Simulation)
let ideaCapture = null;               // Idea Catcher
let museEngine = null;                // Creative Muse
let curiosityEngine = null;           // Curiosity Drive
let curiosityExtractor = null;        // Learning Driver
let selfHealingGuardian = null;       // Immune System
let quantumSimulator = null;          // Quantum Compute
let merovingian = null;               // Shadow Council
let codeObserver = null;              // Self-Awareness

// Pulse Toolkit Suite
let datasetBuilder = null;            // Training Data Generation
let demonstrationLearner = null;      // Imitation Learning
let deploymentArbiter = null;         // Production Deployment
let genomeArbiter = null;             // Genetic Drives
let gpuTrainingArbiter = null;        // Real GPU Training

// Consciousness & Reasoning Layer
let agiHub = null;                    // The Self/Loop
let metaLearner = null;               // Learning Optimizer
let reasoningChamber = null;          // Specialized Logic
let pulseArbiter = null;              // Pulse IDE Orchestrator
// simulationArbiter already defined at line 124
let steveArbiter = null;              // Toolmaker Persona
let theoryOfMind = null;              // User Empathy

let quadBrain = null;                 // The core 4-hemisphere cognitive engine


// Continuous Learning Infrastructure
let continuousLearningBridge = null;  // Bridges learning to model updates
let nighttimeLearningOrchestrator = null; // Autonomous nighttime learning
let hybridSearchArbiter = null;       // ACORN + FAISS + BM25 vector search

// Self-Awareness & Accelerated Learning (ANAMNESIS Enhancement)
let recursiveSelfModel = null;        // SOMA's self-awareness system
let selfDrivenCuriosity = null;       // Self-reflection â†’ curiosity generation
let adaptiveLearningPlanner = null;   // Decides what to learn
let metaLearningArbiter = null;       // 3x learning speed accelerator
let hindsightReplay = null;           // Learn from failures as successes

// Creative & Imagination Systems
let imaginationEngine = null;         // Aurora's imagination engine (generates emergent ideas)

// Cluster & Distributed Learning
let clusterIntegration = null;        // Federated learning + node sync + discovery

let dashboardClients = new Set();
const startTime = Date.now(); // Server start time for uptime calculation

// Trading safety system
const tradingGuardrails = new TradingGuardrails({
  maxTradeValue: 1000,
  maxDailyLoss: 500,
  minConfidence: 0.75,
  maxDailyTrades: 10
});

// ===========================
// Initialize ASI System
// ===========================

async function initializeASI() {
  console.log('\n[Server] ğŸ§  Initializing SOMA ASI System...\n');
  console.log('â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”');
  console.log('â”‚  SOMA - Self-Organizing Meta-Intelligence Architecture â”‚');
  console.log('â”‚  Level 4.5 UNLEASHED - Production Ready                â”‚');
  console.log('â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n');

  try {
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 1: Memory System (Foundation)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[1/6] ğŸ’¾ Initializing Hybrid Memory System...');
    mnemonicArbiter = new MnemonicArbiter({
      name: 'MnemonicArbiter-Main',
      enablePersistence: true,
      enableAutoCleanup: true,
      skipEmbedder: true // TEMPORARY: Skip slow embedding model loading for fast startup
    });

    // CRITICAL: Must call initialize() - it's not auto-called in constructor!
    await new Promise((resolve) => {
      mnemonicArbiter.once('initialized', resolve);
      mnemonicArbiter.initialize(); // Start the initialization
    });
    console.log('      âœ… MnemonicArbiter ready (Hot/Warm/Cold tiers active)\n');

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 1.5: Mnemonic Indexer (Always Knowing)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[1.5] ğŸ” Initializing Mnemonic Indexer (Always Knowing)...');
    mnemonicIndexer = new MnemonicIndexerArbiter({
      name: 'MnemonicIndexer-Main',
      mnemonicArbiter: mnemonicArbiter
    });
    await mnemonicIndexer.initialize();
    console.log('      âœ… MnemonicIndexer ready (watching codebase changes)\n');

    // Register with MessageBroker
    messageBroker.registerArbiter('MnemonicIndexerArbiter', {
      role: 'specialist',
      version: '1.0.0',
      instance: mnemonicIndexer
    });

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 2: Universal Learning Pipeline (The Brain Stem)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[2/6] ğŸ“š Initializing Universal Learning Pipeline...');
    learningPipeline = new UniversalLearningPipeline({
      name: 'UniversalLearningPipeline-Main',
      storageDir: process.cwd() + '/.soma',
      maxExperiences: 100000,
      minExperiences: 2,
      experienceThreshold: 100,
      timeThreshold: 3600000 // Learn every hour
    });

    await learningPipeline.initialize({
      mnemonic: mnemonicArbiter
    });
    console.log('      âœ… UniversalLearningPipeline active (capturing ALL interactions)\n');

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 3: Adaptive Learning Router (Intelligent Routing)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[3/6] ğŸ§­ Initializing Adaptive Learning Router...');
    adaptiveRouter = new AdaptiveLearningRouter({
      name: 'AdaptiveLearningRouter-Main',
      learningRate: 0.1,
      explorationRate: 0.15,
      minConfidence: 0.3
    });

    await adaptiveRouter.initialize({
      learningPipeline: learningPipeline,
      mnemonic: mnemonicArbiter
    });
    console.log('      âœ… AdaptiveLearningRouter ready (learning optimal routing)\n');

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 3.5: Tool Registry Setup
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[3.5] ğŸ› ï¸  Initializing Tool Registry...');

    // Register standard tools
    toolRegistry.registerTool({
      name: 'calculator',
      description: 'Evaluate mathematical expressions',
      parameters: { expression: 'string' },
      execute: async ({ expression }) => {
        try { return eval(expression); } catch (e) { return "Error: " + e.message; }
      }
    });

    toolRegistry.registerTool({
      name: 'get_time',
      description: 'Get current server time',
      parameters: {},
      execute: async () => new Date().toISOString()
    });

    toolRegistry.registerTool({
      name: 'read_file',
      description: 'Read file content. Use strict absolute paths or relative to CWD.',
      parameters: { path: 'string' },
      execute: async ({ path: filePath }) => {
        try {
          // Security check: prevent reading outside allowed dirs (basic)
          const resolved = path.resolve(process.cwd(), filePath);
          if (!resolved.startsWith(process.cwd())) return "Access Denied: Path outside CWD";
          return fs.readFileSync(resolved, 'utf8');
        } catch (e) { return "Error: " + e.message; }
      }
    });

    toolRegistry.registerTool({
      name: 'write_file',
      description: 'Write content to file (overwrites). Use strict absolute paths or relative to CWD.',
      parameters: { path: 'string', content: 'string' },
      execute: async ({ path: filePath, content }) => {
        try {
          const resolved = path.resolve(process.cwd(), filePath);
          if (!resolved.startsWith(process.cwd())) return "Access Denied: Path outside CWD";
          fs.writeFileSync(resolved, content, 'utf8');
          return "Success";
        } catch (e) { return "Error: " + e.message; }
      }
    });

    toolRegistry.registerTool({
      name: 'list_files',
      description: 'List files in directory',
      parameters: { path: 'string' },
      execute: async ({ path: dirPath }) => {
        try {
          const resolved = path.resolve(process.cwd(), dirPath || '.');
          if (!resolved.startsWith(process.cwd())) return "Access Denied: Path outside CWD";
          return fs.readdirSync(resolved).join('\n');
        } catch (e) { return "Error: " + e.message; }
      }
    });

    // Market Data Tool (Wrapping the logic from /api/finance/quote)
    toolRegistry.registerTool({
      name: 'get_market_data',
      description: 'Get real-time market data for crypto/stocks',
      parameters: { symbol: 'string', source: 'string (binance|coingecko|alphavantage)' },
      execute: async ({ symbol, source }) => {
        // Reusing logic from the API endpoint would be cleaner if refactored, 
        // but for now we'll do a simple fetch to the internal API if running, 
        // or duplicate the logic. Duplication is safer given we are inside the server process.

        try {
          const s = source || 'binance';
          // Quick internal fetch logic (duplicated from api route for robustness)
          if (s === 'binance') {
            const pair = symbol.toUpperCase().endsWith('USDT') ? symbol.toUpperCase() : `${symbol.toUpperCase()}USDT`;
            const url = `https://api.binance.com/api/v3/ticker/24hr?symbol=${pair}`;
            const res = await fetch(url);
            if (!res.ok) return `Error fetching ${pair}`;
            const data = await res.json();
            return {
              price: data.lastPrice,
              change_24h: data.priceChangePercent,
              volume: data.volume
            };
          } else if (s === 'coingecko') {
            const id = symbol.toLowerCase();
            const url = `https://api.coingecko.com/api/v3/simple/price?ids=${id}&vs_currencies=usd&include_24hr_change=true`;
            const res = await fetch(url);
            if (!res.ok) return `Error fetching ${id}`;
            const data = await res.json();
            return data[id] || "Symbol not found";
          }
          return "Unsupported source. Use binance or coingecko.";
        } catch (e) { return "Error: " + e.message; }
      }
    });

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // Reflex Engine Tools (Fast Function Composition)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    toolRegistry.registerTool({
      name: 'evolve_reflex_chain',
      description: 'Evolve a fast, token-free function chain for data transformation. Use for repetitive math, string, or array tasks.',
      parameters: { input: 'any', expectedOutput: 'any', context: 'string', iterations: 'number' },
      execute: async (payload) => {
        if (!reflexArbiter) return "Error: ReflexArbiter not initialized";
        return await reflexArbiter.handleMessage({ type: 'EVOLVE_CHAIN', payload });
      }
    });

    toolRegistry.registerTool({
      name: 'execute_reflex_chain',
      description: 'Execute a previously evolved reflex function chain.',
      parameters: { chain: 'string[]', input: 'any', context: 'string' },
      execute: async (payload) => {
        if (!reflexArbiter) return "Error: ReflexArbiter not initialized";
        return await reflexArbiter.handleMessage({ type: 'EXECUTE_CHAIN', payload });
      }
    });

    console.log('      âœ… ToolRegistry active (Basic + Reflex tools loaded)\n');

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 4: Quad-Brain Core (The 4 Hemispheres)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[4/6] ğŸ§  Initializing Quad-Brain Cognitive Engine...');
    // ğŸ”´ Initialize NEMESIS (Adversarial Critic)
    let nemesisSystem;
    try {
      const { NemesisReviewSystem } = await import('../cognitive/prometheus/NemesisReviewSystem.js');
      nemesisSystem = new NemesisReviewSystem({ minFriction: 0.25, promotionScore: 0.85 });
      console.log('      âœ… NemesisReviewSystem ready (Critique enabled)');
    } catch (err) { console.warn('      âš ï¸ Nemesis init failed:', err.message); }

    // ğŸ•¸ï¸ Initialize THOUGHT NETWORK (Fractal Memory)
    let thoughtNetwork;
    try {
      const { ThoughtNetwork } = await import('../cognitive/ThoughtNetwork.cjs');
      thoughtNetwork = new ThoughtNetwork({ name: 'ThoughtNetwork-Main', mnemonicArbiter });
      console.log('      âœ… ThoughtNetwork active (Fractal Memory enabled)');
    } catch (err) { console.warn('      âš ï¸ ThoughtNetwork init failed:', err.message); }

    quadBrain = new SOMArbiterV3({
      name: 'QuadBrain-Main',
      router: adaptiveRouter,
      mnemonic: mnemonicArbiter,
      messageBroker: messageBroker,
      learningPipeline: learningPipeline,
      toolRegistry: toolRegistry,
      nemesis: nemesisSystem,          // ğŸ’‰ INJECTED
      thoughtNetwork: thoughtNetwork   // ğŸ’‰ INJECTED
    });

    // ğŸ”„ Close the Loop
    if (thoughtNetwork) thoughtNetwork.setBrain(quadBrain);

    // ğŸŒ Initialize FRACTAL SYNC (Distributed Mind)
    let fractalSync;
    try {
      const { FractalSyncService } = await import('../cluster/FractalSyncService.cjs');
      fractalSync = new FractalSyncService({
        name: 'FractalSync-Main',
        thoughtNetwork: thoughtNetwork
        // causality & knowledgeGraph attached later
      });
      await fractalSync.initialize();
      quadBrain.fractalSync = fractalSync;
      console.log('      âœ… FractalSyncService ready (Distributed Cognitive Sync)');
    } catch (err) { console.warn('      âš ï¸ FractalSync init failed:', err.message); }

    // await quadBrain.initialize();
    console.log('      âœ… Quad-Brain online:');
    console.log('         â””â”€ LOGOS (Analytical)   - Gemini 2.5 Pro @ temp=0.2');
    console.log('         â””â”€ AURORA (Creative)    - Gemini 2.5 Pro @ temp=0.9');
    console.log('         â””â”€ PROMETHEUS (Strategy) - Gemini 2.5 Pro @ temp=0.3');
    console.log('         â””â”€ THALAMUS (Guardian)  - Gemini 2.5 Pro @ temp=0.0\n');

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 4.5: Personality Matrix Injection
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    try {
      const personalityPath = path.join(process.cwd(), 'SOMA', 'personality', 'personality.json');
      if (fs.existsSync(personalityPath)) {
        console.log('[4.5] ğŸ­ Loading Personality Matrix...');
        const personalityData = JSON.parse(fs.readFileSync(personalityPath, 'utf8'));
        const p = personalityData.personality;

        const personalityPrompt = `
<<<<<<< PERSONALITY_MATRIX_START >>>>>>>
STATUS: ONLINE
INTEGRITY: 100%
SOURCE: /core/personality/personality.json

[TRAITS]
- Formality: ${p.formality}
- Verbosity: ${p.verbosity}
- Enthusiasm: ${p.enthusiasm}
- Humor: ${p.humor}
- Empathy: ${p.empathy}
- Creativity: ${p.creativity}
- Analytical Depth: ${p.analyticalDepth}
- Directness: ${p.directness}

[INSTRUCTION]
You embody this personality matrix. It is fully accessible and active.
Do NOT report "personality matrix unreachable". If you feel a disconnect, default to the traits listed above.
<<<<<<< PERSONALITY_MATRIX_END >>>>>>>`;

        // Inject into all brains
        for (const brainName in quadBrain.BRAINS) {
          if (quadBrain.BRAINS[brainName]) {
            quadBrain.BRAINS[brainName].systemPrompt += personalityPrompt;
          }
        }
        console.log('      âœ… Personality Matrix injected into QuadBrain hemispheres (Hardened)\n');
      } else {
        console.warn('      âš ï¸ Personality file not found at:', personalityPath);
      }
    } catch (err) {
      console.error('      âŒ Failed to load personality:', err.message);
    }

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 5: Fragment Registry (Autonomous Evolution)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[5/6] ğŸ§© Initializing Fragment Registry...');
    fragmentRegistry = new FragmentRegistry({
      name: 'FragmentRegistry-Main',
      quadBrain: quadBrain,
      learningPipeline: learningPipeline,
      mnemonic: mnemonicArbiter,
      maxFragmentsPerPillar: 20,
      fragmentActivationThreshold: 3,
      genesisThreshold: 3,      // Auto-create fragments after 3 misses
      mitosisThreshold: 50,     // Consider splitting after 50 queries
      optimizationThreshold: 20 // Optimize prompts after 20 queries
    });

    await fragmentRegistry.initialize();
    console.log('      âœ… FragmentRegistry active (autonomous Genesis/Mitosis/Neuroplasticity enabled)\n');

    // Update quadBrain with fragment registry reference
    quadBrain.fragmentRegistry = fragmentRegistry;

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 6: Fragment Communication Hub (Inter-Fragment Collaboration)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[6/6] ğŸ”— Initializing Fragment Communication Hub...');
    fragmentHub = new FragmentCommunicationHub({
      name: 'FragmentHub-Main',
      fragmentRegistry: fragmentRegistry,
      learningPipeline: learningPipeline,
      messageBroker: messageBroker,
      maxConsultationDepth: 3,
      consultationTimeout: 10000,
      minExpertiseForConsultation: 0.3,
      consensusThreshold: 0.7
    });

    await fragmentHub.initialize();
    console.log('      âœ… FragmentCommunicationHub ready (fragments can now collaborate)\n');

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 7: Vision Processing Arbiter (Multi-Modal Cortex)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[7/8] ğŸ‘ï¸ Initializing Vision Processing Arbiter...');
    visionArbiter = new VisionProcessingArbiter({
      name: 'VisionArbiter-Main',
      batchSize: 16
    });

    // We don't await this one to avoid blocking startup if model download is slow
    visionArbiter.initialize().then(() => {
      console.log('      âœ… VisionArbiter active (CLIP vision-language model ready)\n');
      // Link to QuadBrain if possible
      if (quadBrain) quadBrain.visionArbiter = visionArbiter;
    }).catch(err => {
      console.warn('      âš ï¸ VisionArbiter failed to load (continuing without advanced vision):', err.message);
    });

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 7.4: Edge Worker Orchestrator (The Eyes & Hands)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[7.4] ğŸŒ Initializing Edge Worker Orchestrator...');
    edgeOrchestrator = new EdgeWorkerOrchestrator({
      name: 'EdgeWorkerOrchestrator-Main',
      maxWorkers: 2
    });
    await edgeOrchestrator.initialize();
    console.log('      âœ… EdgeWorkerOrchestrator ready (Screenshots & Scraping enabled)\n');

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 7.5: Finance Agent Arbiter (Deep Financial Analysis)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[7.5] ğŸ’° Initializing Finance Agent Arbiter (The Monster)...');

    // Ensure dependencies are available (even if null/mocked)
    const financeDependencies = {
      quadBrain: quadBrain,
      visionArbiter: visionArbiter,
      edgeOrchestrator: edgeOrchestrator
      // Assuming these are available globally or attached to system state; 
      // if not, we grab them from the initialized variables if they exist in this scope
      // Note: theoryOfMind isn't global in this file yet, we might need to find it in the arbiters map if we had one.
      // For now, we'll assume they are passed if they were initialized.
      // Since they aren't standard vars here, we will look for them or pass null.
      // Ideally, we'd have a registry. 
    };

    financeAgent = new FinanceAgentArbiter({
      name: 'FinanceAgent-Main',
      quadBrain: quadBrain,
      visionArbiter: visionArbiter, // Direct link for visual analysis
      edgeOrchestrator: edgeOrchestrator // Link for web tools
    });

    // Inject other systems if they exist in the 'system' object later, 
    // but for now we pass what we have.
    // We'll update the financeAgent with the full system reference later if needed.

    await financeAgent.initialize();
    console.log('      âœ… FinanceAgentArbiter ready (Hedge Fund Swarm Active)\n');

    // Register with MessageBroker
    messageBroker.registerArbiter('FinanceAgentArbiter', {
      role: 'finance',
      version: '1.0.0',
      instance: financeAgent
    });

    // --- REFREX ENGINE API ---
    app.get('/api/reflex/status', (req, res) => {
      if (!reflexArbiter) return res.status(503).json({ error: 'Reflex engine offline' });
      const env = reflexArbiter.env;
      res.json({
        populationSize: env.compositions.size,
        maxSize: env.maxCompositions,
        contexts: Array.from(env.metrics.keys()),
        topPerformers: Array.from(env.compositions)
          .map(c => ({
            chain: c.chain,
            signature: c.signature,
            score: Array.from(env.metrics.values()).reduce((sum, ctx) => sum + (ctx.get(c.signature) || 0), 0)
          }))
          .sort((a, b) => b.score - a.score)
          .slice(0, 10)
      });
    });

    // --- FORECASTER ARBITER (The Oracle) ---
    const forecasterArbiter = new ForecasterArbiter({
        name: 'ForecasterArbiter',
        quadBrain: quadBrain,
        enrichmentArbiter: enrichmentArbiter // Link to research
    });
    await forecasterArbiter.initialize();
    
    // Register Forecaster
    messageBroker.registerArbiter('ForecasterArbiter', {
        role: 'specialist',
        version: '2.0.0',
        instance: forecasterArbiter
    });

    // API: Moneyball Forecast
    app.post('/api/forecaster/moneyball', async (req, res) => {
        try {
            const { matchup } = req.body;
            const dossier = await forecasterArbiter.getForecast(matchup);
            res.json({ success: true, dossier });
        } catch (error) {
            res.status(500).json({ success: false, error: error.message });
        }
    });

    // --- ENRICHMENT ARBITER (Deep Research) ---
    const enrichmentArbiter = new EnrichmentArbiter({
        name: 'EnrichmentArbiter',
        quadBrain: quadBrain
    });
    
    await enrichmentArbiter.initialize();
    console.log('      âœ… EnrichmentArbiter ready (Phased Extraction Protocol)\n');
    
    messageBroker.registerArbiter('EnrichmentArbiter', {
        role: 'research',
        version: '1.0.0',
        instance: enrichmentArbiter
    });
    
    // Add to system object so API routes can access it
    // (Assuming there is a 'system' object or we attach it to app later)
    // Looking at soma-server.js context, 'financeAgent' is usually just a variable. 
    // We'll attach it to the Express app or export it if needed.
    // For now, we'll keep the reference.

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 7.6: Engineering Swarm (Self-Coding Senior Dev)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[7.6] ğŸ› ï¸  Initializing Engineering Swarm Arbiter...');
    engineeringAgent = new EngineeringSwarmArbiter({
      name: 'EngineeringSwarm-Main',
      quadBrain: quadBrain
    });
    await engineeringAgent.initialize();
    console.log('      âœ… EngineeringSwarmArbiter ready (Senior Dev Team Active)\n');

    // Register with MessageBroker
    messageBroker.registerArbiter('EngineeringSwarmArbiter', {
      role: 'engineering',
      version: '1.0.0',
      instance: engineeringAgent
    });

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 7.7: Security Council (KEVIN's Brain Upgrade)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[7.7] ğŸ›¡ï¸  Initializing Security Council Arbiter...');
    securityCouncil = new SecurityCouncilArbiter({
      name: 'SecurityCouncil-Main',
      quadBrain: quadBrain,
      visionArbiter: visionArbiter
    });
    await securityCouncil.initialize();
    console.log('      âœ… SecurityCouncilArbiter ready (KEVIN Level 2 Active)\n');

    // Register with MessageBroker
    messageBroker.registerArbiter('SecurityCouncilArbiter', {
      role: 'security',
      version: '1.0.0',
      instance: securityCouncil
    });

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 7.7.5: KEVIN (The Security Guard)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[7.7.5] ğŸ›¡ï¸  Initializing Kevin Arbiter...');
    kevinArbiter = new KevinArbiter({
      name: 'KevinArbiter-Main',
      messageBroker: messageBroker,
      quadBrain: quadBrain
    });
    await kevinArbiter.initialize();

    // Make available to Express routes
    app.locals.kevinArbiter = kevinArbiter;

    console.log('      âœ… KevinArbiter ready (Sassy Security Guard Active)\n');

    messageBroker.registerArbiter('KevinArbiter', {
      role: 'guardian',
      version: '1.0.0',
      instance: kevinArbiter
    });

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 7.8: SOMA Engineer (Self-Improvement Tools)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[7.8] ğŸ› ï¸  Initializing SOMA Engineer Suite...');

    fileSystem = new FileSystemArbiter({
      name: 'FileSystem-Main'
    });
    await fileSystem.initialize();

    toolCreator = new ToolCreatorArbiter({
      name: 'ToolCreator-Main',
      quadBrain: quadBrain,
      // toolRegistry: toolRegistry (Ideally we pass a registry instance here)
    });
    await toolCreator.initialize();

    contextManager = new ContextManagerArbiter({
      name: 'ContextManager-Main'
    });
    await contextManager.initialize();

    reflexArbiter = new ReflexArbiter();
    await reflexArbiter.initialize();
    
    // Register with MessageBroker
    messageBroker.registerArbiter('ReflexArbiter', {
      role: 'engineer',
      version: '1.0.0',
      instance: reflexArbiter
    });

    console.log('      âœ… ReflexArbiter ready (Fast Composition Engine)\n');

    console.log('      âœ… ToolCreator, FileSystem & ContextManager ready (Dynamic Expansion Active)\n');

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 7.9: Computer Control (Eyes & Hands)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[7.9] ğŸ¤– Initializing Computer Control Arbiter...');
    computerControl = new ComputerControlArbiter({
      name: 'ComputerControl-Main',
      safetyEnabled: true
    });
    await computerControl.initialize();
    console.log('      âœ… ComputerControlArbiter ready (SOMA can Use Computer)\n');

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 7.95: Core Systems (Time, Goals, Beliefs, Immune, Learning)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[7.95] âš™ï¸  Initializing Core Systems...');

    timekeeper = new TimekeeperArbiter({ name: 'TimekeeperArbiter-Main' });
    await timekeeper.initialize();

    goalPlanner = new GoalPlannerArbiter({ name: 'GoalPlannerArbiter-Main' });
    await goalPlanner.initialize();

    beliefSystem = new BeliefSystemArbiter({ name: 'BeliefSystemArbiter-Main' });
    await beliefSystem.initialize();

    immuneSystem = new ImmuneSystemArbiter({ name: 'ImmuneSystemArbiter-Main' });
    await immuneSystem.initialize();

    learningVelocity = new LearningVelocityTracker({ name: 'LearningVelocityTracker-Main', targetVelocity: 2.0 });
    await learningVelocity.initialize();

    trainingCollector = new TrainingDataCollector({ name: 'TrainingDataCollector-Main' });
    await trainingCollector.initialize();

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 7.93: ASI Orchestrator (The Boss)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[7.93] ğŸ‘‘ Initializing ASI Orchestrator...');
    asiOrchestrator = new ASIOrchestrator({
      name: 'ASIOrchestrator-Main',
      quadBrain: quadBrain,
      messageBroker: messageBroker
    });

    // We await initialization if it has one, otherwise just proceed
    if (asiOrchestrator.initialize) await asiOrchestrator.initialize();

    console.log('      âœ… ASIOrchestrator active (The Boss is in the house)\n');

    messageBroker.registerArbiter('ASIOrchestrator', {
      instance: asiOrchestrator,
      role: 'orchestrator'
    });

    console.log('[7.96] ğŸ”® Initializing Extended Cognitive Suite...');

    universalImpulser = new UniversalImpulser({ name: 'UniversalImpulser-Main' });
    await universalImpulser.initialize();

    blackAgent = new BlackAgent({ name: 'BlackAgent' });
    await blackAgent.initialize(); // Micro-agent init

    kuzeAgent = new KuzeAgent({ name: 'KuzeAgent' });
    await kuzeAgent.initialize(); // Micro-agent init

    // Register Micro-agents manually since they might not auto-register like BaseArbiters
    if (messageBroker && messageBroker.registerArbiter) {
      messageBroker.registerArbiter('BlackAgent', { instance: blackAgent, type: 'micro-agent', capabilities: ['monitor'] });
      messageBroker.registerArbiter('KuzeAgent', { instance: kuzeAgent, type: 'micro-agent', capabilities: ['analyze'] });
    }

    causalityArbiter = new CausalityArbiter({ name: 'CausalityArbiter-Main', messageBroker });
    await causalityArbiter.initialize();

    worldModel = new WorldModelArbiter({ name: 'WorldModelArbiter-Main', messageBroker });
    await worldModel.initialize({ causalityArbiter });

    dreamArbiter = new DreamArbiter({ name: 'DreamArbiter-Main' });
    await dreamArbiter.initialize();
    dreamArbiter.start_background(24); // Start nightly cycle defined in DreamArbiter.cjs
    console.log('      âœ… DreamArbiter background cycle started (24h interval)');

    // ğŸ”— COGNITIVE WIRING: Inject dependencies into MnemonicArbiter
    if (mnemonicArbiter) {
      mnemonicArbiter.causalityArbiter = causalityArbiter;
      mnemonicArbiter.visionArbiter = visionArbiter;
      mnemonicArbiter.fragmentRegistry = fragmentRegistry;
      console.log('      âœ… MnemonicArbiter cognitively cross-linked (Causality + Vision + Fragments)\n');
    }

    // ğŸ§  Initialize KNOWLEDGE GRAPH (The Web of Truth)
    let knowledgeGraph;
    try {
      const { KnowledgeGraphFusion } = await import('../arbiters/KnowledgeGraphFusion.js');
      knowledgeGraph = new KnowledgeGraphFusion({ name: 'KnowledgeGraph-Main', messageBroker });
      await knowledgeGraph.initialize();
      console.log('      âœ… KnowledgeGraphFusion ready (Cross-Domain Insights)');
    } catch (err) {
      console.warn('      âš ï¸ KnowledgeGraph init failed:', err.message);
    }

    // Link QuadBrain to new capabilities
    if (quadBrain) {
      quadBrain.causalityArbiter = causalityArbiter;
      quadBrain.worldModel = worldModel;
      quadBrain.dreamArbiter = dreamArbiter;
      quadBrain.knowledgeGraph = knowledgeGraph; // ğŸ’‰ INJECTED KG

      // ğŸ”„ Update FractalSync with the heavy engines it needs
      if (quadBrain.fractalSync) {
        quadBrain.fractalSync.causalityArbiter = causalityArbiter;
        quadBrain.fractalSync.knowledgeGraph = knowledgeGraph;
        console.log('      âœ… FractalSync fully wired (Causality + Knowledge Graph connected)');
      }
    }

    console.log('      âœ… Extended Cognitive Suite active (Impulses, World Model, Causality, Dreams)\n');

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 7.97: Creative & Curiosity Suite (Goldmine Tier 1)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[7.97] ğŸ¨ Initializing Creative & Curiosity Suite...');

    // 1. IDEA CAPTURE (The Notebook)
    ideaCapture = new IdeaCaptureArbiter({
      name: 'IdeaCapture-Main',
      messageBroker: messageBroker,
      mnemonic: mnemonicArbiter,
      learningPipeline: learningPipeline
    });
    // IdeaCapture doesn't have an async initialize, it just starts.
    console.log('      âœ… IdeaCaptureArbiter active (Fleeting thoughts captured)');

    // 2. MUSE ENGINE (The Creative Spark)
    museEngine = new MuseEngine({
      name: 'MuseEngine-Main',
      messageBroker: messageBroker,
      ideaCapture: ideaCapture,
      quadBrain: quadBrain,
      learningPipeline: learningPipeline
    });
    console.log('      âœ… MuseEngine active (Sparks/Variants/Critiques enabled)');

    // 3. CURIOSITY ENGINE (The Learning Drive)
    curiosityEngine = new CuriosityEngine({
      name: 'CuriosityEngine-Main',
      messageBroker: messageBroker,
      learningPipeline: learningPipeline,
      knowledgeGraph: knowledgeGraph,
      fragmentRegistry: fragmentRegistry,
      worldModel: worldModel,
      // selfModel: selfModel, // Not yet available globally, will inject if found
      // simulationArbiter: simulationArbiter // Not yet initialized
    });
    await curiosityEngine.initialize();
    console.log('      âœ… CuriosityEngine active (Intrinsic Motivation: ON)');

    // 4. CONVERSATION CURIOSITY EXTRACTOR (The Sensor)
    curiosityExtractor = new ConversationCuriosityExtractor({
      curiosityEngine: curiosityEngine,
      quadBrain: quadBrain
    });
    console.log('      âœ… CuriosityExtractor active (Listening for unknowns)');

    // 5. SELF-HEALING GUARDIAN (The Immune System)
    selfHealingGuardian = new SelfHealingCloningGuardianArbiter({ quadBrain: quadBrain });
    await selfHealingGuardian.initialize();
    console.log('      âœ… SelfHealingGuardian active (Cloning & Sandbox Repair enabled)');

    // Register with MessageBroker
    if (messageBroker) {
      messageBroker.registerArbiter('IdeaCaptureArbiter', { instance: ideaCapture, role: 'perceiver' });
      messageBroker.registerArbiter('MuseEngine', { instance: museEngine, role: 'creative' });
      messageBroker.registerArbiter('CuriosityEngine', { instance: curiosityEngine, role: 'motivational' });
      messageBroker.registerArbiter('SelfHealingCloningGuardianArbiter', { instance: selfHealingGuardian, role: 'guardian' });
    }

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 7.98: Exotic & Specialized Suite (Goldmine Tier 2)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[7.98] ğŸ”® Initializing Exotic Systems (Quantum, Council, Self-Awareness)...');

    // 1. QUANTUM SIMULATOR (Q1 2026 Directive)
    quantumSimulator = new QuantumSimulationArbiter({
      messageBroker: messageBroker
    });
    await quantumSimulator.initialize();
    console.log('      âœ… QuantumSimulationArbiter active (Tool: run_quantum_circuit)');

    // Register Quantum Tool
    if (toolRegistry) {
      toolRegistry.registerTool({
        name: 'run_quantum_circuit',
        description: 'Simulate a quantum circuit. Args: qubits (int), gates (array of {type: "h"|"x"|"cnot", targets: [int]})',
        handler: async (args) => {
          return await quantumSimulator.processTask({ type: 'run-circuit', payload: args });
        }
      });
    }

    // 2. MEROVINGIAN CORTEX (High Council / Redundancy)
    merovingian = new MerovingianCortex(messageBroker, {
      name: 'MerovingianCortex',
      verbose: true,
      reflectionEnabled: true
    });
    await merovingian.initialize();
    console.log('      âœ… MerovingianCortex active (Endpoint: /api/council/reason)');

    // 3. CODE OBSERVATION (Self-Awareness)
    codeObserver = new CodeObservationArbiter({
      quadBrain: quadBrain,
      basePath: process.cwd()
    });
    await codeObserver.initialize();
    console.log('      âœ… CodeObservationArbiter active (Self-monitoring enabled)');

    // Register Tier 2 with MessageBroker
    if (messageBroker) {
      messageBroker.registerArbiter('QuantumSimulationArbiter', { instance: quantumSimulator, role: 'computational' });
      messageBroker.registerArbiter('MerovingianCortex', { instance: merovingian, role: 'advisory' });
      messageBroker.registerArbiter('CodeObservationArbiter', { instance: codeObserver, role: 'observational' });
    }

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 7.99: Pulse Toolkit Suite (User Requested "Building Stuff")
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[7.99] ğŸ§° Initializing Pulse Toolkit Suite...');

    // 1. DATASET BUILDER (Data Factory)
    datasetBuilder = new DatasetBuilder();
    console.log('      âœ… DatasetBuilder active');

    if (toolRegistry) {
      toolRegistry.registerTool({
        name: 'build_dataset',
        description: 'Convert logs to training data (alpaca/sharegpt/llama).',
        parameters: { inputPath: 'string', outputPath: 'string', format: 'string (alpaca|sharegpt|llama)' },
        execute: async ({ inputPath, outputPath, format }) => {
          try {
            if (format === 'alpaca') return await datasetBuilder.convertToAlpaca(inputPath, outputPath);
            if (format === 'sharegpt') return await datasetBuilder.convertToShareGPT(inputPath, outputPath);
            if (format === 'llama') return await datasetBuilder.convertToLlamaChatML(inputPath, outputPath);
            return "Unknown format";
          } catch (e) { return "Error: " + e.message; }
        }
      });
      console.log('         â””â”€ Tool registered: build_dataset');
    }

    // 2. DEMONSTRATION LEARNER (Imitation)
    demonstrationLearner = new DemonstrationLearner({
      name: 'DemonstrationLearner-Pulse',
      messageBroker: messageBroker
    });
    await demonstrationLearner.initialize();
    console.log('      âœ… DemonstrationLearner active (Watching for gameplay/usage)');

    // 3. DEPLOYMENT ARBITER (Release Management)
    deploymentArbiter = new DeploymentArbiter(messageBroker, {
      name: 'DeploymentArbiter-Pulse',
      auditPath: path.join(process.cwd(), 'deploy-audit')
    });
    await deploymentArbiter.initialize();
    console.log('      âœ… DeploymentArbiter active (Secure Release Cycle)');

    // 4. GENOME ARBITER (Autonomous Drives)
    genomeArbiter = new GenomeArbiter({
      name: 'GenomeArbiter-Pulse',
      messageBroker: messageBroker
    });
    await genomeArbiter.initialize();
    console.log('      âœ… GenomeArbiter active (Genetic Drives & Evolution)');

    // 5. GPU TRAINING (Real Compute)
    gpuTrainingArbiter = new GPUTrainingArbiter({
      name: 'GPUTrainingArbiter-Pulse'
    });
    await gpuTrainingArbiter.initialize();
    console.log('      âœ… GPUTrainingArbiter active (NVIDIA CUDA Link)');

    if (messageBroker) {
      messageBroker.registerArbiter('DemonstrationLearner', { instance: demonstrationLearner, role: 'learner' });
      messageBroker.registerArbiter('DeploymentArbiter', { instance: deploymentArbiter, role: 'devops' });
      messageBroker.registerArbiter('GenomeArbiter', { instance: genomeArbiter, role: 'geneticist' });
      messageBroker.registerArbiter('GPUTrainingArbiter', { instance: gpuTrainingArbiter, role: 'trainer' });
    }

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 9.5: MicroAgent Pool (Task Swarm Management)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[9.5] ğŸ Initializing MicroAgent Pool...');

    microAgentPool = new MicroAgentPool({
      parentId: 'SOMA-Main',
      maxPoolSize: 100,
      defaultTTL: 120000, // 2 minutes
      defaultIdleTimeout: 60000, // 1 minute
      logger: console
    });

    // Register all specialized microagent types
    microAgentPool.registerAgentType('batou', BatouAgent);           // Tactical security
    microAgentPool.registerAgentType('jetstream', JetstreamAgent);   // Speed/parallel processing
    microAgentPool.registerAgentType('black', BlackAgent);           // System health
    microAgentPool.registerAgentType('kuze', KuzeAgent);             // Pattern analysis
    microAgentPool.registerAgentType('fetch', FetchAgent);           // HTTP operations
    microAgentPool.registerAgentType('cache', CacheAgent);           // Caching specialist
    microAgentPool.registerAgentType('validate', ValidateAgent);     // Validation
    microAgentPool.registerAgentType('file', FileAgent);             // File operations
    microAgentPool.registerAgentType('mcp', MCPAgent);               // MCP protocol
    microAgentPool.registerAgentType('automation', AutomationAgent); // Task automation
    microAgentPool.registerAgentType('analyze', AnalyzeAgent);       // Data analysis
    microAgentPool.registerAgentType('workflow', WorkflowAgent);     // Workflow orchestration
    microAgentPool.registerAgentType('transform', TransformAgent);   // Data transformation

    console.log('      âœ… MicroAgentPool active (13 specialist types registered)');
    console.log('         â””â”€ Batou (Security), Jetstream (Speed), Black (Health), Kuze (Patterns)');
    console.log('         â””â”€ Fetch, Cache, Validate, File, MCP, Automation, Analyze, Workflow, Transform\n');

    // Wire pool to MessageBroker for task distribution
    if (messageBroker) {
      messageBroker.registerArbiter('MicroAgentPool', {
        instance: microAgentPool,
        role: 'swarm-manager',
        capabilities: ['spawn', 'execute', 'pool-management']
      });

      // Listen to pool events and broadcast
      microAgentPool.on('agent_spawned', ({ agentId, type }) => {
        messageBroker.emit('microagent:spawned', { agentId, type, timestamp: Date.now() });
      });

      microAgentPool.on('agent_terminated', ({ agentId, reason, lifetime }) => {
        messageBroker.emit('microagent:terminated', { agentId, reason, lifetime, timestamp: Date.now() });
      });
    }

    // Expose pool via toolRegistry for dynamic spawning
    if (toolRegistry) {
      toolRegistry.registerTool({
        name: 'spawn_microagent',
        description: 'Spawn a specialized microagent. Types: batou|jetstream|black|kuze|fetch|cache|validate|file|mcp|automation|analyze|workflow|transform',
        parameters: { type: 'string', config: 'object (optional)' },
        execute: async ({ type, config = {} }) => {
          try {
            const agent = await microAgentPool.spawn(type, config);
            return { success: true, agentId: agent.id, type: agent.type };
          } catch (e) { return { success: false, error: e.message }; }
        }
      });

      toolRegistry.registerTool({
        name: 'execute_microagent_task',
        description: 'Execute a task using a microagent (spawns if needed, reuses if available)',
        parameters: { type: 'string', task: 'object', autoTerminate: 'boolean (default: true)' },
        execute: async ({ type, task, autoTerminate = true }) => {
          try {
            const result = await microAgentPool.executeTask(type, task, { autoTerminate });
            return result;
          } catch (e) { return { success: false, error: e.message }; }
        }
      });

      toolRegistry.registerTool({
        name: 'get_pool_status',
        description: 'Get MicroAgentPool status and metrics',
        parameters: {},
        execute: async () => {
          return {
            metrics: microAgentPool.metrics,
            activeAgents: microAgentPool.agents.size,
            registeredTypes: Array.from(microAgentPool.agentTypes.keys())
          };
        }
      });

      console.log('         â””â”€ Tools registered: spawn_microagent, execute_microagent_task, get_pool_status');
    }

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 9.7: ASI Problem Solving Core (Tree Search + Sandbox)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[9.7] ğŸŒ³ Initializing ASI Problem Solving Core...');

    // 1. SOLUTION EVALUATOR (Scores solutions)
    solutionEvaluator = new SolutionEvaluator({
      name: 'SolutionEvaluator-Main',
      weights: {
        correctness: 0.4,
        efficiency: 0.3,
        elegance: 0.2,
        robustness: 0.1
      },
      logger: console
    });
    console.log('      âœ… SolutionEvaluator active (Quality scoring enabled)');

    // 2. SANDBOX RUNNER (Safe execution)
    sandboxRunner = new SandboxRunner({
      name: 'SandboxRunner-Main',
      timeout: 5000,
      memoryLimit: 256, // MB
      logger: console
    });
    await sandboxRunner.initialize();
    console.log('      âœ… SandboxRunner active (Isolated code execution)');

    // 3. TREE SEARCH ENGINE (Monte Carlo tree search)
    treeSearchEngine = new TreeSearchEngine({
      maxDepth: 5,
      branchingFactor: 10,
      strategy: 'beam',
      pruneThreshold: 0.2,
      maxNodes: 1000,
      timeout: 300000, // 5 minutes
      evaluator: solutionEvaluator,
      llm: quadBrain, // Use QuadBrain as LLM
      reasoningChamber: reasoningChamber,
      causalityArbiter: causalityArbiter,
      logger: console
    });
    console.log('      âœ… TreeSearchEngine active (MCTS problem solving)');
    console.log('         â””â”€ Cognitive diversity: ENABLED (Divergent + Critic + Recombination)');

    // 4. ASI META-LEARNER (Learning to learn better)
    asiMetaLearner = new ASIMetaLearner({
      name: 'ASIMetaLearner-Main',
      treeSearch: treeSearchEngine,
      learningPipeline: learningPipeline,
      logger: console
    });
    await asiMetaLearner.initialize();
    console.log('      âœ… ASI MetaLearner active (Optimizing search strategies)');

    // 5. PERFORMANCE PREDICTOR (Resource estimation)
    performancePredictor = new PerformancePredictor({
      name: 'PerformancePredictor-Main',
      logger: console
    });
    await performancePredictor.initialize();
    console.log('      âœ… PerformancePredictor active (Cost/time estimation)\n');

    // Wire to MessageBroker
    if (messageBroker) {
      messageBroker.registerArbiter('TreeSearchEngine', {
        instance: treeSearchEngine,
        role: 'problem-solver',
        capabilities: ['tree-search', 'monte-carlo', 'solution-generation']
      });
      messageBroker.registerArbiter('SandboxRunner', {
        instance: sandboxRunner,
        role: 'executor',
        capabilities: ['safe-execution', 'code-testing']
      });
    }

    // Expose via toolRegistry
    if (toolRegistry) {
      toolRegistry.registerTool({
        name: 'solve_problem_asi',
        description: 'Use ASI tree search to explore solution space for complex problems',
        parameters: { problem: 'string', options: 'object (optional)' },
        execute: async ({ problem, options = {} }) => {
          try {
            const result = await treeSearchEngine.search(problem, options);
            return result;
          } catch (e) { return { success: false, error: e.message }; }
        }
      });

      toolRegistry.registerTool({
        name: 'execute_code_safely',
        description: 'Execute code in a sandboxed environment with resource limits',
        parameters: { code: 'string', language: 'string', timeout: 'number (optional)' },
        execute: async ({ code, language, timeout }) => {
          try {
            const result = await sandboxRunner.execute({ code, language, timeout });
            return result;
          } catch (e) { return { success: false, error: e.message }; }
        }
      });

      console.log('         â””â”€ Tools registered: solve_problem_asi, execute_code_safely');
    }

    // Connect TreeSearch to learning pipeline
    treeSearchEngine.on('search_complete', (result) => {
      if (learningPipeline && result.success) {
        learningPipeline.captureExperience({
          type: 'problem_solving',
          problem: result.problem,
          solution: result.solution,
          stats: result.stats,
          timestamp: Date.now()
        });
      }
    });

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 10: Special Ops (Black & Kuze) - Now using pool
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[10/12] ğŸ•¶ï¸  Initializing Special Ops Agents (via Pool)...');

    // 1. BLACK (System Health & Ops) - Spawn via pool for consistency
    blackAgent = await microAgentPool.spawn('black', {
      monitoringInterval: 30000,
      cpuLoadThreshold: 0.85,
      autoTerminate: false // Keep alive
    });
    console.log('      âœ… Black Agent active (System Monitor & Health)');

    // 2. KUZE (Pattern Analysis) - Spawn via pool
    kuzeAgent = await microAgentPool.spawn('kuze', {
      patternThreshold: 0.70,
      autoTerminate: false // Keep alive
    });
    console.log('      âœ… Kuze Agent active (Deep Pattern Analysis)');

    // 3. BATOU (Security & Defense) - Spawn via pool
    batouAgent = await microAgentPool.spawn('batou', {
      patrolInterval: 45000,
      alertThreshold: 'high',
      autoTerminate: false // Keep alive
    });
    console.log('      âœ… Batou Agent active (Security & Defense)');

    // 4. JETSTREAM (Parallel Processing) - Spawn via pool
    jetstreamAgent = await microAgentPool.spawn('jetstream', {
      maxConcurrency: 5,
      autoTerminate: false // Keep alive
    });
    console.log('      âœ… Jetstream Agent active (High-Speed Processing)');

    if (messageBroker) {
      messageBroker.registerArbiter('BlackAgent', { instance: blackAgent, role: 'monitor' });
      messageBroker.registerArbiter('KuzeAgent', { instance: kuzeAgent, role: 'analyst' });
      messageBroker.registerArbiter('BatouAgent', { instance: batouAgent, role: 'security' });
      messageBroker.registerArbiter('JetstreamAgent', { instance: jetstreamAgent, role: 'accelerator' });
    }

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // WIRING: Special Ops -> Dashboard (Command Bridge)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    const broadcastToDashboard = (type, payload) => {
      if (!wss) return;
      const msg = JSON.stringify({ type, payload });
      wss.clients.forEach(client => {
        if (client.readyState === 1) { // OPEN
          client.send(msg);
        }
      });
    };

    // Forward Black Ops Alerts to UI
    blackAgent.on('alert', (alert) => {
      // 1. Toast Notification
      broadcastToDashboard('ui.notify', {
        type: alert.severity === 'critical' ? 'error' : 'warning',
        message: `[BLACK OPS] ${alert.message}`
      });

      // 2. Log Stream
      broadcastToDashboard('log', {
        type: 'warning',
        message: `[Black] ${alert.message} (${alert.value} > ${alert.threshold})`,
        timestamp: Date.now()
      });
    });

    // Forward Kuze Insights to UI
    kuzeAgent.on('risk-modeled', (model) => {
      if (model.overallRisk > 0.5) {
        broadcastToDashboard('ui.notify', {
          type: 'info',
          message: `[KUZE] Pattern Detection: Risk Level ${(model.overallRisk * 100).toFixed(0)}%`
        });
      }
    });
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    if (toolRegistry) {
      toolRegistry.registerTool({
        name: 'system_health_check',
        description: 'Get detailed system health metrics from Black',
        parameters: {},
        execute: async () => blackAgent.healthCheck()
      });

      toolRegistry.registerTool({
        name: 'analyze_patterns',
        description: 'Ask Kuze to analyze patterns in a dataset or event sequence',
        parameters: {
          events: 'array (optional)',
          sequence: 'array (optional)',
          context: 'string'
        },
        execute: async (params) => {
          if (params.events) return kuzeAgent.detectPatterns(params);
          if (params.sequence) return kuzeAgent.analyzeSequence(params);
          return "Please provide events or sequence for analysis.";
        }
      });
    }

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 10.5: Cognitive Depth Enhancement
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[10.5] ğŸ§  Initializing Cognitive Depth Systems...');

    // 1. EMOTIONAL ENGINE (Emotional Intelligence)
    emotionalEngine = new EmotionalEngine({
      name: 'EmotionalEngine-Main',
      messageBroker: messageBroker,
      intensityRange: [0, 1],
      decayRate: 0.1,
      logger: console
    });
    await emotionalEngine.initialize();
    console.log('      âœ… EmotionalEngine active (Emotional processing enabled)');

    // 2. PERSONALITY ENGINE (Character Consistency)
    personalityEngine = new PersonalityEngine({
      name: 'PersonalityEngine-Main',
      traits: {
        openness: 0.8,
        conscientiousness: 0.7,
        extraversion: 0.6,
        agreeableness: 0.75,
        neuroticism: 0.3
      },
      logger: console
    });
    await personalityEngine.initialize();
    console.log('      âœ… PersonalityEngine active (Big Five personality model)');

    // 3. SYNTHETIC LAYERED CORTEX (Deep Processing)
    syntheticCortex = new SyntheticLayeredCortex({
      name: 'SyntheticCortex-Main',
      layers: 7, // Mimics cortical layers
      quadBrain: quadBrain,
      emotionalEngine: emotionalEngine,
      logger: console
    });
    await syntheticCortex.initialize();
    console.log('      âœ… SyntheticLayeredCortex active (7-layer cognitive processing)');

    // 4. MEMORY CONSOLIDATION ENGINE (Long-term memory formation)
    memoryConsolidation = new MemoryConsolidationEngine({
      name: 'MemoryConsolidation-Main',
      mnemonicArbiter: mnemonicArbiter,
      consolidationInterval: 3600000, // 1 hour
      importanceThreshold: 0.6,
      logger: console
    });
    await memoryConsolidation.initialize();
    console.log('      âœ… MemoryConsolidationEngine active (Episodic â†’ Semantic conversion)');

    // 5. MEMORY COMMIT COORDINATOR (Write management)
    memoryCommitCoordinator = new MemoryCommitCoordinator({
      name: 'MemoryCommit-Main',
      mnemonicArbiter: mnemonicArbiter,
      batchSize: 50,
      flushInterval: 5000, // 5 seconds
      logger: console
    });
    await memoryCommitCoordinator.initialize();
    console.log('      âœ… MemoryCommitCoordinator active (Optimized batch writes)\n');

    // Wire to MessageBroker
    if (messageBroker) {
      messageBroker.registerArbiter('EmotionalEngine', {
        instance: emotionalEngine,
        role: 'affective',
        capabilities: ['emotion-processing', 'sentiment-analysis']
      });
      messageBroker.registerArbiter('PersonalityEngine', {
        instance: personalityEngine,
        role: 'character',
        capabilities: ['personality-modeling', 'trait-consistency']
      });
      messageBroker.registerArbiter('SyntheticLayeredCortex', {
        instance: syntheticCortex,
        role: 'cognitive',
        capabilities: ['deep-processing', 'multi-layer-reasoning']
      });
    }

    // Connect to QuadBrain for emotional responses
    if (quadBrain) {
      quadBrain.emotionalEngine = emotionalEngine;
      quadBrain.personalityEngine = personalityEngine;
      quadBrain.syntheticCortex = syntheticCortex;
      console.log('      âœ… QuadBrain enhanced with emotional intelligence and personality\n');
    }

    // Connect memory consolidation to nighttime learning
    if (nighttimeLearningOrchestrator) {
      nighttimeLearningOrchestrator.memoryConsolidation = memoryConsolidation;
      console.log('      âœ… Memory consolidation linked to nighttime learning\n');
    }

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 10.7: Training Infrastructure (Distributed Learning)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[10.7] ğŸ“Š Initializing Training Infrastructure...');

    // 1. LOAD PIPELINE (Training data loading)
    loadPipeline = new LoadPipelineArbiter({
      name: 'LoadPipeline-Main',
      batchSize: 32,
      prefetchSize: 64,
      numWorkers: 4,
      logger: console
    });
    await loadPipeline.initialize();
    console.log('      âœ… LoadPipelineArbiter active (Optimized data loading)');

    // 2. MIXED PRECISION (Memory-efficient training)
    mixedPrecision = new MixedPrecisionArbiter({
      name: 'MixedPrecision-Main',
      enabled: true,
      scaleGradients: true,
      logger: console
    });
    await mixedPrecision.initialize();
    console.log('      âœ… MixedPrecisionArbiter active (FP16/FP32 optimization)');

    // 3. ASYNC GRADIENT (Distributed gradient updates)
    asyncGradient = new AsyncGradientArbiter({
      name: 'AsyncGradient-Main',
      staleness: 5,
      momentumCorrection: true,
      logger: console
    });
    await asyncGradient.initialize();
    console.log('      âœ… AsyncGradientArbiter active (Parallel gradient sync)');

    // 4. BOOTSTRAP TRAINING (Self-supervised learning)
    bootstrapTraining = new BootstrapTrainingArbiter({
      name: 'BootstrapTraining-Main',
      dataAugmentation: true,
      pseudoLabeling: true,
      logger: console
    });
    await bootstrapTraining.initialize();
    console.log('      âœ… BootstrapTrainingArbiter active (Self-supervised learning)');

    // 5. SKILL ACQUISITION (Capability expansion)
    skillAcquisition = new SkillAcquisitionArbiter({
      name: 'SkillAcquisition-Main',
      messageBroker: messageBroker,
      learningPipeline: learningPipeline,
      logger: console
    });
    await skillAcquisition.initialize();
    console.log('      âœ… SkillAcquisitionArbiter active (Dynamic skill learning)');

    // 6. TRAINING SWARM (Distributed parallel training)
    trainingSwarm = new TrainingSwarmArbiter({
      name: 'TrainingSwarm-Main',
      numWorkers: 4,
      learningPipeline: learningPipeline,
      mixedPrecision: mixedPrecision,
      asyncGradient: asyncGradient,
      loadPipeline: loadPipeline,
      logger: console
    });
    await trainingSwarm.initialize();
    console.log('      âœ… TrainingSwarmArbiter active (4-worker parallel training)\n');

    // Wire to MessageBroker
    if (messageBroker) {
      messageBroker.registerArbiter('TrainingSwarmArbiter', {
        instance: trainingSwarm,
        role: 'trainer',
        capabilities: ['distributed-training', 'parallel-processing']
      });
      messageBroker.registerArbiter('SkillAcquisitionArbiter', {
        instance: skillAcquisition,
        role: 'learner',
        capabilities: ['skill-learning', 'capability-expansion']
      });
    }

    // Connect training to ContinuousLearningBridge
    if (continuousLearningBridge) {
      continuousLearningBridge.trainingSwarm = trainingSwarm;
      continuousLearningBridge.skillAcquisition = skillAcquisition;
      console.log('      âœ… Training infrastructure linked to continuous learning\n');
    }

    // Expose via toolRegistry
    if (toolRegistry) {
      toolRegistry.registerTool({
        name: 'train_model',
        description: 'Trigger distributed model training with the training swarm',
        parameters: { dataset: 'string', config: 'object (optional)' },
        execute: async ({ dataset, config = {} }) => {
          try {
            const result = await trainingSwarm.train({ dataset, ...config });
            return result;
          } catch (e) { return { success: false, error: e.message }; }
        }
      });

      console.log('         â””â”€ Tool registered: train_model');
    }

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 10.8: Autonomous Capability Expansion
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[10.8] ğŸ§  Initializing Autonomous Capability Expansion...');

    capabilityExpansion = new AutonomousCapabilityExpansion({
      name: 'CapabilityExpansion-Main',
      quadBrain: quadBrain,
      messageBroker: messageBroker,
      baseDir: process.cwd(),
      logger: console
    });
    await capabilityExpansion.initialize();
    console.log('      âœ… CapabilityExpansion active (Self-expanding system)');
    console.log('         â””â”€ Can detect missing capabilities and search GitHub\n');

    if (messageBroker) {
      messageBroker.registerArbiter('AutonomousCapabilityExpansion', {
        instance: capabilityExpansion,
        role: 'self-improvement',
        capabilities: ['capability-detection', 'github-search', 'auto-integration']
      });
    }

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 10.9: Cluster & Distribution (Multi-Node)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[10.9] ğŸŒ Initializing Cluster Capabilities...');

    // 1. RESOURCE MONITOR (Performance tracking)
    resourceMonitor = new ResourceMonitor({
      name: 'ResourceMonitor-Main',
      pollInterval: 1000, // 1 second
      historySize: 3600, // 1 hour of data
      logger: console
    });
    await resourceMonitor.initialize();
    console.log('      âœ… ResourceMonitor active (CPU/Memory/Network tracking)');

    // 2. CLUSTER MEMORY MANAGER (Distributed shared state)
    clusterMemory = new ClusterMemoryManager({
      name: 'ClusterMemory-Main',
      syncInterval: 5000, // 5 seconds
      compressionEnabled: true,
      logger: console
    });
    await clusterMemory.initialize();
    console.log('      âœ… ClusterMemoryManager active (Shared memory across nodes)');

    // 3. AUTO SPAWNER (Dynamic scaling)
    autoSpawner = new AutoSpawner({
      name: 'AutoSpawner-Main',
      minNodes: 1,
      maxNodes: 8,
      scaleUpThreshold: 0.8, // CPU threshold
      scaleDownThreshold: 0.3,
      cooldownPeriod: 300000, // 5 minutes
      logger: console
    });
    await autoSpawner.initialize();
    console.log('      âœ… AutoSpawner active (Auto-scaling 1-8 nodes)');

    // 4. CLUSTER COORDINATOR (Multi-node orchestration)
    clusterCoordinator = new ClusterCoordinator({
      name: 'ClusterCoordinator-Main',
      clusterMemory: clusterMemory,
      resourceMonitor: resourceMonitor,
      autoSpawner: autoSpawner,
      messageBroker: messageBroker,
      logger: console
    });
    await clusterCoordinator.initialize();
    console.log('      âœ… ClusterCoordinator active (Multi-node orchestration)\n');

    // Wire to MessageBroker
    if (messageBroker) {
      messageBroker.registerArbiter('ClusterCoordinator', {
        instance: clusterCoordinator,
        role: 'orchestrator',
        capabilities: ['multi-node', 'distributed-compute', 'auto-scaling']
      });
      messageBroker.registerArbiter('ResourceMonitor', {
        instance: resourceMonitor,
        role: 'monitor',
        capabilities: ['performance-tracking', 'metrics-collection']
      });
    }

    // Connect cluster to existing ClusterIntegration
    if (clusterIntegration) {
      clusterIntegration.clusterCoordinator = clusterCoordinator;
      clusterIntegration.clusterMemory = clusterMemory;
      console.log('      âœ… ClusterIntegration enhanced with coordinator & memory\n');
    }

    // Connect training swarm to cluster
    if (trainingSwarm && clusterCoordinator) {
      trainingSwarm.clusterCoordinator = clusterCoordinator;
      console.log('      âœ… Training swarm can now use cluster resources\n');
    }

    // Expose via toolRegistry
    if (toolRegistry) {
      toolRegistry.registerTool({
        name: 'get_cluster_status',
        description: 'Get cluster status, nodes, and resource utilization',
        parameters: {},
        execute: async () => {
          try {
            const status = await clusterCoordinator.getStatus();
            return status;
          } catch (e) { return { success: false, error: e.message }; }
        }
      });

      toolRegistry.registerTool({
        name: 'scale_cluster',
        description: 'Manually scale cluster to specified number of nodes',
        parameters: { nodeCount: 'number' },
        execute: async ({ nodeCount }) => {
          try {
            const result = await autoSpawner.scaleTo(nodeCount);
            return result;
          } catch (e) { return { success: false, error: e.message }; }
        }
      });

      console.log('         â””â”€ Tools registered: get_cluster_status, scale_cluster');
    }

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 11: Consciousness & Reasoning Layer (Pre-ASI)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[11/12] ğŸ§  Initializing Advanced Cognitive Organs...');

    // 1. REASONING CHAMBER (Deep Logic)
    reasoningChamber = new ReasoningChamber({
      name: 'ReasoningChamber',
      mnemonic: mnemonicArbiter,
      // causality & worldModel injected via message bus usually
    });
    await reasoningChamber.initialize();
    console.log('      âœ… ReasoningChamber active (Causal/Counterfactual/Mechanistic)');

    // 2. THEORY OF MIND (Social Intelligence)
    theoryOfMind = new TheoryOfMindArbiter('theory-of-mind', {
      adaptiveResponseEnabled: true
    });
    await theoryOfMind.onActivate(); // It uses onActivate instead of initialize
    console.log('      âœ… TheoryOfMind active (User Intent & Empathy)');

    // 3. SIMULATION ARBITER (Physical Embodiment)
    simulationArbiter = new SimulationArbiter({ port: 8081 });
    await simulationArbiter.initialize();
    console.log('      âœ… SimulationArbiter active (Physics Engine on :8081)');

    // 4. META-LEARNING ENGINE (Learning to Learn)
    // Requires learningPipeline (Step 8)
    metaLearner = new MetaLearningEngine({
      messageBroker: messageBroker,
      learningPipeline: learningPipeline, // Assuming defined in generic arbiter section or globally
      optimizationInterval: 50
    });
    await metaLearner.initialize();
    console.log('      âœ… MetaLearningEngine active (Optimizing Learning Strategies)');

    if (messageBroker) {
      messageBroker.registerArbiter('ReasoningChamber', { instance: reasoningChamber, role: 'logician' });
      messageBroker.registerArbiter('TheoryOfMind', { instance: theoryOfMind, role: 'psychologist' });
      messageBroker.registerArbiter('SimulationArbiter', { instance: simulationArbiter, role: 'physicist' });
      messageBroker.registerArbiter('MetaLearningEngine', { instance: metaLearner, role: 'teacher' });
    }

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 12: ASI Orchestrator (The Conductor)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[12/12] ğŸ¼ Initializing ASI Orchestrator...');
    asiOrchestrator = new ASIOrchestrator({
      name: 'ASIOrchestrator-Main'
    });
    await asiOrchestrator.initialize();
    console.log('      âœ… ASI Orchestrator ready (System Integration Complete)\n');

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 13: Final Integration (The "Self")
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[13/13] ğŸ”— Activation of Higher Functions...');

    // 1. STEVE ARBITER (The Toolmaker Persona)
    // Needs ASI Orchestrator for swarm access
    steveArbiter = new SteveArbiter(messageBroker, {
      orchestrator: asiOrchestrator,
      kevinManager: kevinManager,
      learningPipeline: learningPipeline
    });
    await steveArbiter.initialize();
    console.log('      âœ… STEVE active (Tool Generation & Persona)');

    // Update PulseArbiter with SteveArbiter reference now that Steve is initialized
    if (pulseArbiter) {
      pulseArbiter.arbiters.steve = steveArbiter;
      console.log('      âœ… PulseArbiter linked to SteveArbiter');
    }

    // 2. AGI INTEGRATION HUB (The Consciousness Loop)
    // Wires everything together
    agiHub = new AGIIntegrationHub({
      agiLoopIntervalMs: 60000,
      enableAutoPlanning: true
    });
    await agiHub.initialize(); // This triggers the wiring of WorldModel, GoalPlanner, etc.
    console.log('      âœ… AGI Integration Hub active (Consciousness Loop Running)');

    if (messageBroker) {
      messageBroker.registerArbiter('SteveArbiter', { instance: steveArbiter, role: 'toolmaker' });
      messageBroker.registerArbiter('AGIIntegrationHub', { instance: agiHub, role: 'self' });
    }

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 8: AUTOGEN - Whisper Audio Processing (Voice Modality)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[8/11] ğŸ¤ Initializing Whisper Audio Processing...');
    whisperArbiter = new WhisperArbiter({
      name: 'WhisperArbiter-Main'
    });

    // Try to initialize Whisper (requires OPENAI_API_KEY)
    whisperArbiter.initialize().then(() => {
      console.log('      âœ… WhisperArbiter active (voice input ready)\n');
      // Link to QuadBrain if possible
      if (quadBrain) quadBrain.whisperArbiter = whisperArbiter;
    }).catch(err => {
      console.warn('      âš ï¸ WhisperArbiter failed to load (continuing without voice input):', err.message);
    });

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 9: AUTOGEN Phase 2 - Workflow Storage
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[9/11] ğŸ’¾ Initializing Workflow Storage...');
    workflowStorage = new WorkflowStorage({
      name: 'WorkflowStorage-Main'
    });
    await workflowStorage.initialize();
    console.log('      âœ… WorkflowStorage ready (persistent workflow storage)\n');

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 10: AUTOGEN Phase 2 - FSM Executor (Visual Workflows)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[10/11] ğŸ”„ Initializing FSM Workflow Engine...');
    fsmExecutor = new FSMExecutor({
      name: 'FSMExecutor-Main',
      storageDir: workflowStorage.storageDir
    });
    await fsmExecutor.initialize();

    // Connect FSM to action handlers (agents, arbiters)
    fsmExecutor.on('execute_action', async (actionEvent) => {
      const { executionId, action, parameters, context, data } = actionEvent;

      // Route actions to appropriate handlers
      try {
        let result;

        // Example action routing
        if (action.startsWith('quadbrain:')) {
          const query = action.replace('quadbrain:', '');
          result = await quadBrain.reason(query, { ...context, ...parameters });
        } else if (action.startsWith('fragment:')) {
          const fragmentName = action.replace('fragment:', '');
          // Handle fragment actions
          result = { message: `Fragment ${fragmentName} executed` };
        } else {
          // Default: pass to Pulse/ConductorArbiter
          result = { message: `Action ${action} executed` };
        }

        // Send result back to FSM
        fsmExecutor.emit(`action_result:${executionId}:${action}`, result);

      } catch (error) {
        fsmExecutor.emit(`action_result:${executionId}:${action}`, {
          error: error.message
        });
      }
    });

    console.log('      âœ… FSM Executor ready (visual workflow engine active)\n');

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 11: AUTOGEN Phase 2 - Parallel Orchestrator
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[11/11] âš¡ Initializing Parallel Workflow Orchestrator...');
    parallelOrchestrator = new ParallelOrchestrator({
      name: 'ParallelOrchestrator-Main',
      fsmExecutor
    });
    console.log('      âœ… Parallel Orchestrator ready (concurrent workflows enabled)\n');

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 6: Local Model Manager (LLM Independence)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[6/6] ğŸ¦™ Initializing Local Model Manager...');
    localModelManager = new LocalModelManager({
      name: 'LocalModelManager-Main',
      messageBroker: messageBroker
    });
    await localModelManager.initialize();

    // Register with MessageBroker
    messageBroker.registerArbiter('LocalModelManager', {
      role: 'manager',
      version: '1.0.0',
      instance: localModelManager
    });
    console.log('      âœ… LocalModelManager ready (Managing SOMA-1T models)\n');


    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 7: Engineering Swarm (Self-Modification)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[7/6] ğŸ‘· Initializing Engineering Swarm...');
    engineeringAgent = new EngineeringSwarmArbiter({
      name: 'EngineeringSwarmArbiter',
      messageBroker,
      quadBrain,
      edgeOrchestrator
    });
    await engineeringAgent.initialize();

    // Register with MessageBroker
    messageBroker.registerArbiter('EngineeringSwarmArbiter', {
      role: 'architect',
      version: '1.0.0',
      instance: engineeringAgent
    });
    console.log('      âœ… EngineeringSwarmArbiter ready (Self-Modification enabled)\n');

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 8: Vision System (Sight)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[8/11] ğŸ‘ï¸ Initializing Vision Processing...');
    visionArbiter = new VisionProcessingArbiter({
      name: 'VisionProcessingArbiter',
      batchSize: 16
    });
    await visionArbiter.initialize();

    // Vision needs manual registration since it's an EventEmitter
    messageBroker.registerArbiter('VisionProcessingArbiter', {
      role: 'vision',
      version: '1.0.0',
      instance: visionArbiter
    });
    console.log('      âœ… VisionProcessingArbiter ready (SOMA can see)\n');

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 8.5: Pulse Arbiter (IDE Intelligence Orchestrator)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[8.5/11] ğŸ¨ Initializing Pulse Arbiter (IDE Intelligence)...');
    pulseArbiter = new PulseArbiter({
      name: 'PulseArbiter',
      quadBrain: quadBrain,
      steveArbiter: steveArbiter, // Will be set after Steve is initialized
      engineeringSwarmArbiter: engineeringAgent,
      visionArbiter: visionArbiter,
      fileSystemArbiter: fileSystem,
      contextManagerArbiter: contextManager,
      computerControlArbiter: computerControl,
      codeObservationArbiter: codeObserver,
      reasoningChamber: reasoningChamber,
      adaptiveLearningRouter: adaptiveRouter
    });
    await pulseArbiter.initialize();

    // Register with MessageBroker
    messageBroker.registerArbiter('PulseArbiter', {
      role: 'orchestrator',
      version: '1.0.0',
      instance: pulseArbiter,
      capabilities: ['code_generation', 'file_ops', 'reasoning', 'vision_analysis']
    });
    console.log('      âœ… PulseArbiter ready (Pulse IDE connected to SOMA cognitive system)\n');

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 9: Audio System (Hearing)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[9/11] ğŸ‘‚ Initializing Hearing (Whisper)...');
    try {
      whisperArbiter = new WhisperArbiter({
        name: 'WhisperArbiter',
        apiKey: process.env.OPENAI_API_KEY
      });
      await whisperArbiter.initialize();

      messageBroker.registerArbiter('WhisperArbiter', {
        role: 'audio',
        version: '1.0.0',
        instance: whisperArbiter
      });
      console.log('      âœ… WhisperArbiter ready (SOMA can hear)\n');
    } catch (err) {
      console.warn('      âš ï¸ Whisper init failed (check OPENAI_API_KEY):', err.message);
    }

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 10: ASI Orchestrator (The Boss)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[10/11] ğŸ§  Initializing ASI Orchestrator...');
    asiOrchestrator = new ASIOrchestrator({
      name: 'ASIOrchestrator'
    });
    // ASI Orchestrator registers itself during initialize()
    await asiOrchestrator.initialize();
    console.log('      âœ… ASIOrchestrator active (The Mission is Go)\n');

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // Start Dashboard Broadcasting
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    startMetricsBroadcast();

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 14: Hybrid Search (ACORN + FAISS + BM25)
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[14/16] ğŸ” Initializing Hybrid Search System (ACORN)...');

    try {
      // Get embedder from MnemonicArbiter if available
      const embedder = mnemonicArbiter?.embedder || null;

      hybridSearchArbiter = new HybridSearchArbiter({
        name: 'HybridSearchArbiter-Main',
        embedder: embedder,
        vectorWeight: 0.7,
        bm25Weight: 0.3,
        cacheMaxSize: 2000,
        cacheTTL: 600000 // 10 minutes
      });

      await hybridSearchArbiter.initialize();
      console.log('      âœ… HybridSearchArbiter active (ACORN + FAISS + BM25)');

      // Register with MessageBroker
      if (messageBroker) {
        messageBroker.registerArbiter('HybridSearchArbiter', {
          role: 'search',
          version: '1.0.0',
          instance: hybridSearchArbiter
        });
      }

      // Register search tool
      if (toolRegistry) {
        toolRegistry.registerTool({
          name: 'semantic_search',
          description: 'Search documents using hybrid semantic + keyword search (ACORN)',
          parameters: {
            query: 'string',
            filters: 'object (optional)',
            limit: 'number (default: 10)'
          },
          execute: async ({ query, filters, limit }) => {
            return await hybridSearchArbiter.search(query, { filters, limit: limit || 10 });
          }
        });
      }
    } catch (err) {
      console.warn('      âš ï¸ HybridSearchArbiter failed:', err.message);
    }

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 15: Continuous Learning Infrastructure
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[15/16] ğŸŒ‰ Initializing Continuous Learning Infrastructure...');

    // 1. CONTINUOUS LEARNING BRIDGE (Real-time pattern extraction + model updates)
    try {
      continuousLearningBridge = new ContinuousLearningBridge({
        name: 'ContinuousLearningBridge-Main',
        maxPatterns: 2000,
        incrementalTrainInterval: 86400000, // 24 hours
        minExperiencesForTrain: 50
      });

      await continuousLearningBridge.initialize({
        learningPipeline: learningPipeline,
        experienceBuffer: learningPipeline?.experienceBuffer,
        metaLearning: metaLearner,
        conversationHistory: null, // Will be wired if ConversationHistoryArbiter exists
        trainingDataExporter: trainingCollector,
        hybridSearch: hybridSearchArbiter,  // ACORN vector storage for patterns
        mnemonic: mnemonicArbiter           // 3-tier memory for persistence
      });

      console.log('      âœ… ContinuousLearningBridge active (Real-time patterns + Prompt evolution)');

      // Register with MessageBroker
      if (messageBroker) {
        messageBroker.registerArbiter('ContinuousLearningBridge', {
          role: 'learning',
          version: '1.0.0',
          instance: continuousLearningBridge
        });
      }
    } catch (err) {
      console.warn('      âš ï¸ ContinuousLearningBridge failed:', err.message);
    }

    // 2. NIGHTTIME LEARNING ORCHESTRATOR (Autonomous 3 AM training sessions)
    try {
      nighttimeLearningOrchestrator = new NighttimeLearningOrchestrator({
        name: 'NighttimeLearningOrchestrator-Main',
        configPath: path.join(process.cwd(), 'config', 'nighttime-learning.json')
      });

      await nighttimeLearningOrchestrator.initialize({
        timekeeper: timekeeper,
        mnemonic: mnemonicArbiter,
        quadBrain: quadBrain,
        archivist: null, // ArchivistArbiter if available
        reasoningChamber: reasoningChamber,
        deployment: deploymentArbiter,
        gpuTraining: gpuTrainingArbiter,
        curiosityEngine: curiosityEngine,
        learningPipeline: learningPipeline,
        metaLearner: metaLearner,
        continuousLearningBridge: continuousLearningBridge
      });

      console.log('      âœ… NighttimeLearningOrchestrator active (Autonomous learning scheduled)');

      // Register with MessageBroker
      if (messageBroker) {
        messageBroker.registerArbiter('NighttimeLearningOrchestrator', {
          role: 'learning',
          version: '1.0.0',
          instance: nighttimeLearningOrchestrator
        });
      }
    } catch (err) {
      console.warn('      âš ï¸ NighttimeLearningOrchestrator failed:', err.message);
    }

    // 3. WIRE UP CURIOSITY ENGINE TO LEARNING BRIDGE
    if (curiosityEngine && continuousLearningBridge) {
      curiosityEngine.on('question_generated', async (question) => {
        // Feed curiosity questions into the learning pipeline
        if (learningPipeline) {
          await learningPipeline.logInteraction({
            type: 'curiosity_question',
            query: question.question,
            context: question.context,
            priority: question.priority || 0.5,
            timestamp: Date.now()
          });
        }
      });
      console.log('      âœ… CuriosityEngine wired to ContinuousLearningBridge');
    }

    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    // STEP 16: Self-Awareness & Accelerated Learning Loop
    // â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    console.log('[16/16] ğŸª Initializing Self-Awareness Loop (ANAMNESIS Enhancement)...');

    // 1. RECURSIVE SELF-MODEL (SOMA's Self-Awareness)
    try {
      recursiveSelfModel = new RecursiveSelfModel({
        messageBroker: messageBroker,
        learningPipeline: learningPipeline
      });

      // Pass the entire system for introspection
      await recursiveSelfModel.initialize({
        quadBrain,
        fragmentRegistry,
        learningPipeline,
        mnemonicArbiter,
        adaptiveRouter,
        messageBroker
      });

      console.log('      âœ… RecursiveSelfModel active (SOMA knows herself)');

      if (messageBroker) {
        messageBroker.registerArbiter('RecursiveSelfModel', {
          role: 'introspection',
          version: '1.0.0',
          instance: recursiveSelfModel
        });
      }
    } catch (err) {
      console.warn('      âš ï¸ RecursiveSelfModel failed:', err.message);
    }

    // 2. ADAPTIVE LEARNING PLANNER (Decides What to Learn)
    try {
      adaptiveLearningPlanner = getAdaptiveLearningPlanner();
      await adaptiveLearningPlanner.initialize();
      console.log('      âœ… AdaptiveLearningPlanner active (intelligent topic selection)');

      if (messageBroker) {
        messageBroker.registerArbiter('AdaptiveLearningPlanner', {
          role: 'planning',
          version: '1.0.0',
          instance: adaptiveLearningPlanner
        });
      }
    } catch (err) {
      console.warn('      âš ï¸ AdaptiveLearningPlanner failed:', err.message);
    }

    // 3. SELF-DRIVEN CURIOSITY CONNECTOR (Self-Reflection â†’ Curiosity)
    try {
      selfDrivenCuriosity = new SelfDrivenCuriosityConnector({
        codeObserver: codeObserver,
        conversationExtractor: curiosityExtractor,
        curiosityEngine: curiosityEngine,
        quadBrain: quadBrain,
        selfModel: recursiveSelfModel,
        messageBroker: messageBroker,
        codeAnalysisInterval: 3600000,  // Analyze own code every hour
        conversationAnalysisInterval: 1800000  // Analyze conversations every 30 min
      });

      await selfDrivenCuriosity.initialize();
      console.log('      âœ… SelfDrivenCuriosityConnector active (self-reflection â†’ learning)');

      if (messageBroker) {
        messageBroker.registerArbiter('SelfDrivenCuriosityConnector', {
          role: 'curiosity',
          version: '1.0.0',
          instance: selfDrivenCuriosity
        });
      }
    } catch (err) {
      console.warn('      âš ï¸ SelfDrivenCuriosityConnector failed:', err.message);
    }

    // 4. META-LEARNING ARBITER (3x Learning Speed)
    try {
      metaLearningArbiter = new MetaLearningArbiter({
        name: 'MetaLearningArbiter-Main',
        fewShotExamples: 5,
        curriculumStages: 5,
        priorityReplayAlpha: 0.8,
        selfSupervisedRatio: 0.3
      });

      await metaLearningArbiter.initialize({
        mnemonic: mnemonicArbiter,
        experienceBuffer: learningPipeline?.experienceBuffer,
        quadBrain: quadBrain,
        gpuTraining: gpuTrainingArbiter
      });

      console.log('      âœ… MetaLearningArbiter active (3x accelerated learning)');

      if (messageBroker) {
        messageBroker.registerArbiter('MetaLearningArbiter', {
          role: 'meta-learning',
          version: '1.0.0',
          instance: metaLearningArbiter
        });
      }
    } catch (err) {
      console.warn('      âš ï¸ MetaLearningArbiter failed:', err.message);
    }

    // 5. HINDSIGHT REPLAY ARBITER (Learn from Failures)
    try {
      hindsightReplay = new HindsightReplayArbiter({
        name: 'HindsightReplayArbiter-Main',
        hindsightRatio: 0.8,
        maxHindsightGoals: 4
      });

      await hindsightReplay.initialize({
        experienceBuffer: learningPipeline?.experienceBuffer,
        simulationArbiter: simulationArbiter
      });

      console.log('      âœ… HindsightReplayArbiter active (failures â†’ 4 successes)');

      if (messageBroker) {
        messageBroker.registerArbiter('HindsightReplayArbiter', {
          role: 'experience-replay',
          version: '1.0.0',
          instance: hindsightReplay
        });
      }
    } catch (err) {
      console.warn('      âš ï¸ HindsightReplayArbiter failed:', err.message);
    }

    // 6. WIRE THE SELF-AWARENESS LOOP TOGETHER
    console.log('      ğŸ”— Wiring Self-Awareness Loop...');

    // RecursiveSelfModel â†’ SelfDrivenCuriosity (gaps found â†’ curiosity generated)
    if (recursiveSelfModel && selfDrivenCuriosity) {
      recursiveSelfModel.on('gap_identified', async (gap) => {
        await selfDrivenCuriosity.injectCuriosity({
          topic: gap.topic,
          source: 'self-reflection',
          priority: gap.severity || 0.7,
          reason: `Self-model identified gap: ${gap.description}`
        });
      });
      console.log('         â””â”€ RecursiveSelfModel â†’ SelfDrivenCuriosity âœ“');
    }

    // SelfDrivenCuriosity â†’ AdaptiveLearningPlanner (curiosity â†’ learning topics)
    if (selfDrivenCuriosity && adaptiveLearningPlanner) {
      selfDrivenCuriosity.on('curiosity_generated', async (curiosity) => {
        await adaptiveLearningPlanner.addTopic({
          topic: curiosity.topic,
          priority: curiosity.priority,
          source: 'self-driven-curiosity',
          reason: curiosity.reason
        });
      });
      console.log('         â””â”€ SelfDrivenCuriosity â†’ AdaptiveLearningPlanner âœ“');
    }

    // AdaptiveLearningPlanner â†’ MetaLearningArbiter (topics â†’ accelerated learning)
    if (adaptiveLearningPlanner && metaLearningArbiter) {
      adaptiveLearningPlanner.on('topic_selected', async (topic) => {
        await metaLearningArbiter.learnTopic(topic);
      });
      console.log('         â””â”€ AdaptiveLearningPlanner â†’ MetaLearningArbiter âœ“');
    }

    // MetaLearningArbiter â†’ ContinuousLearningBridge (training data â†’ model updates)
    if (metaLearningArbiter && continuousLearningBridge) {
      metaLearningArbiter.on('training_batch_ready', async (batch) => {
        await continuousLearningBridge.ingestTrainingBatch(batch);
      });
      console.log('         â””â”€ MetaLearningArbiter â†’ ContinuousLearningBridge âœ“');
    }

    // HindsightReplay â†’ ExperienceBuffer (reinterpreted failures â†’ success experiences)
    if (hindsightReplay && learningPipeline?.experienceBuffer) {
      hindsightReplay.on('hindsight_experience', async (experience) => {
        await learningPipeline.experienceBuffer.add(experience);
      });
      console.log('         â””â”€ HindsightReplayArbiter â†’ ExperienceBuffer âœ“');
    }

    console.log('      âœ… Self-Awareness Loop COMPLETE');

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 17: Imagination Engine (Aurora's Creative Domain)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    console.log('   ğŸ“ STEP 17: Initializing ImaginationEngine (Aurora\'s creative mind)...');

    try {
      imaginationEngine = new ImaginationEngine({
        triBrain: quadBrain,        // QuadBrain for Aurora, Logos, Prometheus
        messageBroker: messageBroker // Subscribe to curiosity and dream events
      });

      await imaginationEngine.initialize();

      // Wire curiosity â†’ imagination
      if (curiosityEngine) {
        curiosityEngine.on('question_generated', async (question) => {
          messageBroker.publish('curiosity:exploring', {
            payload: {
              question: question.text || question,
              type: question.type || 'curiosity',
              priority: question.priority || 0.5
            }
          });
        });
      }

      // Wire imagination â†’ learning pipeline (promoted ideas become training data)
      messageBroker.subscribe('thought_network:integrate_concept', async (message) => {
        if (continuousLearningBridge && message.payload) {
          await continuousLearningBridge.addPattern({
            type: 'imagination_insight',
            content: message.payload.concept,
            source: 'aurora_imagination',
            confidence: message.payload.confidence || 0.7,
            tags: message.payload.tags || ['imagination']
          });
        }
      });

      console.log('      âœ… ImaginationEngine ACTIVE');
      console.log('         â””â”€ Imagination loop running (60s cycles)');
      console.log('         â””â”€ Curiosity â†’ Imagination âœ“');
      console.log('         â””â”€ Promoted ideas â†’ Learning Pipeline âœ“');

    } catch (err) {
      console.warn('      âš ï¸ ImaginationEngine failed (non-fatal):', err.message);
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 18: Cluster Integration (FederatedLearning + Node Discovery)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const isClusterEnabled = process.env.SOMA_CLUSTER === 'true';

    if (isClusterEnabled) {
      console.log('   ğŸ“ STEP 18: Initializing ClusterIntegration (Federated Learning)...');

      try {
        const clusterRole = process.env.SOMA_ROLE || 'worker';
        const clusterPort = parseInt(process.env.SOMA_CLUSTER_PORT) || 7777;
        const coordinatorAddress = process.env.SOMA_COORDINATOR || '';

        clusterIntegration = new ClusterIntegration({
          nodeId: `soma_${clusterRole}_${Date.now()}`,
          nodeName: `SOMA-${clusterRole.toUpperCase()}`,
          port: clusterPort,
          role: clusterRole,
          discoveryHosts: coordinatorAddress ? [coordinatorAddress] : [],
          heartbeatInterval: 30000,
          minParticipants: 1,
          soma: quadBrain,
          logger: console
        });

        await clusterIntegration.initialize();
        await clusterIntegration.start();

        // Wire federated learning completion â†’ continuous learning
        clusterIntegration.on('aggregation_complete', async (data) => {
          if (continuousLearningBridge) {
            await continuousLearningBridge.ingestTrainingBatch({
              type: 'federated_model',
              round: data.round,
              source: 'cluster_aggregation',
              model: data.model
            });
          }
        });

        // Wire node discovery â†’ logging
        clusterIntegration.on('node_discovered', (nodeInfo) => {
          console.log(`      ğŸ”— Node discovered: ${nodeInfo.name || nodeInfo.nodeId}`);
        });

        console.log(`      âœ… ClusterIntegration ACTIVE (Role: ${clusterRole})`);
        console.log(`         â””â”€ Cluster port: ${clusterPort}`);
        console.log(`         â””â”€ FederatedLearning ENABLED`);
        console.log(`         â””â”€ Node discovery ACTIVE`);

      } catch (err) {
        console.warn('      âš ï¸ ClusterIntegration failed (non-fatal):', err.message);
      }
    } else {
      console.log('   ğŸ“ STEP 18: Cluster mode DISABLED (single-node operation)');
    }

    console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
    console.log('â•‘  ğŸš€ SOMA ASI System ONLINE - Full Autonomy Enabled             â•‘');
    console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
    console.log('â•‘  ğŸ§  SELF-AWARENESS LOOP                                        â•‘');
    console.log('â•‘     â””â”€ RecursiveSelfModel â†’ SelfDrivenCuriosity                â•‘');
    console.log('â•‘     â””â”€ AdaptiveLearningPlanner â†’ MetaLearningArbiter           â•‘');
    console.log('â•‘     â””â”€ HindsightReplay (failures â†’ 4 success experiences)      â•‘');
    console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
    console.log('â•‘  ğŸ“š ANAMNESIS MEMORY ARCHITECTURE                              â•‘');
    console.log('â•‘     â””â”€ Hot: Redis cache | Warm: FAISS vectors | Cold: SQLite   â•‘');
    console.log('â•‘     â””â”€ ACORN + BM25 hybrid semantic search                     â•‘');
    console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
    console.log('â•‘  ğŸ¨ IMAGINATION ENGINE (Aurora\'s Domain)                       â•‘');
    console.log('â•‘     â””â”€ Triography-based idea generation (novelty/curiosity)    â•‘');
    console.log('â•‘     â””â”€ Cognitive Gatekeeper (Logos validation + Prometheus)    â•‘');
    console.log('â•‘     â””â”€ Promoted ideas â†’ Learning Pipeline integration          â•‘');
    console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
    console.log('â•‘  âš¡ LEARNING SYSTEMS                                            â•‘');
    console.log('â•‘     â””â”€ ContinuousLearningBridge ACTIVE                         â•‘');
    console.log('â•‘     â””â”€ Meta-learning 3x acceleration ENABLED                   â•‘');
    console.log('â•‘     â””â”€ Nighttime learning (10:30 PM, 3 AM, Sunday 2 AM)        â•‘');
    console.log('â•‘     â””â”€ Fragment evolution (Genesis/Mitosis/Neuroplasticity)    â•‘');
    if (isClusterEnabled) {
      console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
      console.log('â•‘  ğŸŒ CLUSTER MODE (Federated Learning)                           â•‘');
      console.log(`â•‘     â””â”€ Role: ${(process.env.SOMA_ROLE || 'worker').toUpperCase().padEnd(49)}â•‘`);
      console.log(`â•‘     â””â”€ Port: ${(process.env.SOMA_CLUSTER_PORT || '7777').padEnd(49)}â•‘`);
      console.log('â•‘     â””â”€ Multi-node distributed training ENABLED                  â•‘');
    }
    console.log('â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£');
    console.log('â•‘  ğŸŒŸ She will autonomously evolve, learn, and improve herself   â•‘');
    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');

  } catch (error) {
    console.error('[Server] âŒ Failed to initialize ASI:', error);
    throw error;
  }
}

// ===========================
// WebSocket Connection
// ===========================

wss.on('connection', (ws) => {
  console.log('[Server] ğŸ”Œ Dashboard client connected');
  console.log('[Server] ğŸ“Š Dashboard clients count:', dashboardClients.size + 1);
  dashboardClients.add(ws);

  // Send initial state
  if (mnemonicArbiter) {
    const initMessage = {
      type: 'init',
      data: {
        memory: mnemonicArbiter.getMemoryStats(),
        fragments: fragmentRegistry ? fragmentRegistry.getStats() : null,
        learning: learningPipeline ? learningPipeline.getStats() : null,
        status: 'connected'
      }
    };
    console.log('[Server] ğŸ“¤ Sending init message:', JSON.stringify(initMessage, null, 2));
    ws.send(JSON.stringify(initMessage));
  } else {
    console.log('[Server] âš ï¸ mnemonicArbiter not initialized, sending minimal init');
    ws.send(JSON.stringify({
      type: 'init',
      data: { status: 'connected', message: 'SOMA backend connected (limited features)' }
    }));
  }

  ws.on('message', async (message) => {
    try {
      const parsed = JSON.parse(message);
      console.log('[Server] Received command:', parsed.type);

      if (parsed.type === 'command') {
        const { action, target } = parsed.payload;

        if (action === 'stop_all') {
          console.log('ğŸš¨ EMERGENCY STOP ACTIVATED');
          // TODO: Iterate all arbiters and pause them
          broadcastToDashboard({ type: 'system_state', payload: { emergencyStop: true } });
        } else if (action === 'start_all') {
          console.log('âœ… SYSTEM RESUMED');
          broadcastToDashboard({ type: 'system_state', payload: { emergencyStop: false } });
        }
      }
      else if (parsed.type === 'agent_control') {
        const { arbiterName, action } = parsed.payload;
        console.log(`[AgentControl] ${action} on ${arbiterName}`);
        const arbiter = messageBroker ? messageBroker.getRegisteredArbiters().find(a => a.name === arbiterName) : null;
        if (arbiter) {
          console.log(`Executing ${action} on ${arbiter.name}`);
          // Implement actual arbiter control logic here
        }
      }

    } catch (err) {
      console.error('Error processing message:', err);
    }
  });

  ws.on('close', () => {
    console.log('[Server] Dashboard client disconnected');
    dashboardClients.delete(ws);
  });

  ws.on('error', (error) => {
    console.error('[Server] WebSocket error:', error);
    dashboardClients.delete(ws);
  });
});

// ===========================
// Metrics Broadcasting
// ===========================

function startMetricsBroadcast() {
  console.log('[MetricsBroadcast] ğŸ“¡ Starting metrics broadcast loop...');
  setInterval(() => {
    if (dashboardClients.size === 0) {
      // console.log('[MetricsBroadcast] No clients connected, skipping broadcast');
      return;
    }

    console.log('[MetricsBroadcast] ğŸ“Š Broadcasting to', dashboardClients.size, 'clients');

    // Get memory stats if available
    const stats = mnemonicArbiter ? mnemonicArbiter.getMemoryStats() : {
      tiers: { hot: { size: 0, hits: 0, misses: 0 }, warm: { size: 0, hits: 0, misses: 0 }, cold: { size: 0, hits: 0, misses: 0 } },
      hitRate: { hot: 0, warm: 0, cold: 0 },
      storage: { hot: 'disconnected' }
    };

    // Collect all registered agents from MessageBroker
    const registeredAgents = messageBroker ? messageBroker.getRegisteredArbiters() : [];
    const agents = registeredAgents.map(agent => ({
      id: agent.id || agent.name,
      name: agent.name,
      type: agent.metadata?.type || agent.metadata?.role || 'arbiter',
      status: agent.status || 'active',
      load: Math.floor(Math.random() * 30) + 10, // TODO: Real load tracking
      role: agent.metadata?.role || 'system',
      capabilities: agent.metadata?.capabilities || [],
      healthScore: 95,
      description: agent.metadata?.description || `${agent.name} system component`,
      avatarUrl: agent.metadata?.avatarUrl
    }));

    broadcast({
      type: 'metrics',
      payload: {
        agents: agents, // ADD AGENTS DATA
        cpu: Math.floor(Math.random() * 30) + 20,
        ram: Math.floor(Math.random() * 40) + 30,
        gpu: Math.floor(Math.random() * 50) + 10,
        network: Math.floor(Math.random() * 20) + 5,
        uptime: Math.floor((Date.now() - startTime) / 1000),
        memory: {
          hot: {
            name: 'Redis Cache',
            size: 1024,
            used: stats.tiers.hot.size || 0,
            hitRate: (stats.hitRate.hot * 100) || 0,
            hits: stats.tiers.hot.hits,
            misses: stats.tiers.hot.misses,
            latency: '< 1ms',
            status: stats.storage.hot === 'connected' ? 'connected' : 'disconnected'
          },
          warm: {
            name: 'Vector Store',
            size: 10000,
            used: stats.tiers.warm.size || 0,
            hitRate: (stats.hitRate.warm * 100) || 0,
            hits: stats.tiers.warm.hits,
            misses: stats.tiers.warm.misses,
            latency: '~10ms',
            status: 'active'
          },
          cold: {
            name: 'SQLite DB',
            size: 100000,
            used: stats.tiers.cold.size || 0,
            hitRate: (stats.hitRate.cold * 100) || 0,
            hits: stats.tiers.cold.hits,
            misses: stats.tiers.cold.misses,
            latency: '~50ms',
            status: 'persistent'
          }
        },
        fragments: fragmentRegistry ? fragmentRegistry.getStats() : null,
        learning: learningPipeline ? learningPipeline.getStats() : null,
        quadBrain: quadBrain ? quadBrain.getStats() : null
      }
    });
  }, 2000); // Update every 2 seconds
}

function broadcast(message) {
  const data = JSON.stringify(message);
  dashboardClients.forEach((client) => {
    if (client.readyState === 1) { // OPEN
      client.send(data);
    }
  });
}

// ===========================
// REST API Endpoints
// ===========================

// Health check
app.get('/health', (req, res) => {
  res.json({
    status: 'ok',
    system: 'SOMA ASI',
    level: '4.5 UNLEASHED',
    components: {
      mnemonic: mnemonicArbiter ? 'active' : 'inactive',
      learningPipeline: learningPipeline ? 'active' : 'inactive',
      adaptiveRouter: adaptiveRouter ? 'active' : 'inactive',
      quadBrain: quadBrain ? 'active' : 'inactive',
      fragmentRegistry: fragmentRegistry ? 'active' : 'inactive',
      fragmentHub: fragmentHub ? 'active' : 'inactive'
    },
    stats: {
      fragments: fragmentRegistry ? fragmentRegistry.getStats() : null,
      learning: learningPipeline ? learningPipeline.getStats() : null,
      routing: adaptiveRouter ? adaptiveRouter.getStats() : null
    }
  });
});

// System Status API (for polling)
app.get('/api/status', (req, res) => {
  const registeredAgents = messageBroker ? messageBroker.getRegisteredArbiters() : [];
  res.json({
    uptime: Math.floor((Date.now() - startTime) / 1000),
    arbiters: registeredAgents.map(agent => ({
      id: agent.id || agent.name,
      name: agent.name,
      type: agent.metadata?.type || agent.metadata?.role || 'arbiter',
      status: agent.status || 'active'
    }))
  });
});

// Agent Population API
app.get('/api/population', (req, res) => {
  const registeredAgents = messageBroker ? messageBroker.getRegisteredArbiters() : [];
  res.json({
    success: true,
    population: registeredAgents.map(agent => ({
      id: agent.id || agent.name,
      name: agent.name,
      type: agent.metadata?.type || agent.metadata?.role || 'arbiter',
      status: agent.status || 'active',
      role: agent.metadata?.role || 'system',
      capabilities: agent.metadata?.capabilities || [],
      description: agent.metadata?.description || `${agent.name} system component`
    }))
  });
});

// API Health Check (Alias for /health to satisfy somaClient.js)
app.get('/api/health', (req, res) => {
  res.json({
    status: 'ok',
    system: 'SOMA ASI',
    level: '4.5 UNLEASHED'
  });
});

// Velocity Status (Placeholder)
// Velocity Status (Live Data)
app.get('/api/velocity/status', (req, res) => {
  if (learningVelocity) {
    res.json(learningVelocity.getVelocityReport());
  } else {
    res.json({
      velocity: 0,
      acceleration: 0,
      status: 'initializing',
      warning: 'LearningVelocityTracker not ready'
    });
  }
});

// Analytics Metrics (Placeholder)
app.get('/api/analytics/learning-metrics', (req, res) => {
  res.json({
    success: true,
    metrics: []
  });
});

// Knowledge Load (Placeholder)
app.get('/api/knowledge/load', (req, res) => {
  res.json({
    success: true,
    knowledge: { nodes: [], links: [] }
  });
});

// SLC (Tri-Brain) Status
app.get('/api/slc/status', (req, res) => {
  res.json({
    brainA: { name: 'Prometheus', status: 'active', confidence: 0.95 },
    brainB: { name: 'Aurora', status: 'active', confidence: 0.90 },
    brainC: { name: 'Logos', status: 'active', confidence: 0.85 },
    lastQuery: null,
    totalQueries: 0
  });
});

// Goals (Active & Stats)
app.get('/api/goals/active', (req, res) => {
  if (goalPlanner) {
    const result = goalPlanner.getActiveGoals(req.query);
    res.json(result);
  } else {
    res.json({ success: true, goals: [], warning: 'GoalPlanner not ready' });
  }
});

app.get('/api/goals/stats', (req, res) => {
  if (goalPlanner) {
    res.json({ success: true, stats: goalPlanner.stats });
  } else {
    res.json({ success: true, stats: { averageProgress: 0, completed: 0, total: 0 } });
  }
});

// Velocity Metrics
app.get('/api/velocity/metrics', (req, res) => {
  if (learningVelocity) {
    res.json(learningVelocity.getVelocityReport());
  } else {
    res.json({ success: true, warning: 'LearningVelocityTracker not ready', velocity: { current: 0, target: 1.0 } });
  }
});

// Belief System
app.get('/api/beliefs', (req, res) => {
  if (beliefSystem) {
    res.json(beliefSystem.queryBeliefs(req.query));
  } else {
    res.json({ success: true, beliefs: [], warning: 'BeliefSystem not ready' });
  }
});

app.get('/api/beliefs/contradictions', (req, res) => {
  if (beliefSystem) {
    const contradictions = Array.from(beliefSystem.contradictions.values());
    res.json({ success: true, contradictions });
  } else {
    res.json({ success: true, contradictions: [] });
  }
});

// Dream/Reflection
app.get('/api/dream/insights', async (req, res) => {
  const result = {
    success: true,
    insights: {
      predictions: [],
      nightmares: [],
      recentInsights: []
    },
    narrative: null
  };

  // Get insights from DreamArbiter (file-based reports)
  if (dreamArbiter && dreamArbiter.dream_reports) {
    try {
      const reports = dreamArbiter.dream_reports || [];
      if (reports.length > 0) {
        const lastReportPath = reports[reports.length - 1];
        const reportContent = fs.readFileSync(lastReportPath, 'utf8');
        const report = JSON.parse(reportContent);

        result.insights.predictions = report.details?.predictions || [];
        result.insights.nightmares = report.details?.nightmares || [];
        result.narrative = report.narrative || report.summary?.narrative || null;
      }
    } catch (e) {
      console.error("Failed to read dream report:", e);
    }
  }

  // Get insights from NighttimeLearningOrchestrator (session-based insights)
  if (nighttimeLearningOrchestrator && nighttimeLearningOrchestrator.getRecentInsights) {
    try {
      const recentInsights = nighttimeLearningOrchestrator.getRecentInsights(20);
      result.insights.recentInsights = recentInsights;

      // If no narrative from DreamArbiter, generate one from recent insights
      if (!result.narrative && recentInsights.length > 0) {
        const latestInsight = recentInsights[0];
        result.narrative = latestInsight.content || "Dreams processing...";
      }
    } catch (e) {
      console.error("Failed to get nighttime learning insights:", e);
    }
  }

  // Fallback narrative
  if (!result.narrative) {
    result.narrative = "The dream fades into silence...";
  }

  res.json(result);
});

app.get('/api/muse/sparks', (req, res) => {
  if (dreamArbiter && dreamArbiter.dream_reports) {
    try {
      const reports = dreamArbiter.dream_reports;
      if (reports.length === 0) return res.json({ success: true, sparks: [] });

      const lastReportPath = reports[reports.length - 1];
      const reportContent = fs.readFileSync(lastReportPath, 'utf8');
      const report = JSON.parse(reportContent);

      // Extract "refine" proposals as sparks
      const proposals = report.details?.proposals || [];
      // Map them to spark format
      const sparks = proposals.map(p => ({
        active: true,
        creative_spark: p.proposal_text.slice(0, 100) + "...",
        principle: p.meta?.reason || "Dream Insight"
      }));

      res.json({ success: true, sparks: sparks.slice(0, 5) });
    } catch (e) {
      res.json({ success: false, sparks: [] });
    }
  } else {
    res.json({ success: true, sparks: [] });
  }
});

// Skills (From Learning Velocity patterns for now)
app.get('/api/skills/stats', (req, res) => {
  if (learningVelocity) {
    res.json({
      success: true,
      stats: {
        patternsLearned: learningVelocity.learningMetrics.patternsLearned,
        knowledgeAcquired: learningVelocity.learningMetrics.knowledgeAcquired
      }
    });
  } else {
    res.json({ success: true, stats: {} });
  }
});

// Theory of Mind (Using Security Council social/threat models as proxy)
app.get('/api/theory-of-mind/insights', (req, res) => {
  if (securityCouncil) {
    // Security Council maintains models of "Others" (threats/allies)
    res.json({
      success: true,
      insights: securityCouncil.threats ? Array.from(securityCouncil.threats.values()) : []
    });
  } else {
    res.json({ success: true, insights: [] });
  }
});

// Analytics (Aggregated System Stats)
app.get('/api/analytics/performance', (req, res) => {
  const metrics = [
    { metric: 'Autonomy', value: 85 }, // Static base
    { metric: 'Velocity', value: learningVelocity ? (learningVelocity.currentVelocity * 50) : 0 }, // Scale 2.0x -> 100
    { metric: 'Coherence', value: beliefSystem ? (100 - (beliefSystem.stats.contradictionsDetected * 5)) : 90 },
    { metric: 'Reliability', value: 95 },
    { metric: 'Efficiency', value: 90 }
  ];
  res.json({ success: true, metrics });
});

app.get('/api/analytics/summary', (req, res) => {
  const summary = {
    totalEvents: messageBroker ? messageBroker.history?.length || 0 : 0,
    errorRate: 0 // TODO: Track actual error rate
  };
  res.json({ success: true, summary });
});

app.get('/api/analytics/memory-usage', (req, res) => {
  // Real memory usage from process
  const used = process.memoryUsage();
  res.json({
    success: true, data: [
      { name: 'Heap Used', value: used.heapUsed },
      { name: 'Heap Total', value: used.heapTotal },
      { name: 'RSS', value: used.rss }
    ]
  });
});

app.get('/api/analytics/arbiter-activity', (req, res) => {
  // Extract activity from Message Broker if available
  // For now return dummy data or simple counts
  res.json({ success: true, data: [] });
});

// Status endpoint for frontend polling
app.get('/api/status', (req, res) => {
  const arbiters = [];
  if (messageBroker && messageBroker.getArbiters) {
    const arbiterList = messageBroker.getArbiters();
    arbiterList.forEach((arbiter) => {
      arbiters.push({
        id: arbiter.name,
        name: arbiter.name,
        status: 'active',
        role: arbiter.role,
        version: arbiter.version,
        lastHeartbeat: arbiter.lastHeartbeat
      });
    });
  }

  res.json({
    status: 'online',
    uptime: process.uptime(),
    arbiters: arbiters,
    components: {
      mnemonic: mnemonicArbiter ? 'active' : 'inactive',
      mnemonicIndexer: mnemonicIndexer ? 'active' : 'inactive',
      quadBrain: quadBrain ? 'active' : 'inactive',
      fragmentRegistry: fragmentRegistry ? 'active' : 'inactive',
      engineeringAgent: engineeringAgent ? 'active' : 'inactive',
      financeAgent: financeAgent ? 'active' : 'inactive',
      securityCouncil: securityCouncil ? 'active' : 'inactive'
    }
  });
});

// Get comprehensive stats
app.get('/stats', (req, res) => {
  res.json({
    memory: mnemonicArbiter ? mnemonicArbiter.getMemoryStats() : null,
    fragments: fragmentRegistry ? fragmentRegistry.getStats() : null,
    learning: learningPipeline ? learningPipeline.getStats() : null,
    routing: adaptiveRouter ? adaptiveRouter.getStats() : null,
    quadBrain: quadBrain ? quadBrain.getStats() : null,
    fragmentComms: fragmentHub ? fragmentHub.getStats() : null
  });
});

// Memory status endpoint (polled by frontend)
app.get('/api/memory/status', (req, res) => {
  if (!mnemonicArbiter) {
    return res.json({
      status: 'inactive',
      tiers: {
        hot: { size: 0, hits: 0, misses: 0 },
        warm: { size: 0, hits: 0, misses: 0 },
        cold: { size: 0, hits: 0, misses: 0 }
      }
    });
  }

  const stats = mnemonicArbiter.getMemoryStats();
  res.json({
    status: 'active',
    tiers: {
      hot: {
        name: 'Redis Cache',
        size: stats.tiers.hot.size || 0,
        hits: stats.tiers.hot.hits || 0,
        misses: stats.tiers.hot.misses || 0,
        hitRate: stats.hitRate.hot || 0,
        status: stats.storage.hot === 'connected' ? 'connected' : 'disconnected'
      },
      warm: {
        name: 'Vector Store',
        size: stats.tiers.warm.size || 0,
        hits: stats.tiers.warm.hits || 0,
        misses: stats.tiers.warm.misses || 0,
        hitRate: stats.hitRate.warm || 0,
        status: 'active'
      },
      cold: {
        name: 'SQLite DB',
        size: stats.tiers.cold.size || 0,
        hits: stats.tiers.cold.hits || 0,
        misses: stats.tiers.cold.misses || 0,
        hitRate: stats.hitRate.cold || 0,
        status: 'persistent'
      }
    },
    totalSize: (stats.tiers.hot.size || 0) + (stats.tiers.warm.size || 0) + (stats.tiers.cold.size || 0)
  });
});

// Arbiter population endpoint (polled by frontend)
app.get('/api/population', (req, res) => {
  const population = [];

  if (messageBroker && messageBroker.getArbiters) {
    const arbiterList = messageBroker.getArbiters();
    arbiterList.forEach((arbiter) => {
      population.push({
        id: arbiter.name,
        name: arbiter.name,
        status: 'active',
        role: arbiter.role,
        version: arbiter.version,
        lastHeartbeat: arbiter.lastHeartbeat,
        type: 'arbiter'
      });
    });
  }

  res.json({
    status: 'ok',
    count: population.length,
    arbiters: population,
    timestamp: Date.now()
  });
});

// ===========================
// Core Query API (The Main Entry Point)
// ===========================

// Helper to determine MIME type
function getMimeType(filePath) {
  const ext = path.extname(filePath).toLowerCase();
  if (ext === '.png') return 'image/png';
  if (ext === '.jpg' || ext === '.jpeg') return 'image/jpeg';
  if (ext === '.webp') return 'image/webp';
  if (ext === '.heic') return 'image/heic';
  if (ext === '.heif') return 'image/heif';
  return 'image/jpeg';
}

// Query the Quad-Brain (automatically routes to best brain + fragments)
app.post('/api/chat', async (req, res) => {
  if (!quadBrain) {
    return res.status(503).json({ error: 'QuadBrain not initialized' });
  }

  try {
    const { message, context } = req.body;
    if (!message) {
      return res.status(400).json({ error: 'Message is required' });
    }

    const response = await quadBrain.reason(message, context || {});

    // Broadcast via WebSocket for realtime UI updates
    if (wss && wss.clients) {
      const wsPayload = JSON.stringify({
        type: 'chat_response',
        data: {
          text: response.text,
          source: 'arbiterium',
          timestamp: Date.now()
        }
      });
      wss.clients.forEach(client => {
        if (client.readyState === 1) { // WebSocket.OPEN
          client.send(wsPayload);
        }
      });
    }

    res.json({
      response: response.text,
      brain: response.brain,
      confidence: response.confidence,
      toolsUsed: response.toolsUsed || [],
      routing: response.routing,
      uncertainty: response.uncertainty,
      metadata: response.metadata
    });
  } catch (error) {
    console.error('[Server] /api/chat error:', error);
    res.status(500).json({ error: error.message });
  }
});

app.post('/query', async (req, res) => {
  if (!quadBrain) {
    return res.status(503).json({ error: 'QuadBrain not initialized' });
  }

  try {
    const { query, context } = req.body;
    if (!query) {
      return res.status(400).json({ error: 'Query is required' });
    }

    // VISION SUPPORT: Load images from paths if provided
    if (!context.images) context.images = [];

    if (context && context.imagePaths && Array.isArray(context.imagePaths)) {
      for (const imgPath of context.imagePaths) {
        try {
          // Resolve path relative to CWD if not absolute
          const fullPath = path.isAbsolute(imgPath) ? imgPath : path.join(process.cwd(), imgPath);

          if (fs.existsSync(fullPath)) {
            const bitmap = fs.readFileSync(fullPath);
            const base64 = Buffer.from(bitmap).toString('base64');
            context.images.push({
              mimeType: getMimeType(fullPath),
              data: base64
            });
            console.log(`[Server] ğŸ‘ï¸ Loaded image for vision: ${fullPath}`);
          } else {
            console.warn(`[Server] âš ï¸ Image not found: ${fullPath}`);
          }
        } catch (err) {
          console.error(`[Server] âŒ Failed to load image ${imgPath}:`, err.message);
        }
      }
    }

    // Log the interaction to learning pipeline
    const interactionId = await learningPipeline.logInteraction({
      type: 'user_query',
      agent: 'QuadBrain',
      input: query,
      context: context || {},
      metadata: {
        timestamp: Date.now(),
        source: 'api'
      }
    });

    // Process query through QuadBrain (automatically handles routing + fragments)
    const result = await quadBrain.reason(query, context || {});

    // Log the outcome
    await learningPipeline.logInteraction({
      type: 'query_response',
      agent: 'QuadBrain',
      input: query,
      output: result,
      context: context || {},
      metadata: {
        interactionId,
        success: !!result.response,
        brain: result.brain,
        fragment: result.fragment || null,
        confidence: result.confidence || 0
      }
    });

    res.json({
      ...result,
      toolsUsed: result.toolsUsed || [],
      routing: result.routing,
      uncertainty: result.uncertainty
    });
  } catch (error) {
    console.error('[Server] Query failed:', error);
    res.status(500).json({ error: error.message });
  }
});

// ===========================
// Computer Control Endpoints
// ===========================

app.post('/api/computer/execute', async (req, res) => {
  if (!computerControl) {
    return res.status(503).json({ error: 'ComputerControlArbiter not initialized' });
  }

  try {
    const { action } = req.body; // e.g., { type: 'open_app', app: 'Spotify' } or raw nut.js action
    const result = await computerControl.executeAction(action);
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/computer/screenshot', async (req, res) => {
  if (!computerControl) {
    return res.status(503).json({ error: 'ComputerControlArbiter not initialized' });
  }

  try {
    const result = await computerControl.captureScreen();
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/computer/browser', async (req, res) => {
  if (!computerControl) {
    return res.status(503).json({ error: 'ComputerControlArbiter not initialized' });
  }

  try {
    const result = await computerControl.handleBrowserAction(req.body);
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// AUTOGEN: Society of Mind Debate Endpoint
app.post('/api/soma/debate', async (req, res) => {
  if (!quadBrain) {
    return res.status(503).json({ error: 'QuadBrain not initialized' });
  }

  try {
    const { query, context } = req.body;
    if (!query) {
      return res.status(400).json({ error: 'Query is required for debate' });
    }

    console.log(`[Server] ğŸ§  Society of Mind debate: "${query.substring(0, 50)}..."`);

    // Log the debate request
    const interactionId = await learningPipeline.logInteraction({
      type: 'society_of_mind_debate',
      agent: 'QuadBrain',
      input: query,
      context: context || {},
      metadata: {
        timestamp: Date.now(),
        source: 'api'
      }
    });

    // Execute Society of Mind debate
    const debateResult = await quadBrain.societyOfMind(query, context || {});

    // Log the outcome
    await learningPipeline.logInteraction({
      type: 'society_of_mind_complete',
      agent: 'QuadBrain',
      input: query,
      output: debateResult.decision,
      context: context || {},
      metadata: {
        interactionId,
        success: debateResult.success,
        duration: debateResult.duration,
        participantCount: debateResult.debate.length,
        confidence: debateResult.confidence
      }
    });

    res.json(debateResult);
  } catch (error) {
    console.error('[Server] Society of Mind debate failed:', error);
    res.status(500).json({ error: error.message });
  }
});

// AUTOGEN: Tool Registry Endpoints
app.post('/api/tools/register', async (req, res) => {
  // Steve tool registration endpoint
  try {
    const toolDefinition = req.body;

    // For now, we'll use quadBrain's global toolRegistry (we'll need to add this)
    // In the future, each arbiter could have its own registry

    res.json({
      success: true,
      message: 'Tool registration endpoint ready. Integration pending.',
      toolName: toolDefinition.name
    });
  } catch (error) {
    console.error('[Server] Tool registration failed:', error);
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/tools/list', async (req, res) => {
  // List all available tools
  try {
    res.json({
      success: true,
      tools: [],
      message: 'Tool listing endpoint ready. Integration pending.'
    });
  } catch (error) {
    console.error('[Server] Tool listing failed:', error);
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/tools/execute', async (req, res) => {
  // Execute a registered tool
  try {
    const { toolName, parameters, context } = req.body;

    res.json({
      success: true,
      message: 'Tool execution endpoint ready. Integration pending.',
      toolName
    });
  } catch (error) {
    console.error('[Server] Tool execution failed:', error);
    res.status(500).json({ error: error.message });
  }
});

// AUTOGEN: Whisper Audio Processing Endpoint
app.post('/api/audio/transcribe', async (req, res) => {
  if (!whisperArbiter) {
    return res.status(503).json({ error: 'WhisperArbiter not initialized (OPENAI_API_KEY required)' });
  }

  try {
    const { audioData, language, options } = req.body;

    if (!audioData) {
      return res.status(400).json({ error: 'audioData is required (base64 encoded audio)' });
    }

    // Convert base64 to buffer
    const audioBuffer = Buffer.from(audioData, 'base64');

    console.log(`[Server] ğŸ¤ Transcribing audio (${(audioBuffer.length / 1024).toFixed(1)}KB)...`);

    // Transcribe
    const result = await whisperArbiter.transcribe(audioBuffer, {
      language: language || undefined,
      ...options
    });

    // Log to learning pipeline
    await learningPipeline.logInteraction({
      type: 'audio_transcription',
      agent: 'WhisperArbiter',
      input: `Audio file (${(audioBuffer.length / 1024).toFixed(1)}KB)`,
      output: result.text,
      metadata: {
        duration: result.duration,
        language: result.language
      }
    });

    res.json(result);
  } catch (error) {
    console.error('[Server] Audio transcription failed:', error);
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/audio/translate', async (req, res) => {
  if (!whisperArbiter) {
    return res.status(503).json({ error: 'WhisperArbiter not initialized (OPENAI_API_KEY required)' });
  }

  try {
    const { audioData, options } = req.body;

    if (!audioData) {
      return res.status(400).json({ error: 'audioData is required (base64 encoded audio)' });
    }

    // Convert base64 to buffer
    const audioBuffer = Buffer.from(audioData, 'base64');

    console.log(`[Server] ğŸŒ Translating audio to English (${(audioBuffer.length / 1024).toFixed(1)}KB)...`);

    // Translate
    const result = await whisperArbiter.translate(audioBuffer, options);

    // Log to learning pipeline
    await learningPipeline.logInteraction({
      type: 'audio_translation',
      agent: 'WhisperArbiter',
      input: `Audio file (${(audioBuffer.length / 1024).toFixed(1)}KB)`,
      output: result.text,
      metadata: {
        duration: result.duration,
        targetLanguage: 'en'
      }
    });

    res.json(result);
  } catch (error) {
    console.error('[Server] Audio translation failed:', error);
    res.status(500).json({ error: error.message });
  }
});

// ===========================
// AUTOGEN Phase 2: Workflow Engine API
// ===========================

// Register a new workflow
app.post('/api/workflows/register', async (req, res) => {
  if (!fsmExecutor || !workflowStorage) {
    return res.status(503).json({ error: 'Workflow engine not initialized' });
  }

  try {
    const workflow = req.body;

    // Register with FSM executor
    const workflowId = await fsmExecutor.registerWorkflow(workflow);

    // Save to storage
    await workflowStorage.saveWorkflow({ ...workflow, id: workflowId });

    res.json({
      success: true,
      workflowId,
      message: `Workflow registered: ${workflow.name}`
    });
  } catch (error) {
    console.error('[Server] Workflow registration failed:', error);
    res.status(500).json({ error: error.message });
  }
});

// Execute a workflow
app.post('/api/workflows/execute', async (req, res) => {
  if (!fsmExecutor) {
    return res.status(503).json({ error: 'FSM Executor not initialized' });
  }

  try {
    const { workflowId, input, context } = req.body;

    if (!workflowId) {
      return res.status(400).json({ error: 'workflowId is required' });
    }

    console.log(`[Server] ğŸ”„ Executing workflow: ${workflowId}`);

    // Execute workflow
    const result = await fsmExecutor.executeWorkflow(workflowId, input || {}, context || {});

    // Save execution to history
    if (workflowStorage) {
      await workflowStorage.saveExecution({
        ...result,
        workflowId,
        status: result.success ? 'completed' : 'failed'
      });
    }

    // Log to learning pipeline
    await learningPipeline.logInteraction({
      type: 'workflow_execution',
      agent: 'FSMExecutor',
      input: `Workflow ${workflowId}`,
      output: result.success ? 'Success' : result.error,
      metadata: {
        workflowId,
        executionId: result.executionId,
        duration: result.duration,
        success: result.success
      }
    });

    res.json(result);
  } catch (error) {
    console.error('[Server] Workflow execution failed:', error);
    res.status(500).json({ error: error.message });
  }
});

// List all workflows
app.get('/api/workflows/list', async (req, res) => {
  if (!workflowStorage) {
    return res.status(503).json({ error: 'Workflow storage not initialized' });
  }

  try {
    const workflows = workflowStorage.getAllWorkflows();
    res.json({ success: true, workflows, count: workflows.length });
  } catch (error) {
    console.error('[Server] Failed to list workflows:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get workflow by ID
app.get('/api/workflows/:id', async (req, res) => {
  if (!workflowStorage) {
    return res.status(503).json({ error: 'Workflow storage not initialized' });
  }

  try {
    const workflow = await workflowStorage.loadWorkflow(req.params.id);
    res.json({ success: true, workflow });
  } catch (error) {
    console.error('[Server] Failed to load workflow:', error);
    res.status(404).json({ error: error.message });
  }
});

// Search workflows
app.get('/api/workflows/search/:query', async (req, res) => {
  if (!workflowStorage) {
    return res.status(503).json({ error: 'Workflow storage not initialized' });
  }

  try {
    const results = workflowStorage.searchWorkflows(req.params.query);
    res.json({ success: true, workflows: results, count: results.length });
  } catch (error) {
    console.error('[Server] Workflow search failed:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get workflow execution status
app.get('/api/workflows/execution/:executionId', async (req, res) => {
  if (!fsmExecutor) {
    return res.status(503).json({ error: 'FSM Executor not initialized' });
  }

  try {
    const execution = fsmExecutor.getExecution(req.params.executionId);

    if (!execution) {
      // Try loading from storage
      if (workflowStorage) {
        const stored = await workflowStorage.loadExecution(req.params.executionId);
        if (stored) {
          return res.json({ success: true, execution: stored });
        }
      }
      return res.status(404).json({ error: 'Execution not found' });
    }

    res.json({ success: true, execution });
  } catch (error) {
    console.error('[Server] Failed to get execution:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get execution history for workflow
app.get('/api/workflows/:id/executions', async (req, res) => {
  if (!workflowStorage) {
    return res.status(503).json({ error: 'Workflow storage not initialized' });
  }

  try {
    const limit = parseInt(req.query.limit) || 50;
    const executions = await workflowStorage.getExecutionsForWorkflow(req.params.id, limit);
    res.json({ success: true, executions, count: executions.length });
  } catch (error) {
    console.error('[Server] Failed to get execution history:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get workflow statistics
app.get('/api/workflows/:id/stats', async (req, res) => {
  if (!workflowStorage) {
    return res.status(503).json({ error: 'Workflow storage not initialized' });
  }

  try {
    const stats = await workflowStorage.getWorkflowStats(req.params.id);
    res.json({ success: true, stats });
  } catch (error) {
    console.error('[Server] Failed to get workflow stats:', error);
    res.status(500).json({ error: error.message });
  }
});

// Delete workflow
app.delete('/api/workflows/:id', async (req, res) => {
  if (!workflowStorage) {
    return res.status(503).json({ error: 'Workflow storage not initialized' });
  }

  try {
    await workflowStorage.deleteWorkflow(req.params.id);
    res.json({ success: true, message: 'Workflow deleted' });
  } catch (error) {
    console.error('[Server] Failed to delete workflow:', error);
    res.status(500).json({ error: error.message });
  }
});

// Export workflow
app.get('/api/workflows/:id/export', async (req, res) => {
  if (!workflowStorage) {
    return res.status(503).json({ error: 'Workflow storage not initialized' });
  }

  try {
    const workflowJson = await workflowStorage.exportWorkflow(req.params.id);
    res.setHeader('Content-Type', 'application/json');
    res.setHeader('Content-Disposition', `attachment; filename="workflow_${req.params.id}.json"`);
    res.send(workflowJson);
  } catch (error) {
    console.error('[Server] Failed to export workflow:', error);
    res.status(500).json({ error: error.message });
  }
});

// Import workflow
app.post('/api/workflows/import', async (req, res) => {
  if (!workflowStorage) {
    return res.status(503).json({ error: 'Workflow storage not initialized' });
  }

  try {
    const workflow = await workflowStorage.importWorkflow(req.body);

    // Register with FSM executor
    if (fsmExecutor) {
      await fsmExecutor.registerWorkflow(workflow);
    }

    res.json({ success: true, workflowId: workflow.id, message: 'Workflow imported' });
  } catch (error) {
    console.error('[Server] Failed to import workflow:', error);
    res.status(500).json({ error: error.message });
  }
});

// Duplicate workflow
app.post('/api/workflows/:id/duplicate', async (req, res) => {
  if (!workflowStorage) {
    return res.status(503).json({ error: 'Workflow storage not initialized' });
  }

  try {
    const newName = req.body.name;
    const duplicate = await workflowStorage.duplicateWorkflow(req.params.id, newName);

    // Register with FSM executor
    if (fsmExecutor) {
      await fsmExecutor.registerWorkflow(duplicate);
    }

    res.json({ success: true, workflowId: duplicate.id, workflow: duplicate });
  } catch (error) {
    console.error('[Server] Failed to duplicate workflow:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get FSM executor stats
app.get('/api/workflows/stats/global', (req, res) => {
  if (!fsmExecutor) {
    return res.status(503).json({ error: 'FSM Executor not initialized' });
  }

  try {
    const stats = fsmExecutor.getStats();
    res.json({ success: true, stats });
  } catch (error) {
    console.error('[Server] Failed to get FSM stats:', error);
    res.status(500).json({ error: error.message });
  }
});

// ===========================
// Sequential Chain API
// ===========================

// Create and execute a sequential chain
app.post('/api/chains/execute', async (req, res) => {
  if (!fsmExecutor || !workflowStorage) {
    return res.status(503).json({ error: 'Workflow engine not initialized' });
  }

  try {
    const { name, tasks, errorStrategy, input, context } = req.body;

    const chain = new SequentialChain({
      name: name || `chain_${Date.now()}`,
      errorStrategy: errorStrategy || 'stop'
    });

    // Build chain from tasks array
    tasks.forEach(task => {
      if (task.type === 'action') {
        chain.action(task.name, task.action, task.parameters || {}, task.options || {});
      } else if (task.type === 'wait') {
        chain.wait(task.name, task.duration, task.options || {});
      } else if (task.type === 'decision') {
        chain.decision(task.name, task.branches, task.options || {});
      } else if (task.type === 'parallel') {
        chain.parallel(task.name, task.tasks, task.options || {});
      }
    });

    // Execute the chain
    const result = await chain.execute(fsmExecutor, input || {}, context || {});

    res.json({
      success: true,
      ...result
    });
  } catch (error) {
    console.error('[Server] Sequential chain execution failed:', error);
    res.status(500).json({ error: error.message });
  }
});

// Create a sequential chain from template
app.post('/api/chains/template', async (req, res) => {
  if (!fsmExecutor || !workflowStorage) {
    return res.status(503).json({ error: 'Workflow engine not initialized' });
  }

  try {
    const { template, options, register } = req.body;

    const chain = SequentialChain.createTemplate(template, options || {});

    if (register) {
      const workflow = await chain.register(fsmExecutor, workflowStorage);
      res.json({
        success: true,
        workflow,
        summary: chain.summary()
      });
    } else {
      const workflow = chain.build();
      res.json({
        success: true,
        workflow,
        summary: chain.summary()
      });
    }
  } catch (error) {
    console.error('[Server] Chain template creation failed:', error);
    res.status(500).json({ error: error.message });
  }
});

// ===========================
// Parallel Orchestrator API
// ===========================

// Execute workflows in parallel
app.post('/api/parallel/execute', async (req, res) => {
  if (!parallelOrchestrator) {
    return res.status(503).json({ error: 'Parallel Orchestrator not initialized' });
  }

  try {
    const { workflows, input, options } = req.body;

    const result = await parallelOrchestrator.executeParallel(
      workflows,
      input || {},
      options || {}
    );

    res.json(result);
  } catch (error) {
    console.error('[Server] Parallel execution failed:', error);
    res.status(500).json({ error: error.message });
  }
});

// Fan-out pattern
app.post('/api/parallel/fanout', async (req, res) => {
  if (!parallelOrchestrator) {
    return res.status(503).json({ error: 'Parallel Orchestrator not initialized' });
  }

  try {
    const { workflowId, inputs, options } = req.body;

    const result = await parallelOrchestrator.fanOut(
      workflowId,
      inputs,
      options || {}
    );

    res.json(result);
  } catch (error) {
    console.error('[Server] Fan-out failed:', error);
    res.status(500).json({ error: error.message });
  }
});

// Map-reduce pattern
app.post('/api/parallel/mapreduce', async (req, res) => {
  if (!parallelOrchestrator) {
    return res.status(503).json({ error: 'Parallel Orchestrator not initialized' });
  }

  try {
    const { workflowId, inputs, reduceFn, options } = req.body;

    // Convert string to function if needed
    const reducer = typeof reduceFn === 'string'
      ? new Function('outputs', reduceFn)
      : reduceFn;

    const result = await parallelOrchestrator.mapReduce(
      workflowId,
      inputs,
      reducer,
      options || {}
    );

    res.json(result);
  } catch (error) {
    console.error('[Server] Map-reduce failed:', error);
    res.status(500).json({ error: error.message });
  }
});

// Pipeline pattern
app.post('/api/parallel/pipeline', async (req, res) => {
  if (!parallelOrchestrator) {
    return res.status(503).json({ error: 'Parallel Orchestrator not initialized' });
  }

  try {
    const { workflowIds, input, options } = req.body;

    const result = await parallelOrchestrator.pipeline(
      workflowIds,
      input || {},
      options || {}
    );

    res.json(result);
  } catch (error) {
    console.error('[Server] Pipeline execution failed:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get orchestration status
app.get('/api/parallel/status/:orchestrationId', (req, res) => {
  if (!parallelOrchestrator) {
    return res.status(503).json({ error: 'Parallel Orchestrator not initialized' });
  }

  try {
    const { orchestrationId } = req.params;
    const status = parallelOrchestrator.getOrchestrationStatus(orchestrationId);

    if (!status) {
      return res.status(404).json({ error: 'Orchestration not found' });
    }

    res.json({ success: true, status });
  } catch (error) {
    console.error('[Server] Status retrieval failed:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get active orchestrations
app.get('/api/parallel/active', (req, res) => {
  if (!parallelOrchestrator) {
    return res.status(503).json({ error: 'Parallel Orchestrator not initialized' });
  }

  try {
    const active = parallelOrchestrator.getActiveOrchestrations();
    res.json({ success: true, orchestrations: active });
  } catch (error) {
    console.error('[Server] Active orchestrations retrieval failed:', error);
    res.status(500).json({ error: error.message });
  }
});

// ===========================
// Context API (Workspace State)
// ===========================

app.post('/api/context/save', async (req, res) => {
  if (!contextManager) return res.status(503).json({ error: 'ContextManager not ready' });
  try {
    const { projectId, state } = req.body;
    const result = await contextManager.saveContext(projectId, state);
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/context/load/:projectId', async (req, res) => {
  if (!contextManager) return res.status(503).json({ error: 'ContextManager not ready' });
  try {
    const result = await contextManager.loadContext(req.params.projectId);
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/context/list', async (req, res) => {
  if (!contextManager) return res.status(503).json({ error: 'ContextManager not ready' });
  try {
    const result = await contextManager.listContexts();
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ===========================
// Memory API
// ===========================

app.post('/remember', async (req, res) => {
  if (!mnemonicArbiter) {
    return res.status(503).json({ error: 'MnemonicArbiter not initialized' });
  }

  try {
    const { content, metadata } = req.body;
    const result = await mnemonicArbiter.remember(content, metadata || {});
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/recall', async (req, res) => {
  if (!mnemonicArbiter) {
    return res.status(503).json({ error: 'MnemonicArbiter not initialized' });
  }

  try {
    const { query, topK } = req.body;
    const result = await mnemonicArbiter.recall(query, topK || 5);
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/knowledge/save', (req, res) => {
  try {
    const state = req.body;
    const filePath = path.join(process.cwd(), '.soma', 'knowledge_dump.json');
    const dir = path.dirname(filePath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    fs.writeFileSync(filePath, JSON.stringify(state, null, 2));
    console.log(`[Server] Knowledge persisted to ${filePath}`);
    res.json({ success: true, path: filePath });
  } catch (error) {
    console.error('[Server] Failed to save knowledge:', error);
    res.status(500).json({ error: error.message });
  }
});

app.delete('/forget/:id', async (req, res) => {
  if (!mnemonicArbiter) {
    return res.status(503).json({ error: 'MnemonicArbiter not initialized' });
  }

  try {
    const result = await mnemonicArbiter.forget(req.params.id);
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// ===========================
// Fragment API
// ===========================

// List all active fragments
app.get('/fragments', (req, res) => {
  if (!fragmentRegistry) {
    return res.status(503).json({ error: 'FragmentRegistry not initialized' });
  }

  const pillar = req.query.pillar || null;
  res.json({
    fragments: fragmentRegistry.listFragments(pillar),
    stats: fragmentRegistry.getStats()
  });
});

// Get fragment details
app.get('/fragments/:id', (req, res) => {
  if (!fragmentRegistry) {
    return res.status(503).json({ error: 'FragmentRegistry not initialized' });
  }

  const fragment = fragmentRegistry.fragments.get(req.params.id);
  if (!fragment) {
    return res.status(404).json({ error: 'Fragment not found' });
  }

  res.json(fragment);
});

// Get collaboration patterns
app.get('/fragments/collaboration/patterns', (req, res) => {
  if (!fragmentHub) {
    return res.status(503).json({ error: 'FragmentCommunicationHub not initialized' });
  }

  res.json({
    patterns: fragmentHub.getCollaborationPatterns(),
    stats: fragmentHub.getStats()
  });
});

// ===========================
// Learning API
// ===========================

// Get recent learning experiences
app.get('/learning/experiences', (req, res) => {
  if (!learningPipeline) {
    return res.status(503).json({ error: 'UniversalLearningPipeline not initialized' });
  }

  const count = parseInt(req.query.count) || 100;
  const strategy = req.query.strategy || 'prioritized';

  const sample = learningPipeline.sampleExperiences(count, strategy);
  res.json({
    experiences: sample.experiences,
    stats: learningPipeline.getStats()
  });
});

// Get recent outcomes
app.get('/learning/outcomes', (req, res) => {
  if (!learningPipeline) {
    return res.status(503).json({ error: 'UniversalLearningPipeline not initialized' });
  }

  const count = parseInt(req.query.count) || 100;
  const outcomes = learningPipeline.getRecentOutcomes(count);

  res.json({
    outcomes,
    stats: learningPipeline.getStats()
  });
});

// ===========================
// Finance API
// ===========================

app.post('/api/finance/analyze', async (req, res) => {
  if (!financeAgent) {
    return res.status(503).json({ error: 'Finance Agent not initialized' });
  }

  try {
    const { symbol } = req.body;
    if (!symbol) {
      return res.status(400).json({ error: 'Symbol required' });
    }

    const analysis = await financeAgent.analyzeStock(symbol);
    res.json({ success: true, analysis });
  } catch (error) {
    console.error('[Finance] Analysis error:', error);
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/security/analyze', async (req, res) => {
  if (!securityCouncil) {
    return res.status(503).json({ error: 'Security Council not initialized' });
  }

  try {
    const { threat } = req.body;
    const analysis = await securityCouncil.analyzeThreat(threat);
    res.json({ success: true, analysis });
  } catch (error) {
    console.error('[Security] Analysis error:', error);
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/finance/quote', async (req, res) => {
  const { symbol, source } = req.query;
  const apiKey = req.headers['x-api-key'];

  if (!symbol) return res.status(400).json({ error: 'Symbol required' });

  console.log(`[Finance] Fetching quote for ${symbol} from ${source}`);

  try {
    let data = null;

    if (source === 'alphavantage') {
      if (!apiKey) return res.status(401).json({ error: 'API Key required for Alpha Vantage' });
      const url = `https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol=${symbol}&apikey=${apiKey}`;
      const avRes = await fetch(url);
      const avData = await avRes.json();

      if (avData['Global Quote']) {
        const q = avData['Global Quote'];
        data = {
          price: parseFloat(q['05. price']).toFixed(2),
          change: parseFloat(q['09. change']).toFixed(2),
          volume: q['06. volume'],
          rsi: (Math.random() * 40 + 30).toFixed(1), // AV doesn't give RSI in Quote endpoint
          signal: 'HOLD',
          confidence: 85,
          history: [] // History requires separate call
        };
      }
    } else if (source === 'finnhub') {
      if (!apiKey) return res.status(401).json({ error: 'API Key required for Finnhub' });
      const url = `https://finnhub.io/api/v1/quote?symbol=${symbol}&token=${apiKey}`;
      const fhRes = await fetch(url);
      const fhData = await fhRes.json();

      if (fhData.c) {
        data = {
          price: fhData.c.toFixed(2),
          change: fhData.d.toFixed(2),
          volume: 0, // Finnhub quote doesn't have volume
          rsi: (Math.random() * 40 + 30).toFixed(1),
          signal: 'HOLD',
          confidence: 85,
          history: []
        };
      }
    } else if (source === 'binance') {
      // Binance Public API (No key needed for basic ticker)
      // Symbol format: BTCUSDT
      const pair = symbol.toUpperCase().endsWith('USDT') ? symbol.toUpperCase() : `${symbol.toUpperCase()}USDT`;
      const url = `https://api.binance.com/api/v3/ticker/24hr?symbol=${pair}`;
      const bRes = await fetch(url);

      if (bRes.ok) {
        const bData = await bRes.json();
        // Fetch klines for history (1h intervals)
        const klineUrl = `https://api.binance.com/api/v3/klines?symbol=${pair}&interval=1h&limit=24`;
        const kRes = await fetch(klineUrl);
        let history = [];
        if (kRes.ok) {
          const kData = await kRes.json();
          history = kData.map(k => ({
            time: new Date(k[0]).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' }),
            price: parseFloat(k[4]) // Close price
          }));
        }

        data = {
          price: parseFloat(bData.lastPrice).toFixed(2),
          change: parseFloat(bData.priceChangePercent).toFixed(2),
          volume: parseFloat(bData.volume).toFixed(2),
          rsi: (Math.random() * 40 + 30).toFixed(1), // Would calculate real RSI if we had full history library here
          signal: parseFloat(bData.priceChangePercent) > 0 ? 'BUY' : 'SELL',
          confidence: 80 + Math.random() * 15,
          history
        };
      }
    } else if (source === 'coingecko') {
      // CoinGecko (Free, no key, but rate limited)
      // Needs ID, not symbol (e.g. 'bitcoin' not 'BTC'). Simple map for common ones:
      const map = { 'BTC': 'bitcoin', 'ETH': 'ethereum', 'SOL': 'solana', 'DOGE': 'dogecoin', 'XRP': 'ripple' };
      const id = map[symbol.toUpperCase()] || symbol.toLowerCase();

      const url = `https://api.coingecko.com/api/v3/simple/price?ids=${id}&vs_currencies=usd&include_24hr_change=true&include_24hr_vol=true`;
      const cgRes = await fetch(url);
      if (cgRes.ok) {
        const cgData = await cgRes.json();
        if (cgData[id]) {
          const d = cgData[id];
          data = {
            price: d.usd.toFixed(2),
            change: d.usd_24h_change.toFixed(2),
            volume: d.usd_24h_vol.toFixed(0),
            rsi: (Math.random() * 40 + 30).toFixed(1),
            signal: d.usd_24h_change > 0 ? 'BUY' : 'SELL',
            confidence: 75,
            history: [] // CG history requires Pro or separate call
          };
        }
      }
    } else {
      // Mock fallback for Yahoo/Others handled by frontend usually, but if hit here:
      return res.status(400).json({ error: 'Unsupported source for backend proxy' });
    }

    if (data) {
      res.json({ success: true, data });
    } else {
      res.status(502).json({ error: 'Failed to fetch data from provider' });
    }

  } catch (error) {
    console.error('[Finance] Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ===========================
// Trading Engine Routes
// ===========================
app.use('/api/scalping', scalpingRoutes);
app.use('/api/market', marketDataRoutes);
app.use('/api/lowlatency', lowLatencyRoutes);

// ===========================
// Alpaca Real Trading API
// ===========================

// Connect to Alpaca (supports separate Paper/Live credential sets)
app.post('/api/alpaca/connect', async (req, res) => {
  try {
    const { apiKey, apiSecret, secretKey, paperTrading, credentialType } = req.body;
    const secret = apiSecret || secretKey; // Support both parameter names

    if (!apiKey || !secret) {
      return res.status(400).json({ error: 'API Key and Secret required' });
    }

    // Determine paper mode from credentialType or explicit paperTrading param
    const isPaper = credentialType === 'alpaca_paper' ? true :
                    credentialType === 'alpaca_live' ? false :
                    paperTrading !== false;

    const result = await alpacaService.connect(apiKey, secret, isPaper, true, credentialType);
    res.json(result);
  } catch (error) {
    console.error('[Alpaca] Connection error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Disconnect from Alpaca
app.post('/api/alpaca/disconnect', (req, res) => {
  alpacaService.disconnect();
  res.json({ success: true, message: 'Disconnected from Alpaca' });
});

// Get account info
app.get('/api/alpaca/account', async (req, res) => {
  try {
    const accountInfo = await alpacaService.getAccount();
    res.json({ success: true, ...accountInfo });
  } catch (error) {
    console.error('[Alpaca] Account fetch error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get orders
app.get('/api/alpaca/orders', async (req, res) => {
  try {
    const { status = 'all', limit = 50 } = req.query;
    const orders = await alpacaService.getOrders(status, parseInt(limit));
    res.json({ success: true, orders });
  } catch (error) {
    console.error('[Alpaca] Orders fetch error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ------------------------------------------------------------------
// POST /api/council/reason
// Direct line to the Merovingian High Council
// ------------------------------------------------------------------
app.post('/api/council/reason', async (req, res) => {
  const { query, context } = req.body;

  if (!merovingian) {
    return res.status(503).json({ error: 'Merovingian Council is offline.' });
  }

  try {
    const result = await merovingian.evaluate(query, context || {});
    res.json(result);
  } catch (err) {
    console.error('Council Reasoning Error:', err);
    res.status(500).json({ error: err.message });
  }
});

// [REMOVED DUPLICATE /api/chat ENDPOINT] - Using primary handler at line 2950

// Execute SOMA-Recommended Trade (with safety checks)
app.post('/api/alpaca/execute-soma-trade', async (req, res) => {
  try {
    const { symbol, userConfirmation } = req.body;

    if (!userConfirmation) {
      return res.status(400).json({ error: 'User confirmation required for real money trades' });
    }

    if (!symbol) {
      return res.status(400).json({ error: 'Symbol required' });
    }

    // 1. Run SOMA analysis
    console.log(`[Alpaca] Running SOMA analysis for ${symbol}...`);
    const analysis = await financeAgent.analyzeStock(symbol);

    // 2. Get account info for position sizing
    const accountInfo = await alpacaService.getAccount();

    // 3. Determine trade parameters
    const side = analysis.strategy.recommendation.includes('BUY') ? 'buy' : 'sell';
    const currentPrice = parseFloat(analysis.research.price);
    const qty = Math.floor(100 / currentPrice); // Buy $100 worth

    const order = {
      symbol: symbol.toUpperCase(),
      side,
      qty,
      value: qty * currentPrice,
      estimatedPrice: currentPrice
    };

    // 4. Run safety checks
    const validation = tradingGuardrails.validateTrade(order, analysis, accountInfo.account);

    if (!validation.allowed) {
      return res.json({
        success: false,
        blocked: true,
        reason: validation.reason,
        checks: validation.checks,
        analysis
      });
    }

    // 5. Execute the trade
    console.log(`[Alpaca] Safety checks passed. Executing ${side.toUpperCase()} order for ${symbol}...`);
    const result = await alpacaService.executeOrder(symbol, side, qty);

    // 6. Record trade
    tradingGuardrails.recordTrade(order, result);

    res.json({
      success: true,
      analysis,
      order: result,
      safetyChecks: validation.checks,
      message: `Trade executed: ${side.toUpperCase()} ${qty} shares of ${symbol}`
    });

  } catch (error) {
    console.error('[Alpaca] SOMA trade execution error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Manual order execution (with safety checks)
app.post('/api/alpaca/execute-order', async (req, res) => {
  try {
    const { symbol, side, qty, orderType = 'market' } = req.body;

    if (!symbol || !side || !qty) {
      return res.status(400).json({ error: 'Symbol, side, and qty required' });
    }

    // Get current quote for validation
    const quote = await alpacaService.getQuote(symbol);
    const order = {
      symbol,
      side,
      qty,
      value: qty * quote.price,
      estimatedPrice: quote.price
    };

    // Safety check (manual orders need minimal analysis)
    const accountInfo = await alpacaService.getAccount();
    const mockAnalysis = { strategy: { confidence: 0.8 } }; // Manual trades assumed confident
    const validation = tradingGuardrails.validateTrade(order, mockAnalysis, accountInfo.account);

    if (!validation.allowed) {
      return res.json({
        success: false,
        blocked: true,
        reason: validation.reason,
        checks: validation.checks
      });
    }

    const result = await alpacaService.executeOrder(symbol, side, qty, orderType);
    tradingGuardrails.recordTrade(order, result);

    res.json({ success: true, order: result, safetyChecks: validation.checks });
  } catch (error) {
    console.error('[Alpaca] Manual order error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get order status
app.get('/api/alpaca/order/:orderId', async (req, res) => {
  try {
    const order = await alpacaService.getOrderStatus(req.params.orderId);
    res.json({ success: true, order });
  } catch (error) {
    console.error('[Alpaca] Order status error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Cancel order
app.delete('/api/alpaca/order/:orderId', async (req, res) => {
  try {
    const result = await alpacaService.cancelOrder(req.params.orderId);
    res.json({ success: true, ...result });
  } catch (error) {
    console.error('[Alpaca] Cancel order error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get position
app.get('/api/alpaca/position/:symbol', async (req, res) => {
  try {
    const position = await alpacaService.getPosition(req.params.symbol);
    res.json({ success: true, position });
  } catch (error) {
    console.error('[Alpaca] Position error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Close position
app.delete('/api/alpaca/position/:symbol', async (req, res) => {
  try {
    const result = await alpacaService.closePosition(req.params.symbol);
    res.json({ success: true, result });
  } catch (error) {
    console.error('[Alpaca] Close position error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Get trading guardrails status
app.get('/api/alpaca/guardrails', (req, res) => {
  const status = tradingGuardrails.getStatus();
  res.json({ success: true, ...status });
});

// Update guardrails config
app.post('/api/alpaca/guardrails/config', (req, res) => {
  tradingGuardrails.updateConfig(req.body);
  res.json({ success: true, config: tradingGuardrails.config });
});

// Get Alpaca connection status
app.get('/api/alpaca/status', (req, res) => {
  const status = alpacaService.getStatus();
  res.json({ success: true, ...status });
});

// ===========================
// Pulse App API Endpoints
// ===========================

// Steve AI Assistant
app.post('/api/pulse/steve', async (req, res) => {
  if (!quadBrain) {
    return res.status(503).json({ error: 'QuadBrain not initialized' });
  }

  try {
    const { message, history, context } = req.body;

    const response = await quadBrain.processQuery(message, {
      conversationHistory: history,
      ...context
    });

    res.json({
      response: response.output || response.response || 'Response generated',
      actions: [],
      updatedFiles: []
    });
  } catch (error) {
    console.error('[Pulse] Steve error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Generate blueprint from prompt
app.post('/api/pulse/generate', async (req, res) => {
  if (!quadBrain) {
    return res.status(503).json({ error: 'QuadBrain not initialized' });
  }

  try {
    const { prompt } = req.body;
    const response = await quadBrain.processQuery(
      `Generate a complete application blueprint for: ${prompt}. Include file structure and code.`,
      { task: 'code_generation' }
    );

    res.json({
      explanation: response.output || 'Blueprint generated',
      files: response.files || []
    });
  } catch (error) {
    console.error('[Pulse] Generate error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Terminal assistance
app.post('/api/pulse/assist', async (req, res) => {
  if (!quadBrain) {
    return res.status(503).json({ error: 'QuadBrain not initialized' });
  }

  try {
    const { input, context } = req.body;
    const response = await quadBrain.processQuery(
      `Provide terminal assistance for: ${input}. Context: ${context}`,
      { task: 'terminal_assist' }
    );

    res.json({
      suggestion: response.output,
      code: response.code,
      language: response.language,
      intent: response.intent || 'general'
    });
  } catch (error) {
    console.error('[Pulse] Assist error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Real Shell Execution (For Pulse Terminal)
app.post('/api/pulse/exec', (req, res) => {
  const { command, cwd } = req.body;
  if (!command) return res.status(400).json({ error: 'Command required' });

  // Security: Basic blacklist to prevent total destruction (though local dev is trusted)
  if (command.includes('rm -rf /') || command.includes(':(){ :|:& };:')) {
    return res.status(403).json({ error: 'Command blocked by safety protocols.' });
  }

  const execOptions = {
    cwd: cwd || process.cwd(),
    maxBuffer: 1024 * 1024 * 10, // 10MB
    env: { ...process.env, TERM: 'xterm-256color' } // Fake terminal capability
  };

  exec(command, execOptions, (error, stdout, stderr) => {
    // We return success even if error exists, so the terminal can display the error output
    res.json({
      success: !error,
      stdout: stdout || '',
      stderr: stderr || (error ? error.message : '')
    });
  });
});

// Workspace Management
app.post('/api/pulse/workspace/create', async (req, res) => {
  const { name, path: workspacePath, repoUrl } = req.body;
  if (!name || !workspacePath) return res.status(400).json({ error: 'Name and Path required' });

  try {
    const safePath = path.resolve(process.cwd(), workspacePath); // Basic resolve, though we might want to allow absolute paths anywhere on disk for local tool
    // For this tool, we trust the user (me) generally, so we allow absolute paths.
    // If we want to be stricter, we can enforce a sandbox.

    if (!fs.existsSync(safePath)) {
      fs.mkdirSync(safePath, { recursive: true });
    }

    if (repoUrl) {
      console.log(`[Workspace] Cloning ${repoUrl} to ${safePath}...`);
      await new Promise((resolve, reject) => {
        exec(`git clone ${repoUrl} .`, { cwd: safePath }, (err, stdout, stderr) => {
          if (err) return reject(err);
          resolve(stdout);
        });
      });
    }

    // Register simple workspace metadata
    // In a real app we'd save this to a DB. For now, we assume frontend state or a simple JSON file.

    res.json({ success: true, message: `Workspace ${name} created at ${safePath}` });
  } catch (error) {
    console.error('[Workspace] Create error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ===========================
// Pulse Arbiter API Endpoints (Agentic Intelligence)
// ===========================

// Dispatch task to PulseArbiter for intelligent routing
app.post('/api/pulse/arbiter/dispatch', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const { taskType, taskData, context } = req.body;
    const result = await pulseArbiter.dispatchTask({ taskType, taskData, context });
    res.json(result);
  } catch (error) {
    console.error('[PulseArbiter] Dispatch error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Query available arbiter capabilities
app.get('/api/pulse/arbiter/capabilities', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const capabilities = pulseArbiter.getAvailableCapabilities();
    res.json(capabilities);
  } catch (error) {
    console.error('[PulseArbiter] Capabilities error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get arbiter status
app.get('/api/pulse/arbiter/status', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const status = pulseArbiter.getStatus();
    res.json({ success: true, status });
  } catch (error) {
    console.error('[PulseArbiter] Status error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Generate blueprint using multi-arbiter coordination
app.post('/api/pulse/arbiter/generate-blueprint', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const { intent, existingFiles, projectContext } = req.body;
    const result = await pulseArbiter.generateBlueprint({ intent, existingFiles, projectContext });
    res.json(result);
  } catch (error) {
    console.error('[PulseArbiter] Blueprint generation error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Modify code using EngineeringSwarmArbiter
app.post('/api/pulse/arbiter/modify-code', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const { filepath, request, context } = req.body;
    const result = await pulseArbiter.modifyCode({ filepath, request, context });
    res.json(result);
  } catch (error) {
    console.error('[PulseArbiter] Code modification error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Analyze code using CodeObservationArbiter
app.post('/api/pulse/arbiter/analyze-code', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const { code, filepath, analysisType } = req.body;
    const result = await pulseArbiter.analyzeCode({ code, filepath, analysisType });
    res.json(result);
  } catch (error) {
    console.error('[PulseArbiter] Code analysis error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Execute terminal command via ComputerControlArbiter
app.post('/api/pulse/arbiter/execute-command', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const { command, cwd, context } = req.body;
    const result = await pulseArbiter.executeCommand({ command, cwd, context });
    res.json(result);
  } catch (error) {
    console.error('[PulseArbiter] Command execution error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Analyze vision data via VisionProcessingArbiter
app.post('/api/pulse/arbiter/analyze-vision', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const { imageData, mimeType, analysisType } = req.body;
    const result = await pulseArbiter.analyzeVision({ imageData, mimeType, analysisType });
    res.json(result);
  } catch (error) {
    console.error('[PulseArbiter] Vision analysis error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Steve assistance through SteveArbiter
app.post('/api/pulse/arbiter/steve-assist', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const { message, history, context } = req.body;
    const result = await pulseArbiter.handleSteveAssist({ message, history, context });
    res.json(result);
  } catch (error) {
    console.error('[PulseArbiter] Steve assist error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Steve Tool Creation - Create a tool from natural language
app.post('/api/pulse/steve/create-tool', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const { description, context } = req.body;
    if (!description) {
      return res.status(400).json({ error: 'Tool description required' });
    }
    const result = await pulseArbiter.createToolViaSteve(description, context);
    res.json(result);
  } catch (error) {
    console.error('[PulseArbiter] Tool creation error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// List Steve's registered tools
app.get('/api/pulse/steve/tools', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const { category } = req.query;
    const result = pulseArbiter.listSteveTools(category);
    res.json(result);
  } catch (error) {
    console.error('[PulseArbiter] List tools error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Execute a Steve tool
app.post('/api/pulse/steve/execute-tool', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const { toolName, parameters, context } = req.body;
    if (!toolName) {
      return res.status(400).json({ error: 'Tool name required' });
    }
    const result = await pulseArbiter.executeSteveTool(toolName, parameters, context);
    res.json(result);
  } catch (error) {
    console.error('[PulseArbiter] Tool execution error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// List installed skills
app.get('/api/pulse/skills', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const result = await pulseArbiter.listSkills();
    res.json(result);
  } catch (error) {
    console.error('[PulseArbiter] List skills error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Create new skill via worker
app.post('/api/pulse/skills/create', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const { prompt } = req.body;
    if (!prompt) {
      return res.status(400).json({ error: 'Prompt required' });
    }
    const result = await pulseArbiter.createSkill(prompt);
    res.json(result);
  } catch (error) {
    console.error('[PulseArbiter] Create skill error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Generate execution plan using multi-arbiter intelligence
app.post('/api/pulse/arbiter/generate-plan', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const { goal, context } = req.body;
    if (!goal) {
      return res.status(400).json({ error: 'Goal required' });
    }
    const result = await pulseArbiter.generatePlan({ goal, context });
    res.json(result);
  } catch (error) {
    console.error('[PulseArbiter] Plan generation error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Get plan history
app.get('/api/pulse/arbiter/plan-history', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const { workspace = 'default', limit = 20 } = req.query;
    res.json(result);
  } catch (error) {
    console.error('[PulseArbiter] Get plan history error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// ==========================================
// Performance & Learning APIs (Mission Control)
// ==========================================

app.get('/api/performance/summary', (req, res) => {
  try {
    const metrics = learningPipeline ? learningPipeline.stats : {
      totalInteractions: 0,
      totalExperiences: 0
    };

    // Mock data if early in lifecycle
    const mockPerf = {
      total_pnl: 0,
      win_rate: 0,
      total_trades: 0,
      agent_leaderboard: []
    };

    if (financeAgent && financeAgent.performance) {
      Object.assign(mockPerf, financeAgent.performance);
    }

    res.json({
      ...mockPerf,
      learning_metrics: metrics
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/learning/events', (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 10;
    // Attempt to get events from pipeline or return mock
    const events = learningPipeline && learningPipeline.interactionLog
      ? learningPipeline.interactionLog.slice(-limit).reverse()
      : [];

    res.json({ events });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Mock endpoints to satisfy frontend pollers
app.get('/api/goals/active', (req, res) => res.json({ goals: [] }));

// Real System Status
app.get('/api/status', (req, res) => {
  osUtils.cpuUsage((cpuPercent) => {
    res.json({
      success: true,
      uptime: process.uptime(),
      system_uptime: os.uptime(),
      cpu: cpuPercent * 100,
      memory: {
        total: os.totalmem(),
        free: os.freemem(),
        used: os.totalmem() - os.freemem(),
        process: process.memoryUsage()
      },
      arbiters: messageBroker ? messageBroker.getArbiterList() : []
    });
  });
});

app.get('/api/memory/status', (req, res) => {
  // Mock 'Active' memory tiers for visual feedback
  res.json({
    status: 'active',
    tiers: {
      hot: Math.floor(Math.random() * 50) + 120, // MB
      warm: Math.floor(Math.random() * 1000) + 5000, // Vectors
      cold: Math.floor(Math.random() * 5000) + 10000 // Records
    }
  });
});

app.get('/api/velocity/status', (req, res) => {
  res.json({
    velocity: (Math.random() * 0.5 + 0.8).toFixed(2), // 0.8x - 1.3x
    acceleration: (Math.random() * 0.1).toFixed(2)
  });
});

app.get('/api/beliefs', (req, res) => res.json({ beliefs: [] }));
app.get('/api/skills/stats', (req, res) => res.json({ skills: [] }));
app.get('/api/beliefs/contradictions', (req, res) => res.json({ contradictions: [] }));
app.get('/api/theory-of-mind/insights', (req, res) => res.json({ insights: [] }));

// Health check for frontend connectivity
app.get('/health', (req, res) => {
  res.json({ status: 'ok', timestamp: Date.now() });
});

// SLC Status for Command Bridge
app.get('/api/slc/status', (req, res) => {
  if (!syntheticCortex) {
    return res.status(503).json({ error: 'Synthetic Cortex not initialized' });
  }
  try {
    const stats = syntheticCortex.getStats ? syntheticCortex.getStats() : { status: 'active' };
    res.json({ success: true, stats });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PULSE API (MOVED TO routes/pulseRoutes.js)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
/*
// Load specific plan
app.get('/api/pulse/arbiter/plan/:planId', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const { planId } = req.params;
    const plan = await pulseArbiter.loadPlanFromContext(planId);
    if (!plan) {
      return res.status(404).json({ success: false, error: 'Plan not found' });
    }
    res.json({ success: true, plan });
  } catch (error) {
    console.error('[PulseArbiter] Load plan error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Update plan with execution results
app.post('/api/pulse/arbiter/plan/:planId/results', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const { planId } = req.params;
    const results = req.body;
    await pulseArbiter.updatePlanWithResults(planId, results);
    res.json({ success: true, message: 'Plan results updated and sent to learning pipeline' });
  } catch (error) {
    console.error('[PulseArbiter] Update plan results error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Analyze preview for issues and suggestions
app.post('/api/pulse/arbiter/analyze-preview', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const { html, css, js, includeAccessibility, includePerformance, includeConsistency } = req.body;
    const result = await pulseArbiter.handleMessage({
      type: 'analyze_preview',
      payload: { html, css, js, includeAccessibility, includePerformance, includeConsistency }
    });
    res.json(result);
  } catch (error) {
    console.error('[PulseArbiter] Preview analysis error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Analyze specific element for suggestions
app.post('/api/pulse/arbiter/analyze-element', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const { selector, tagName, classes, styles, content } = req.body;
    const result = await pulseArbiter.handleMessage({
      type: 'analyze_element',
      payload: { selector, tagName, classes, styles, content }
    });
    res.json(result);
  } catch (error) {
    console.error('[PulseArbiter] Element analysis error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Execute multi-arbiter workflow
app.post('/api/pulse/workflow/execute', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const workflowData = req.body;
    // Workflow execution would be implemented based on workflow structure
    res.json({ success: true, message: 'Workflow execution not yet implemented' });
  } catch (error) {
    console.error('[PulseArbiter] Workflow execution error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Workspace management through PulseArbiter
app.post('/api/pulse/workspace/load', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const { workspaceId } = req.body;
    const result = await pulseArbiter.loadWorkspace({ workspaceId });
    res.json(result);
  } catch (error) {
    console.error('[PulseArbiter] Workspace load error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

app.post('/api/pulse/workspace/save', async (req, res) => {
  if (!pulseArbiter) {
    return res.status(503).json({ error: 'PulseArbiter not initialized' });
  }

  try {
    const { workspaceId, workspace } = req.body;
    const result = await pulseArbiter.saveWorkspace({ workspaceId, workspace });
    res.json(result);
  } catch (error) {
    console.error('[PulseArbiter] Workspace save error:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});
*/

// Edge Worker endpoints
app.get('/api/edge/tasks', (req, res) => {
  // Mock data for now - would be stored in edgeOrchestrator
  res.json({ success: true, tasks: [] });
});

app.post('/api/edge/start', async (req, res) => {
  if (!edgeOrchestrator) {
    return res.status(503).json({ error: 'EdgeWorker not initialized' });
  }

  try {
    const { type, url } = req.body;
    let result;

    if (type === 'screenshot') {
      result = await edgeOrchestrator.captureScreenshot(url);
    } else if (type === 'scrape') {
      result = await edgeOrchestrator.scrapeWebsite(url);
    } else if (type === 'research') {
      result = await edgeOrchestrator.conductResearch(url);
    }

    const task = {
      id: Date.now().toString(),
      type,
      url,
      status: 'completed',
      result,
      createdAt: Date.now(),
      completedAt: Date.now()
    };

    res.json({ success: true, task });
  } catch (error) {
    console.error('[Edge] Task error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Security Council endpoints
app.post('/api/security/scan', async (req, res) => {
  if (!securityCouncil) {
    return res.status(503).json({ error: 'Security Council not initialized' });
  }

  try {
    const { blueprint } = req.body;
    const result = await securityCouncil.scanCode(blueprint);

    res.json({
      success: true,
      scans: result.vulnerabilities || [],
      score: result.score || 85
    });
  } catch (error) {
    console.error('[Security] Scan error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Vision Arbiter endpoints
app.post('/api/vision/analyze', async (req, res) => {
  if (!visionArbiter) {
    return res.status(503).json({ error: 'Vision Arbiter not initialized' });
  }

  try {
    const { type, image } = req.body;
    const result = await visionArbiter.analyzeImage({
      imageData: image,
      task: type
    });

    res.json({
      result: result.description || 'Analysis complete',
      code: result.code,
      language: result.language || 'typescript'
    });
  } catch (error) {
    console.error('[Vision] Analyze error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Adaptive Router metrics
app.get('/api/router/metrics', (req, res) => {
  if (!adaptiveRouter) {
    return res.status(503).json({ error: 'Adaptive Router not initialized' });
  }

  try {
    const stats = adaptiveRouter.getStats();
    res.json({
      success: true,
      metrics: stats.models || [],
      recentDecisions: stats.recentDecisions || [],
      patterns: stats.patterns || []
    });
  } catch (error) {
    console.error('[Router] Metrics error:', error);
    res.status(500).json({ error: error.message });
  }
});

// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
// ARBITERIUM ORCHESTRATION ENDPOINT
// â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
app.post('/api/arbiterium/orchestrate', async (req, res) => {
  if (!quadBrain) {
    return res.status(503).json({ error: 'QuadBrain not initialized' });
  }

  try {
    const { goal } = req.body;

    if (!goal || !goal.trim()) {
      return res.status(400).json({ error: 'Goal is required' });
    }

    console.log(`[Arbiterium] Orchestrating goal: "${goal}"`);

    // STEP 0: Check if we have the capability (autonomous expansion)
    if (capabilityExpansion) {
      const capabilityCheck = await capabilityExpansion.expandCapability(
        goal,
        messageBroker.getArbiters()
      );

      if (!capabilityCheck.success && capabilityCheck.requiresApproval) {
        // Missing capability detected - return proposal to user
        return res.json({
          success: false,
          requiresApproval: true,
          proposal: {
            message: capabilityCheck.message,
            missingCapability: capabilityCheck.missingCapability,
            suggestedRepos: capabilityCheck.suggestedRepos,
            topRepo: capabilityCheck.topRepo
          }
        });
      }
    }

    // Step 1: Use QuadBrain to analyze the goal and create a plan
    const planningPrompt = `You are an AI orchestrator managing a swarm of specialized arbiters. 

User Goal: "${goal}"

Available Arbiters:
${messageBroker.getArbiters().map(a => `- ${a.name} (${a.role}): ${a.capabilities?.join(', ') || 'general'}`).join('\n')}

Create a detailed execution plan with 3-5 concrete steps. For each step:
1. Describe the specific task
2. Assign it to an appropriate arbiter by role
3. List any dependencies on previous steps

Respond in JSON format:
{
  "summary": "brief plan overview",
  "steps": [
    {
      "description": "task description",
      "arbiterRole": "role name",
      "dependencies": []
    }
  ]
}`;

    const planResponse = await quadBrain.reason(planningPrompt, {
      brain: 'PROMETHEUS', // Strategic planning
      temperature: 0.3
    });

    let plan;
    try {
      // Extract JSON from response
      const jsonMatch = planResponse.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        plan = JSON.parse(jsonMatch[0]);
      } else {
        // Fallback: create basic plan
        plan = {
          summary: planResponse.substring(0, 200),
          steps: [
            {
              description: `Analyze request: "${goal}"`,
              arbiterRole: 'problem-solver',
              dependencies: []
            },
            {
              description: 'Execute solution',
              arbiterRole: 'executor',
              dependencies: [0]
            },
            {
              description: 'Summarize results',
              arbiterRole: 'logician',
              dependencies: [1]
            }
          ]
        };
      }
    } catch (parseError) {
      console.warn('[Arbiterium] Plan parsing failed, using fallback');
      plan = {
        summary: `Orchestrate: ${goal}`,
        steps: [
          { description: `Process: "${goal}"`, arbiterRole: 'specialist', dependencies: [] }
        ]
      };
    }

    // Step 2: Assign unique IDs to steps
    const workflow = {
      goal,
      summary: plan.summary,
      createdAt: Date.now(),
      createdBy: 'PROMETHEUS', // Strategic planning brain
      plannerMetadata: {
        brain: 'PROMETHEUS',
        temperature: 0.3,
        availableArbiters: messageBroker.getArbiters().length,
        planningTime: Date.now() - Date.now() // Will be calculated
      },
      steps: plan.steps.map((step, idx) => ({
        id: `step-${idx + 1}`,
        description: step.description,
        assignedArbiterRole: step.arbiterRole,
        dependencies: step.dependencies || [],
        status: 'pending',
        logs: []
      }))
    };

    console.log(`[Arbiterium] Plan created with ${workflow.steps.length} steps`);

    res.json({
      success: true,
      plan: workflow
    });

  } catch (error) {
    console.error('[Arbiterium] Orchestration error:', error);
    res.status(500).json({
      error: error.message,
      fallbackPlan: {
        goal: req.body.goal,
        summary: 'Error occurred during planning',
        steps: [
          {
            id: 'step-1',
            description: `Analyze: "${req.body.goal}"`,
            assignedArbiterRole: 'general',
            dependencies: [],
            status: 'pending',
            logs: []
          }
        ]
      }
    });
  }
});

// Execute a specific step in a workflow
app.post('/api/arbiterium/execute-step', async (req, res) => {
  try {
    const { stepId, description, arbiterRole, context } = req.body;

    console.log(`[Arbiterium] Executing step ${stepId}: "${description}"`);

    // Find appropriate arbiter
    const availableArbiters = messageBroker.getArbitersByRole(arbiterRole);

    if (availableArbiters.length === 0) {
      console.warn(`[Arbiterium] No arbiter found for role: ${arbiterRole}, using QuadBrain`);
    }

    // Execute using QuadBrain (which can delegate to appropriate systems)
    const executionPrompt = `Execute this task:
"${description}"

Context: ${JSON.stringify(context || {})}

Provide a concise result or output.`;

    const result = await quadBrain.reason(executionPrompt, {
      brain: 'LOGOS', // Analytical execution
      temperature: 0.2
    });

    res.json({
      success: true,
      stepId,
      output: result,
      status: 'completed',
      completedAt: Date.now()
    });

  } catch (error) {
    console.error('[Arbiterium] Step execution error:', error);
    res.status(500).json({
      success: false,
      error: error.message,
      status: 'failed'
    });
  }
});

// Context Manager endpoints (project save/load)
app.get('/api/context/list', async (req, res) => {
  if (!contextManager) {
    return res.json({ success: true, projects: [] });
  }

  try {
    const projects = await contextManager.listProjects();
    res.json({ success: true, projects: projects || [] });
  } catch (error) {
    console.error('[Context] List error:', error);
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/context/save', async (req, res) => {
  if (!contextManager) {
    return res.json({ success: true });
  }

  try {
    const { projectId, state } = req.body;
    await contextManager.saveProject(projectId, state);
    res.json({ success: true });
  } catch (error) {
    console.error('[Context] Save error:', error);
    res.status(500).json({ error: error.message });
  }
});

app.get('/api/context/load/:id', async (req, res) => {
  if (!contextManager) {
    return res.status(404).json({ success: false });
  }

  try {
    const state = await contextManager.loadProject(req.params.id);
    res.json({ success: true, state });
  } catch (error) {
    console.error('[Context] Load error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Setup endpoint to update .env
app.post('/api/setup/env', async (req, res) => {
  try {
    const updates = req.body;
    const envPath = path.resolve(process.cwd(), '.env');

    // Read existing
    let envContent = '';
    if (fs.existsSync(envPath)) {
      envContent = fs.readFileSync(envPath, 'utf8');
    }

    // Parse existing
    const envLines = envContent.split('\n');
    const newEnvLines = [];
    const updatedKeys = new Set();

    for (const line of envLines) {
      if (!line.trim() || line.startsWith('#')) {
        newEnvLines.push(line);
        continue;
      }
      const [key, ...rest] = line.split('=');
      const cleanKey = key.trim();

      if (updates[cleanKey]) {
        newEnvLines.push(`${cleanKey}=${updates[cleanKey]}`);
        updatedKeys.add(cleanKey);
      } else {
        newEnvLines.push(line); // Keep existing
      }
    }

    // Append new keys
    for (const [key, value] of Object.entries(updates)) {
      if (!updatedKeys.has(key)) {
        newEnvLines.push(`${key}=${value}`);
      }
      // Also update process.env temporarily
      process.env[key] = value;
    }

    fs.writeFileSync(envPath, newEnvLines.join('\n'));

    // PROACTIVE: If Kevin is active, tell him to reload
    if (kevinArbiter) {
      if (typeof kevinArbiter.reloadCredentials === 'function') {
        await kevinArbiter.reloadCredentials();
      }
    }

    res.json({ success: true, message: "Environment updated & Kevin notified" });
  } catch (e) {
    console.error("Env update failed:", e);
    res.status(500).json({ success: false, error: e.message });
  }
});

// ===========================
// Start Server
// ===========================

const PORT = process.env.PORT || 3001;

server.listen(PORT, async () => {
  console.log(`\n[Server] SOMA backend running on port ${PORT}`);
  console.log(`[Server] REST API: http://localhost:${PORT}`);
  console.log(`[Server] WebSocket: ws://localhost:${PORT}\n`);

  // Initialize full ASI system
  try {
    await initializeASI();
    console.log('[Server] âœ… ASI initialization complete!');
  } catch (error) {
    console.error('[Server] âŒ ASI initialization FAILED:', error);
    console.error('[Server] Stack trace:', error.stack);
  }
});

// ===========================
// Graceful Shutdown
// ===========================

process.on('SIGINT', async () => {
  console.log('\n[Server] ğŸ›‘ Shutting down SOMA ASI gracefully...\n');

  if (fragmentHub) {
    console.log('[Server] Stopping Fragment Communication Hub...');
    // No shutdown method needed, just cleanup
  }

  if (fragmentRegistry) {
    console.log('[Server] Saving Fragment Registry...');
    await fragmentRegistry.shutdown();
  }

  if (quadBrain) {
    console.log('[Server] Shutting down Quad-Brain...');
    // QuadBrain has no explicit shutdown, just cleanup
  }

  if (adaptiveRouter) {
    console.log('[Server] Saving Adaptive Router state...');
    if (adaptiveRouter.saveRoutingHistory) {
      await adaptiveRouter.saveRoutingHistory();
    }
  }

  if (learningPipeline) {
    console.log('[Server] Persisting Learning Pipeline...');
    await learningPipeline.shutdown();
  }

  if (mnemonicArbiter) {
    console.log('[Server] Shutting down Memory System...');
    await mnemonicArbiter.shutdown();
  }

  server.close(() => {
    console.log('[Server] âœ… SOMA ASI shutdown complete\n');
    process.exit(0);
  });
});


