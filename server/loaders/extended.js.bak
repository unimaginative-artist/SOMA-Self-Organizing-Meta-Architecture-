/**
 * server/loaders/extended.js
 *
 * PHASE 4.1: Extended Specialist Arbiters
 * Activates ~40 high-impact arbiters that were sitting on disk unused.
 * Organized into 8 boot phases by dependency order.
 * Each wrapped in try/catch ‚Äî one failure never crashes the boot.
 */

import path from 'path';
import { createRequire } from 'module';

const require = createRequire(import.meta.url);

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// PHASE A: Infrastructure (no dependencies)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
import OutcomeTracker from '../../arbiters/OutcomeTracker.js';
import ExperienceReplayBuffer from '../../arbiters/ExperienceReplayBuffer.js';
import { PortfolioOptimizer } from '../../arbiters/PortfolioOptimizer.js';
import { QueryComplexityClassifier } from '../../arbiters/QueryComplexityClassifier.js';
import { EconomicCalendar } from '../../arbiters/EconomicCalendar.js';
import { MarketRegimeDetector } from '../../arbiters/MarketRegimeDetector.js';
import { FragmentRegistry } from '../../arbiters/FragmentRegistry.js';
import MnemonicIndexerArbiter from '../../arbiters/MnemonicIndexerArbiter.js';
const HybridSearchArbiter = require('../../arbiters/HybridSearchArbiter.cjs');
const TimekeeperArbiter = require('../../arbiters/TimekeeperArbiter.cjs');
const GoalPlannerArbiter = require('../../arbiters/GoalPlannerArbiter.cjs');

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// PHASE B: Core Specialists (use system.quadBrain, etc.)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
import { ReasoningChamber } from '../../arbiters/ReasoningChamber.js';
import { DevilsAdvocateArbiter } from '../../arbiters/DevilsAdvocateArbiter.js';
import { ForecasterArbiter } from '../../arbiters/ForecasterArbiter.js';
import { ToolCreatorArbiter } from '../../arbiters/ToolCreatorArbiter.js';
import { SentimentAggregator } from '../../arbiters/SentimentAggregator.js';
import { GistArbiter } from '../../arbiters/GistArbiter.js';
import { CodeObservationArbiter } from '../../arbiters/CodeObservationArbiter.js';

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// PHASE C: Cognitive Enhancement
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
import { HippocampusArbiter } from '../../arbiters/HippocampusArbiter.js';
import { MetaCortexArbiter } from '../../arbiters/MetaCortexArbiter.js';
import { AbstractionArbiter } from '../../arbiters/AbstractionArbiter.js';
import { KnowledgeAugmentedGenerator } from '../../arbiters/KnowledgeAugmentedGenerator.js';

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// PHASE D: Trading Complex Systems
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
import { MultiTimeframeAnalyzer } from '../../arbiters/MultiTimeframeAnalyzer.js';
import { AdversarialDebate } from '../../arbiters/AdversarialDebate.js';
import { TradeLearningEngine } from '../../arbiters/TradeLearningEngine.js';
import { BacktestEngine } from '../../arbiters/BacktestEngine.js';
import { SmartOrderRouter } from '../../arbiters/SmartOrderRouter.js';
import { AdaptivePositionSizer } from '../../arbiters/AdaptivePositionSizer.js';
import StrategyOptimizer from '../../arbiters/StrategyOptimizer.js';
import { RedditSignalDetector } from '../../arbiters/RedditSignalDetector.js';

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// PHASE E: Learning & Self-Improvement
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
import { UniversalLearningPipeline } from '../../arbiters/UniversalLearningPipeline.js';
import { CuriosityEngine } from '../../arbiters/CuriosityEngine.js';
import AdaptiveLearningPlanner from '../../arbiters/AdaptiveLearningPlanner.js';
import { HindsightReplayArbiter } from '../../arbiters/HindsightReplayArbiter.js';
import { SelfImprovementCoordinator } from '../../arbiters/SelfImprovementCoordinator.js';
import { CriticAlignmentService } from '../../arbiters/CriticAlignmentService.js';
import { PerformanceOracle } from '../../arbiters/PerformanceOracle.js';

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// PHASE F: Knowledge & Research
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
import { FragmentCommunicationHub } from '../../arbiters/FragmentCommunicationHub.js';
import { IdeaCaptureArbiter } from '../../arbiters/IdeaCaptureArbiter.js';
import { ConversationCuriosityExtractor } from '../../arbiters/ConversationCuriosityExtractor.js';
import CuriosityWebAccessConnector from '../../arbiters/CuriosityWebAccessConnector.js';

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// PHASE G: Identity & Context
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
import { PersonalityForgeArbiter } from '../../arbiters/PersonalityForgeArbiter.js';
import { UserProfileArbiter } from '../../arbiters/UserProfileArbiter.js';
import { ContextManagerArbiter } from '../../arbiters/ContextManagerArbiter.js';
import { MoltbookArbiter } from '../../arbiters/MoltbookArbiter.js';
import { SocialAutonomyArbiter } from '../../arbiters/SocialAutonomyArbiter.js';

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// PHASE H2: Autonomous Orchestration
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
import { NighttimeLearningOrchestrator } from '../../core/NighttimeLearningOrchestrator.js';
import { ReportingArbiter } from '../../arbiters/ReportingArbiter.js';

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// PHASE I: Self-Awareness & Autonomy
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
import { RecursiveSelfModel } from '../../arbiters/RecursiveSelfModel.js';
import { SelfCodeInspector } from '../../arbiters/SelfCodeInspector.js';
import { SelfDrivenCuriosityConnector } from '../../arbiters/SelfDrivenCuriosityConnector.js';
import { AutonomousCapabilityExpansion } from '../../arbiters/AutonomousCapabilityExpansion.js';
import { DeploymentArbiter } from '../../arbiters/DeploymentArbiter.js';
import { MetaLearningEngine } from '../../arbiters/MetaLearningEngine.js';
import { SkillWatcherArbiter } from '../../arbiters/SkillWatcherArbiter.js';
import { TrainingDataExporter } from '../../arbiters/TrainingDataExporter.js';
import { ConversationHistoryArbiter } from '../../arbiters/ConversationHistoryArbiter.js';
import { EnrichmentArbiter } from '../../arbiters/EnrichmentArbiter.js';
import { ReflexArbiter } from '../../arbiters/ReflexArbiter.js';
import { ReflexScoutArbiter } from '../../arbiters/ReflexScoutArbiter.js';

const rootPath = process.cwd();

const SAFE_LOAD_TIMEOUT_MS = 3000; // 3 seconds max per arbiter ‚Äî skip slow ones

// Counter for breathing room between batches
let _arbiterLoadCount = 0;

// Yield the event loop between arbiter loads so HTTP requests can be served.
// Each arbiter can block the event loop for up to 3s during constructor/init.
// We yield for 5s between EVERY arbiter and 15s every 3 arbiters.
// This is slow (~15 min total) but keeps the server responsive throughout.
async function yieldEventLoop() {
    _arbiterLoadCount++;
    if (_arbiterLoadCount % 3 === 0) {
        // Every 3 arbiters: 15-second break to fully drain HTTP requests
        await new Promise(resolve => setTimeout(resolve, 15000));
    } else {
        // 5-second yield between each arbiter
        await new Promise(resolve => setTimeout(resolve, 5000));
    }
}

// Memory ceiling ‚Äî skip non-essential arbiters if heap exceeds this
// Lower = more stable but fewer arbiters loaded
// 400MB ceiling with ~215MB baseline = ~185MB for Tier 2 arbiters
const HEAP_CEILING_MB = 400;

async function safeLoad(name, factory) {
    // Memory guard FIRST ‚Äî skip immediately without waiting if over ceiling
    const heapMB = process.memoryUsage().heapUsed / 1024 / 1024;
    if (heapMB > HEAP_CEILING_MB) {
        console.warn(`    ‚ö†Ô∏è ${name} skipped: heap at ${heapMB.toFixed(0)}MB (ceiling: ${HEAP_CEILING_MB}MB)`);
        return null;
    }

    // Only yield if we're actually going to load
    await yieldEventLoop();

    const memBefore = process.memoryUsage().heapUsed;
    try {
        const timeout = new Promise((_, reject) =>
            setTimeout(() => reject(new Error(`initialization timed out after ${SAFE_LOAD_TIMEOUT_MS / 1000}s`)), SAFE_LOAD_TIMEOUT_MS)
        );

        const load = async () => {
            const instance = await factory();
            if (instance && typeof instance.initialize === 'function') {
                await instance.initialize();
            } else if (instance && typeof instance.onInitialize === 'function') {
                await instance.onInitialize();
            } else if (instance && typeof instance.onActivate === 'function') {
                await instance.onActivate();
            }
            return instance;
        };

        const instance = await Promise.race([load(), timeout]);
        const memDelta = ((process.memoryUsage().heapUsed - memBefore) / 1024 / 1024).toFixed(1);
        const totalMB = (process.memoryUsage().heapUsed / 1024 / 1024).toFixed(0);
        console.log(`    ‚úÖ ${name} (+${memDelta}MB, heap: ${totalMB}MB)`);
        return instance;
    } catch (e) {
        console.warn(`    ‚ö†Ô∏è ${name} skipped: ${e.message}`);
        return null;
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TIER 1: Essential ASI arbiters (learning, fragments, memory)
// Loads 60s after boot. ~12 arbiters. Light enough to not kill event loop.
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
export async function loadEssentialSystems(system) {
    console.log('\n[Essential] ‚ïê‚ïê‚ïê Loading ASI Core (Learning + Fragments) ‚ïê‚ïê‚ïê');
    _arbiterLoadCount = 0; // Reset counter
    const ext = {};

    // OutcomeTracker (reuse from early boot)
    if (system.outcomeTracker) {
        ext.outcomeTracker = system.outcomeTracker;
        console.log('    ‚úÖ OutcomeTracker (reusing from early boot)');
    } else {
        ext.outcomeTracker = await safeLoad('OutcomeTracker', () =>
            new OutcomeTracker({ storageDir: path.join(rootPath, 'data', 'outcomes'), maxInMemory: 10000, enablePersistence: true })
        );
    }

    ext.experienceReplay = await safeLoad('ExperienceReplayBuffer', () =>
        new ExperienceReplayBuffer({ maxSize: 50000, name: 'ExperienceReplay' })
    );

    ext.queryClassifier = await safeLoad('QueryComplexityClassifier', () =>
        new QueryComplexityClassifier()
    );

    ext.fragmentRegistry = await safeLoad('FragmentRegistry', () =>
        new FragmentRegistry({ messageBroker: system.messageBroker })
    );

    ext.learningPipeline = await safeLoad('UniversalLearningPipeline', () =>
        new UniversalLearningPipeline({ name: 'UniversalLearningPipeline', messageBroker: system.messageBroker })
    );

    ext.curiosityEngine = await safeLoad('CuriosityEngine', () =>
        new CuriosityEngine({
            knowledgeGraph: system.knowledgeGraph,
            messageBroker: system.messageBroker,
            simulationArbiter: system.simulation,
            worldModel: system.worldModel,
            fragmentRegistry: ext.fragmentRegistry || system.fragmentRegistry
        })
    );

    ext.curiosityExtractor = await safeLoad('ConversationCuriosityExtractor', () =>
        new ConversationCuriosityExtractor({
            curiosityEngine: ext.curiosityEngine,
            quadBrain: system.quadBrain
        })
    );

    ext.personalityForge = await safeLoad('PersonalityForgeArbiter', () =>
        new PersonalityForgeArbiter({
            quadBrain: system.quadBrain,
            messageBroker: system.messageBroker
        })
    );

    ext.moltbook = await safeLoad('MoltbookArbiter', () =>
        new MoltbookArbiter({
            messageBroker: system.messageBroker,
            securityCouncil: system.securityCouncil || system.immuneCortex
        })
    );

    ext.conversationHistory = await safeLoad('ConversationHistoryArbiter', () => {
        const arb = new ConversationHistoryArbiter({
            dbPath: path.join(rootPath, 'SOMA', 'conversations.db')
        });
        arb._initArbiters = { mnemonic: system.mnemonicArbiter, personalityForge: ext.personalityForge };
        return arb;
    });
    if (ext.conversationHistory && ext.conversationHistory._initArbiters) {
        try {
            await ext.conversationHistory.initialize(ext.conversationHistory._initArbiters);
            delete ext.conversationHistory._initArbiters;
            console.log('    ‚úÖ ConversationHistoryArbiter (DB initialized)');
        } catch (e) {
            console.warn('    ‚ö†Ô∏è ConversationHistory DB init:', e.message);
        }
    }

    ext.trainingDataExporter = await safeLoad('TrainingDataExporter', () =>
        new TrainingDataExporter({
            outputDir: path.join(rootPath, 'SOMA', 'training-data')
        })
    );

    // ‚îÄ‚îÄ Wire essential connections ‚îÄ‚îÄ
    console.log('\n[Essential] Wiring ASI core connections...');

    if (ext.learningPipeline) {
        if (ext.outcomeTracker) ext.learningPipeline.outcomeTracker = ext.outcomeTracker;
        if (ext.experienceReplay) ext.learningPipeline.experienceReplay = ext.experienceReplay;
        if (system.mnemonicArbiter) ext.learningPipeline.mnemonicArbiter = system.mnemonicArbiter;
        system.learningPipeline = ext.learningPipeline;
        console.log('    üîó Learning Pipeline ‚Üí OutcomeTracker + ExperienceReplay + Memory');
    }

    if (ext.curiosityExtractor) {
        system.curiosityExtractor = ext.curiosityExtractor;
        console.log('    üîó CuriosityExtractor ‚Üí system');
    }

    if (ext.fragmentRegistry) {
        if (system.quadBrain) system.quadBrain.fragmentRegistry = ext.fragmentRegistry;
        if (ext.learningPipeline) ext.fragmentRegistry.learningPipeline = ext.learningPipeline;
        system.fragmentRegistry = ext.fragmentRegistry;
        console.log('    üîó FragmentRegistry ‚Üí QuadBrain + LearningPipeline');
    }

    if (ext.moltbook) { system.moltbook = ext.moltbook; }
    if (ext.personalityForge) { system.personalityForge = ext.personalityForge; }
    if (ext.conversationHistory) { system.conversationHistory = ext.conversationHistory; }

    if (ext.trainingDataExporter) {
        ext.trainingDataExporter.conversationHistory = ext.conversationHistory;
        ext.trainingDataExporter.personalityForge = ext.personalityForge;
        ext.trainingDataExporter.mnemonic = system.mnemonicArbiter;
        ext.trainingDataExporter.learningPipeline = ext.learningPipeline;
        console.log('    üîó TrainingDataExporter ‚Üê ConversationHistory, Memory, LearningPipeline');
    }

    // AdaptiveLearningPlanner ‚Äî feeds into curiosity-driven learning
    ext.learningPlanner = await safeLoad('AdaptiveLearningPlanner', () =>
        new AdaptiveLearningPlanner({
            curiosityEngine: ext.curiosityEngine,
            outcomeTracker: ext.outcomeTracker,
            knowledgeGraph: system.knowledgeGraph,
            messageBroker: system.messageBroker
        })
    );

    // HindsightReplayArbiter ‚Äî learns from every failure
    ext.hindsightReplay = await safeLoad('HindsightReplayArbiter', () =>
        new HindsightReplayArbiter({
            experienceReplay: ext.experienceReplay,
            outcomeTracker: ext.outcomeTracker
        })
    );

    const loaded = Object.values(ext).filter(v => v !== null).length;
    const heapMB = (process.memoryUsage().heapUsed / 1024 / 1024).toFixed(0);
    console.log(`\n[Essential] ‚ïê‚ïê‚ïê ${loaded} ASI-core arbiters activated (heap: ${heapMB}MB) ‚ïê‚ïê‚ïê\n`);
    return ext;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TIER 2: Full extended arbiters (trading, research, self-awareness, etc.)
// Loads 10 min after boot. Non-essential for chat/learning.
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
export async function loadExtendedSystems(system) {
    console.log('\n[Extended] ‚ïê‚ïê‚ïê Activating Remaining Specialist Arbiters ‚ïê‚ïê‚ïê');
    const ext = {};
    _arbiterLoadCount = 0; // Reset counter

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE A: Infrastructure (reuse essential tier where available)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.log('\n[Phase A] Infrastructure & Data...');

    // Reuse arbiters already loaded by loadEssentialSystems()
    ext.outcomeTracker = system.outcomeTracker || await safeLoad('OutcomeTracker', () =>
        new OutcomeTracker({ storageDir: path.join(rootPath, 'data', 'outcomes'), maxInMemory: 10000, enablePersistence: true })
    );
    if (ext.outcomeTracker) console.log('    ‚úÖ OutcomeTracker (reused)');

    ext.experienceReplay = system.learningPipeline?.experienceReplay || await safeLoad('ExperienceReplayBuffer', () =>
        new ExperienceReplayBuffer({ maxSize: 50000, name: 'ExperienceReplay' })
    );

    ext.portfolioOptimizer = await safeLoad('PortfolioOptimizer', () =>
        new PortfolioOptimizer({ rootPath })
    );

    ext.queryClassifier = system.queryClassifier || await safeLoad('QueryComplexityClassifier', () =>
        new QueryComplexityClassifier()
    );

    ext.economicCalendar = await safeLoad('EconomicCalendar', () =>
        new EconomicCalendar()
    );

    ext.regimeDetector = await safeLoad('MarketRegimeDetector', () =>
        new MarketRegimeDetector()
    );

    ext.fragmentRegistry = system.fragmentRegistry || await safeLoad('FragmentRegistry', () =>
        new FragmentRegistry({ messageBroker: system.messageBroker })
    );
    if (system.fragmentRegistry) console.log('    ‚úÖ FragmentRegistry (reused from essential)');

    ext.mnemonicIndexer = await safeLoad('MnemonicIndexerArbiter', () =>
        new MnemonicIndexerArbiter({
            mnemonicArbiter: system.mnemonicArbiter,
            storageArbiter: system.storageArbiter || system.storage || null,
            watchPath: process.env.SOMA_INDEX_PATH || process.cwd()
        })
    );

    // HybridSearchArbiter loads LocalEmbedder (all-MiniLM-L6-v2 transformer, ~290MB).
    // Even when it times out at 3s, the model load continues in background and kills the event loop.
    // Only load if explicitly enabled or if memory headroom is generous.
    const heapBeforeHybrid = process.memoryUsage().heapUsed / 1024 / 1024;
    if (process.env.SOMA_HYBRID_SEARCH === 'true' && heapBeforeHybrid < 400) {
        const useHybridWorker = process.env.SOMA_HYBRID_WORKER === 'true';
        ext.hybridSearch = await safeLoad('HybridSearchArbiter', () =>
            new HybridSearchArbiter({ name: 'HybridSearchArbiter', useWorker: useHybridWorker })
        );
    } else {
        console.log(`    ‚è≠Ô∏è HybridSearchArbiter deferred (heap: ${heapBeforeHybrid.toFixed(0)}MB, loads 290MB ML model)`);
        ext.hybridSearch = null;
    }

    ext.timekeeper = await safeLoad('TimekeeperArbiter', () =>
        new TimekeeperArbiter({ name: 'TimekeeperArbiter' })
    );

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE B/C/D: Heavyweight arbiters (Reasoning, Cognitive, Trading)
    // These eat 200-400MB combined and block the event loop during init.
    // Only load if explicitly opted in via SOMA_LOAD_HEAVY=true.
    // Chat works fine without them ‚Äî QuadBrain + Gemini handles everything.
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const loadHeavy = process.env.SOMA_LOAD_HEAVY === 'true';
    if (!loadHeavy) {
        console.log('\n[Phase B/C/D] ‚è≠Ô∏è Skipped heavyweight arbiters (set SOMA_LOAD_HEAVY=true to enable)');
        console.log('    Skipped: ReasoningChamber, DevilsAdvocate, Forecaster, Hippocampus,');
        console.log('    MetaCortex, Abstraction, KnowledgeGenerator, Trading Pipeline');
    }
    if (loadHeavy) {
    console.log('\n[Phase B] Core Specialists (HEAVYWEIGHT)...');

    // Force GC before heavy phase if available
    if (global.gc) { global.gc(); console.log('    üóëÔ∏è Forced GC before Phase B'); }
    await new Promise(resolve => setTimeout(resolve, 10000)); // Extra 10s breathing room

    ext.reasoning = await safeLoad('ReasoningChamber', () =>
        new ReasoningChamber({
            name: 'ReasoningChamber',
            causalityArbiter: system.causality,
            knowledgeGraph: system.knowledgeGraph,
            mnemonic: system.mnemonicArbiter,
            worldModel: system.worldModel
        })
    );

    ext.devilsAdvocate = await safeLoad('DevilsAdvocateArbiter', () =>
        new DevilsAdvocateArbiter({ name: 'DevilsAdvocate', quadBrain: system.quadBrain, messageBroker: system.messageBroker })
    );

    ext.forecaster = await safeLoad('ForecasterArbiter', () =>
        new ForecasterArbiter({ name: 'Forecaster', quadBrain: system.quadBrain, enrichmentArbiter: system.enrichmentArbiter, worldModel: system.worldModel, messageBroker: system.messageBroker })
    );

    ext.toolCreator = await safeLoad('ToolCreatorArbiter', () =>
        new ToolCreatorArbiter({ name: 'ToolCreator', quadBrain: system.quadBrain, toolRegistry: system.toolRegistry, messageBroker: system.messageBroker })
    );

    ext.sentimentAggregator = await safeLoad('SentimentAggregator', () =>
        new SentimentAggregator({ quadBrain: system.quadBrain })
    );

    ext.gistArbiter = await safeLoad('GistArbiter', () =>
        new GistArbiter({ name: 'GistArbiter', quadBrain: system.quadBrain })
    );

    ext.codeObserver = await safeLoad('CodeObservationArbiter', () =>
        new CodeObservationArbiter({ rootPath })
    );

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE C: Cognitive Enhancement
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.log('\n[Phase C] Cognitive Enhancement...');

    ext.hippocampus = await safeLoad('HippocampusArbiter', () =>
        new HippocampusArbiter({
            mnemonicArbiter: system.mnemonicArbiter,
            knowledgeGraph: system.knowledgeGraph,
            messageBroker: system.messageBroker
        })
    );

    ext.metaCortex = await safeLoad('MetaCortexArbiter', () =>
        new MetaCortexArbiter({
            quadBrain: system.quadBrain,
            messageBroker: system.messageBroker
        })
    );

    ext.abstractionArbiter = await safeLoad('AbstractionArbiter', () =>
        new AbstractionArbiter({
            knowledgeGraph: system.knowledgeGraph,
            worldModel: system.worldModel
        })
    );

    ext.knowledgeGenerator = await safeLoad('KnowledgeAugmentedGenerator', () =>
        new KnowledgeAugmentedGenerator({
            quadBrain: system.quadBrain,
            knowledgeGraph: system.knowledgeGraph,
            mnemonicArbiter: system.mnemonicArbiter
        })
    );

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE D: Trading Complex Systems
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.log('\n[Phase D] Trading Pipeline...');

    ext.mtfAnalyzer = await safeLoad('MultiTimeframeAnalyzer', () =>
        new MultiTimeframeAnalyzer({ regimeDetector: ext.regimeDetector })
    );

    ext.adversarialDebate = await safeLoad('AdversarialDebate', () =>
        new AdversarialDebate({ quadBrain: system.quadBrain })
    );

    ext.tradeLearning = await safeLoad('TradeLearningEngine', () =>
        new TradeLearningEngine({ outcomeTracker: ext.outcomeTracker, rootPath })
    );

    ext.backtestEngine = await safeLoad('BacktestEngine', () =>
        new BacktestEngine({ quadBrain: system.quadBrain, mtfAnalyzer: ext.mtfAnalyzer, regimeDetector: ext.regimeDetector, rootPath })
    );

    ext.smartOrderRouter = await safeLoad('SmartOrderRouter', () =>
        new SmartOrderRouter({ rootPath })
    );

    ext.positionSizer = await safeLoad('AdaptivePositionSizer', () =>
        new AdaptivePositionSizer({ rootPath })
    );

    ext.strategyOptimizer = await safeLoad('StrategyOptimizer', () =>
        new StrategyOptimizer({ quadBrain: system.quadBrain, rootPath })
    );

    ext.redditSignals = await safeLoad('RedditSignalDetector', () =>
        new RedditSignalDetector({ quadBrain: system.quadBrain })
    );
    } // end if (loadHeavy) ‚Äî Phase B/C/D

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE E: Learning & Self-Improvement
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.log('\n[Phase E] Learning & Self-Improvement...');

    // Reuse from Tier 1 if available
    if (system.learningPipeline) {
        ext.learningPipeline = system.learningPipeline;
        console.log('    ‚úÖ UniversalLearningPipeline (reused from essential)');
    } else {
        ext.learningPipeline = await safeLoad('UniversalLearningPipeline', () =>
            new UniversalLearningPipeline({ name: 'UniversalLearningPipeline', messageBroker: system.messageBroker })
        );
    }

    // CuriosityEngine ‚Äî not directly on system, check via curiosityExtractor
    if (system.curiosityExtractor?.curiosityEngine) {
        ext.curiosityEngine = system.curiosityExtractor.curiosityEngine;
        console.log('    ‚úÖ CuriosityEngine (reused from essential)');
    } else {
        ext.curiosityEngine = await safeLoad('CuriosityEngine', () =>
            new CuriosityEngine({
                knowledgeGraph: system.knowledgeGraph,
                messageBroker: system.messageBroker,
                simulationArbiter: system.simulation,
                worldModel: system.worldModel,
                fragmentRegistry: ext.fragmentRegistry || system.fragmentRegistry
            })
        );
    }

    ext.learningPlanner = await safeLoad('AdaptiveLearningPlanner', () =>
        new AdaptiveLearningPlanner({
            curiosityEngine: ext.curiosityEngine,
            outcomeTracker: ext.outcomeTracker,
            knowledgeGraph: system.knowledgeGraph,
            messageBroker: system.messageBroker
        })
    );

    ext.hindsightReplay = await safeLoad('HindsightReplayArbiter', () =>
        new HindsightReplayArbiter({
            experienceReplay: ext.experienceReplay,
            outcomeTracker: ext.outcomeTracker
        })
    );

    ext.selfImprovement = await safeLoad('SelfImprovementCoordinator', () =>
        new SelfImprovementCoordinator({
            quadBrain: system.quadBrain,
            outcomeTracker: ext.outcomeTracker,
            messageBroker: system.messageBroker
        })
    );

    ext.criticAlignment = await safeLoad('CriticAlignmentService', () =>
        new CriticAlignmentService({
            quadBrain: system.quadBrain
        })
    );

    ext.performanceOracle = await safeLoad('PerformanceOracle', () =>
        new PerformanceOracle({
            quadBrain: system.quadBrain,
            outcomeTracker: ext.outcomeTracker
        })
    );

    // Use existing goalPlanner from cognitive.js if present, otherwise create new
    if (system.goalPlanner && system.goalPlanner.goals) {
        ext.goalPlanner = system.goalPlanner;
        console.log('    ‚úÖ GoalPlannerArbiter (reusing from cognitive.js)');
    } else {
        ext.goalPlanner = await safeLoad('GoalPlannerArbiter', () =>
            new GoalPlannerArbiter({
                name: 'GoalPlannerArbiter',
                maxActiveGoals: 20,
                planningIntervalHours: 6
            })
        );
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE F: Knowledge & Research
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.log('\n[Phase F] Knowledge & Research...');

    ext.fragmentComms = await safeLoad('FragmentCommunicationHub', () =>
        new FragmentCommunicationHub({
            fragmentRegistry: ext.fragmentRegistry,
            messageBroker: system.messageBroker
        })
    );

    ext.ideaCapture = await safeLoad('IdeaCaptureArbiter', () =>
        new IdeaCaptureArbiter({
            knowledgeGraph: system.knowledgeGraph,
            messageBroker: system.messageBroker
        })
    );

    // Reuse from Tier 1 if available
    if (system.curiosityExtractor) {
        ext.curiosityExtractor = system.curiosityExtractor;
        console.log('    ‚úÖ ConversationCuriosityExtractor (reused from essential)');
    } else {
        ext.curiosityExtractor = await safeLoad('ConversationCuriosityExtractor', () =>
            new ConversationCuriosityExtractor({
                curiosityEngine: ext.curiosityEngine,
                quadBrain: system.quadBrain
            })
        );
    }

    ext.webResearcher = await safeLoad('CuriosityWebAccessConnector', () =>
        new CuriosityWebAccessConnector({
            curiosityEngine: ext.curiosityEngine,
            edgeWorker: system.edgeWorker,
            messageBroker: system.messageBroker
        })
    );

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE G: Identity & Context
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.log('\n[Phase G] Identity & Context...');

    // Reuse from Tier 1 if available
    if (system.personalityForge) {
        ext.personalityForge = system.personalityForge;
        console.log('    ‚úÖ PersonalityForgeArbiter (reused from essential)');
    } else {
        ext.personalityForge = await safeLoad('PersonalityForgeArbiter', () =>
            new PersonalityForgeArbiter({
                quadBrain: system.quadBrain,
                messageBroker: system.messageBroker
            })
        );
    }

    ext.userProfile = await safeLoad('UserProfileArbiter', () =>
        new UserProfileArbiter({
            mnemonicArbiter: system.mnemonicArbiter,
            rootPath
        })
    );

    ext.contextManager = await safeLoad('ContextManagerArbiter', () =>
        new ContextManagerArbiter({
            mnemonicArbiter: system.mnemonicArbiter,
            messageBroker: system.messageBroker
        })
    );

    // Reuse from Tier 1 if available
    if (system.moltbook) {
        ext.moltbook = system.moltbook;
        console.log('    ‚úÖ MoltbookArbiter (reused from essential)');
    } else {
        ext.moltbook = await safeLoad('MoltbookArbiter', () =>
            new MoltbookArbiter({
                messageBroker: system.messageBroker,
                securityCouncil: system.securityCouncil || system.immuneCortex
            })
        );
    }

    ext.socialAutonomy = await safeLoad('SocialAutonomyArbiter', () =>
        new SocialAutonomyArbiter({
            moltbook: ext.moltbook,
            quadBrain: system.quadBrain
        })
    );

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE I: Self-Awareness & Autonomy
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.log('\n[Phase I] Self-Awareness & Autonomy...');

    // Tier 1: No internal dependencies
    ext.reflexArbiter = await safeLoad('ReflexArbiter (Von Stratum)', () =>
        new ReflexArbiter()
    );

    ext.deploymentArbiter = await safeLoad('DeploymentArbiter', () =>
        new DeploymentArbiter({
            auditPath: path.join(rootPath, 'SOMA', 'deployment-audit')
        })
    );

    ext.enrichmentArbiter = await safeLoad('EnrichmentArbiter', () =>
        new EnrichmentArbiter({ quadBrain: system.quadBrain })
    );

    // Reuse from Tier 1 if available
    if (system.conversationHistory) {
        ext.conversationHistory = system.conversationHistory;
        console.log('    ‚úÖ ConversationHistoryArbiter (reused from essential)');
    } else {
        ext.conversationHistory = await safeLoad('ConversationHistoryArbiter', () => {
            const arb = new ConversationHistoryArbiter({
                dbPath: path.join(rootPath, 'SOMA', 'conversations.db')
            });
            arb._initArbiters = { mnemonic: system.mnemonicArbiter, personalityForge: ext.personalityForge };
            return arb;
        });
        if (ext.conversationHistory && ext.conversationHistory._initArbiters) {
            try {
                await ext.conversationHistory.initialize(ext.conversationHistory._initArbiters);
                delete ext.conversationHistory._initArbiters;
                console.log('    ‚úÖ ConversationHistoryArbiter (DB initialized)');
            } catch (e) {
                console.warn('    ‚ö†Ô∏è ConversationHistory DB init:', e.message);
            }
        }
    }

    ext.autonomousExpansion = await safeLoad('AutonomousCapabilityExpansion', () =>
        new AutonomousCapabilityExpansion({
            quadBrain: system.quadBrain,
            messageBroker: system.messageBroker
        })
    );

    // Tier 2: Uses ext arbiters from earlier phases
    ext.recursiveSelfModel = await safeLoad('RecursiveSelfModel', async () => {
        const rsm = new RecursiveSelfModel({
            messageBroker: system.messageBroker,
            learningPipeline: ext.learningPipeline
        });
        // RecursiveSelfModel.initialize(system) needs the system ref as arg
        // so it can discover all components. Call it manually, then remove
        // the method so safeLoad doesn't double-call it.
        rsm.system = system;
        await rsm.initialize(system);
        delete rsm.initialize;
        return rsm;
    });

    ext.selfCodeInspector = await safeLoad('SelfCodeInspector', () =>
        new SelfCodeInspector({
            somaRoot: rootPath,
            curiosityEngine: ext.curiosityEngine
        })
    );

    ext.metaLearning = await safeLoad('MetaLearningEngine', () =>
        new MetaLearningEngine({
            learningPipeline: ext.learningPipeline,
            fragmentRegistry: ext.fragmentRegistry,
            messageBroker: system.messageBroker
        })
    );

    ext.skillWatcher = await safeLoad('SkillWatcherArbiter', () =>
        new SkillWatcherArbiter({
            toolRegistry: system.toolRegistry,
            system
        })
    );

    // TrainingDataExporter ‚Äî not on system directly, but check ext from essential
    ext.trainingDataExporter = await safeLoad('TrainingDataExporter', () =>
        new TrainingDataExporter({
            outputDir: path.join(rootPath, 'SOMA', 'training-data')
        })
    );

    // Tier 3: Depends on Tier 1+2
    ext.selfDrivenCuriosity = await safeLoad('SelfDrivenCuriosityConnector', () =>
        new SelfDrivenCuriosityConnector({
            codeObserver: ext.codeObserver,
            conversationExtractor: ext.curiosityExtractor,
            curiosityEngine: ext.curiosityEngine,
            quadBrain: system.quadBrain,
            selfModel: ext.recursiveSelfModel,
            knowledgeGraph: system.knowledgeGraph,
            messageBroker: system.messageBroker
        })
    );

    ext.reflexScout = await safeLoad('ReflexScoutArbiter', () =>
        new ReflexScoutArbiter({
            conversationHistory: ext.conversationHistory,
            reflexArbiter: ext.reflexArbiter,
            mnemonic: system.mnemonicArbiter
        })
    );

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE H: Wire Cross-System Connections
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    console.log('\n[Phase H] Wiring cross-system connections...');

    // Learning loop: OutcomeTracker ‚Üí Pipeline ‚Üí Memory
    if (ext.learningPipeline) {
        if (ext.outcomeTracker) ext.learningPipeline.outcomeTracker = ext.outcomeTracker;
        if (ext.experienceReplay) ext.learningPipeline.experienceReplay = ext.experienceReplay;
        if (system.mnemonicArbiter) ext.learningPipeline.mnemonicArbiter = system.mnemonicArbiter;
        // Expose on system so chat handler can call logInteraction()
        system.learningPipeline = ext.learningPipeline;
        console.log('    üîó Learning loop: OutcomeTracker ‚Üí Pipeline ‚Üí Memory ‚Üí system.learningPipeline');
    }

    // Curiosity ‚Üí Learning Planner ‚Üí Web Research
    if (ext.curiosityEngine && ext.learningPlanner) {
        console.log('    üîó Curiosity ‚Üí Learning Planner ‚Üí Web Research');
    }

    // Curiosity Extractor ‚Äî expose on system for chat post-processing
    if (ext.curiosityExtractor) {
        system.curiosityExtractor = ext.curiosityExtractor;
        console.log('    üîó CuriosityExtractor ‚Üí system.curiosityExtractor');
    }

    // Hippocampus ‚Üí Mnemonic consolidation
    if (ext.hippocampus && system.mnemonicArbiter) {
        console.log('    üîó Hippocampus ‚Üî Mnemonic memory consolidation');
    }

    // Fragment system
    if (ext.fragmentRegistry && ext.fragmentComms) {
        console.log('    üîó Fragment Registry ‚Üî Communication Hub');
    }

    // Wire fragment registry into core systems (ensures real fragments are used)
    if (ext.fragmentRegistry) {
        if (system.quadBrain) system.quadBrain.fragmentRegistry = ext.fragmentRegistry;
        if (system.mnemonicArbiter) system.mnemonicArbiter.fragmentRegistry = ext.fragmentRegistry;
        if (ext.performanceOracle) ext.performanceOracle.fragmentRegistry = ext.fragmentRegistry;
        // Give fragments access to learning pipeline so recordFragmentOutcome() can feed back
        if (ext.learningPipeline) ext.fragmentRegistry.learningPipeline = ext.learningPipeline;
        system.fragmentRegistry = ext.fragmentRegistry;
        console.log('    üîó Fragment Registry ‚Üí QuadBrain/Mnemonic/PerformanceOracle/LearningPipeline');
    }

    // Moltbook + PersonalityForge availability for tools
    if (ext.moltbook) {
        system.moltbook = ext.moltbook;
        console.log('    üîó MoltbookArbiter ‚Üí system.moltbook');
    }
    if (ext.personalityForge) {
        system.personalityForge = ext.personalityForge;
        console.log('    üîó PersonalityForgeArbiter ‚Üí system.personalityForge');
    }

    // Wire autonomous systems into QuadBrain so it can query them in chat
    if (system.quadBrain) {
        if (ext.goalPlanner) system.quadBrain.goalPlanner = ext.goalPlanner;
        if (ext.codeObserver) system.quadBrain.codeObserver = ext.codeObserver;
        if (ext.curiosityEngine) system.quadBrain.curiosityEngine = ext.curiosityEngine;
        console.log('    üîó QuadBrain ‚Üê GoalPlanner, CodeObserver, CuriosityEngine');
    }

    // Hybrid search availability for tools + learning systems
    if (ext.hybridSearch) {
        system.hybridSearch = ext.hybridSearch;
        system.searchArbiter = ext.hybridSearch;
        system.hybridSearchArbiter = ext.hybridSearch;
        console.log('    üîó HybridSearchArbiter ‚Üí system.hybridSearch/searchArbiter');
    }

    // Optional: one-time deep scan on boot for persistent search index
    if (ext.mnemonicIndexer && process.env.SOMA_INDEX_ON_START === 'true') {
        const scanPath = process.env.SOMA_INDEX_PATH || process.cwd();
        ext.mnemonicIndexer.scanDirectory(scanPath).catch(() => {});
        console.log(`    üîó MnemonicIndexerArbiter ‚Üí scanDirectory(${scanPath})`);
    }

    // Self-improvement loop
    if (ext.selfImprovement && ext.outcomeTracker && ext.hindsightReplay) {
        console.log('    üîó Self-Improvement ‚Üî Outcome Tracking ‚Üî Hindsight Replay');
    }

    // ‚îÄ‚îÄ Late-wire trading arbiters into SOMA_TRADING ‚îÄ‚îÄ
    // These load after boot, so we inject them into the global that
    // ScalpingEngine, PositionGuardian, and finance routes already check.
    if (global.SOMA_TRADING) {
        if (ext.regimeDetector && !global.SOMA_TRADING.regimeDetector) {
            global.SOMA_TRADING.regimeDetector = ext.regimeDetector;
            console.log('    üîó MarketRegimeDetector ‚Üí SOMA_TRADING (ScalpingEngine now regime-aware)');
        }
        if (ext.positionSizer && !global.SOMA_TRADING.positionSizer) {
            global.SOMA_TRADING.positionSizer = ext.positionSizer;
            console.log('    üîó AdaptivePositionSizer ‚Üí SOMA_TRADING (dynamic position sizing active)');
        }
        if (ext.tradeLearning && !global.SOMA_TRADING.tradeLearning) {
            global.SOMA_TRADING.tradeLearning = ext.tradeLearning;
            console.log('    üîó TradeLearningEngine ‚Üí SOMA_TRADING (QuadBrain trade analysis active)');
        }
        if (ext.mtfAnalyzer && !global.SOMA_TRADING.mtfAnalyzer) {
            global.SOMA_TRADING.mtfAnalyzer = ext.mtfAnalyzer;
            console.log('    üîó MultiTimeframeAnalyzer ‚Üí SOMA_TRADING');
        }
        if (ext.smartOrderRouter && !global.SOMA_TRADING.smartOrderRouter) {
            global.SOMA_TRADING.smartOrderRouter = ext.smartOrderRouter;
            console.log('    üîó SmartOrderRouter ‚Üí SOMA_TRADING');
        }
    }

    // Self-awareness loop: SelfModel ‚Üî CodeInspector ‚Üî CuriosityConnector
    if (ext.recursiveSelfModel && ext.selfCodeInspector) {
        ext.selfCodeInspector.selfModel = ext.recursiveSelfModel;
        console.log('    üîó Self-Awareness loop: SelfModel ‚Üî CodeInspector ‚Üî CuriosityConnector');
    }

    // MetaLearning ‚Üî OutcomeTracker + ExperienceReplay
    if (ext.metaLearning) {
        if (ext.outcomeTracker) ext.metaLearning.outcomeTracker = ext.outcomeTracker;
        if (ext.experienceReplay) ext.metaLearning.experienceReplay = ext.experienceReplay;
        console.log('    üîó MetaLearning ‚Üî OutcomeTracker + ExperienceReplay');
    }

    // TrainingDataExporter ‚Äî wire all data sources
    if (ext.trainingDataExporter) {
        ext.trainingDataExporter.conversationHistory = ext.conversationHistory;
        ext.trainingDataExporter.personalityForge = ext.personalityForge;
        ext.trainingDataExporter.userProfile = ext.userProfile;
        ext.trainingDataExporter.mnemonic = system.mnemonicArbiter;
        ext.trainingDataExporter.learningPipeline = ext.learningPipeline;
        ext.trainingDataExporter.metaLearning = ext.metaLearning;
        ext.trainingDataExporter.causality = system.causality;
        console.log('    üîó TrainingDataExporter ‚Üê ConversationHistory, Personality, Memory, MetaLearning');
    }

    // AutonomousExpansion ‚Äî give it system reference
    if (ext.autonomousExpansion) {
        ext.autonomousExpansion.system = system;
        console.log('    üîó AutonomousCapabilityExpansion ‚Üê System reference');
    }

    // ‚îÄ‚îÄ AUTONOMOUS BACKGROUND SYSTEMS ‚îÄ‚îÄ
    // Timekeeper ‚Üí GoalPlanner (sends planning_pulse every 6h)
    if (ext.timekeeper) {
        system.timekeeper = ext.timekeeper;
        console.log('    üîó TimekeeperArbiter ‚Üí system.timekeeper (temporal rhythms active)');
    }

    // GoalPlanner ‚Üê CodeObserver, CuriosityEngine, SelfImprovement
    if (ext.goalPlanner) {
        if (ext.codeObserver) ext.goalPlanner.codeObserver = ext.codeObserver;
        if (ext.curiosityEngine) ext.goalPlanner.curiosityEngine = ext.curiosityEngine;
        if (ext.selfImprovement) ext.goalPlanner.selfImprovement = ext.selfImprovement;
        if (ext.outcomeTracker) ext.goalPlanner.outcomeTracker = ext.outcomeTracker;
        if (system.quadBrain && !ext.goalPlanner.quadBrain) ext.goalPlanner.quadBrain = system.quadBrain;
        system.goalPlanner = ext.goalPlanner; // Ensure system ref is up to date
        console.log('    üîó GoalPlannerArbiter ‚Üê CodeObserver, Curiosity, SelfImprovement');
    }

    // NighttimeLearningOrchestrator ‚Äî autonomous learning during idle periods
    try {
        ext.nighttimeLearning = new NighttimeLearningOrchestrator({
            name: 'NighttimeLearningOrchestrator'
        });
        await ext.nighttimeLearning.initialize({
            timekeeper: ext.timekeeper,
            mnemonic: system.mnemonicArbiter,
            quadBrain: system.quadBrain,
            archivist: system.archivistArbiter || system.archivist,
            reasoningChamber: ext.reasoning,
            deployment: ext.deploymentArbiter,
            storage: system.storageArbiter || system.storage,
            knowledgeGraph: system.knowledgeGraph
        });
        system.nighttimeLearning = ext.nighttimeLearning;
        console.log('    üîó NighttimeLearningOrchestrator ‚Üê Timekeeper, Memory, QuadBrain, Reasoning');
    } catch (e) {
        console.warn(`    ‚ö†Ô∏è NighttimeLearningOrchestrator skipped: ${e.message}`);
        ext.nighttimeLearning = null;
    }

    // ‚îÄ‚îÄ ReportingArbiter: Automated daily/weekly reports ‚îÄ‚îÄ
    try {
        ext.reportingArbiter = new ReportingArbiter({ name: 'ReportingArbiter' });
        await ext.reportingArbiter.initialize({
            goalPlanner: ext.goalPlanner || system.goalPlanner,
            timekeeper: ext.timekeeper || system.timekeeper,
            curiosityEngine: ext.curiosityEngine || system.curiosityEngine,
            nighttimeLearning: ext.nighttimeLearning || system.nighttimeLearning,
            codeObserver: ext.codeObserver || system.codeObserver,
            approvalSystem: system.approvalSystem
        });
        system.reportingArbiter = ext.reportingArbiter;
        console.log('    üîó ReportingArbiter ‚Üê GoalPlanner, Timekeeper, Curiosity, Learning, CodeObserver, Approvals');
    } catch (e) {
        console.warn(`    ‚ö†Ô∏è ReportingArbiter skipped: ${e.message}`);
        ext.reportingArbiter = null;
    }

    // ‚îÄ‚îÄ KEVIN: Inject cognitive arbiters so Kevin has brain access ‚îÄ‚îÄ
    if (system.kevinArbiter) {
        const kevin = system.kevinArbiter;
        if (!kevin.quadBrain && system.quadBrain) kevin.quadBrain = system.quadBrain;
        if (!kevin.reasoning && ext.reasoning) kevin.reasoning = ext.reasoning;
        if (!kevin.toolCreator && ext.toolCreator) kevin.toolCreator = ext.toolCreator;
        if (!kevin.ideaCapture && ext.ideaCapture) kevin.ideaCapture = ext.ideaCapture;
        if (!kevin.learningPipeline && ext.learningPipeline) kevin.learningPipeline = ext.learningPipeline;
        if (!kevin.mnemonic && system.mnemonicArbiter) kevin.mnemonic = system.mnemonicArbiter;
        if (!kevin.codeObserver && ext.codeObserver) kevin.codeObserver = ext.codeObserver;
        if (!kevin.causality && system.causality) kevin.causality = system.causality;
        console.log('    üîó KEVIN ‚Üê QuadBrain, Reasoning, ToolCreator, IdeaCapture, Memory');
    }

    // ‚îÄ‚îÄ STEVE (ExecutiveCortex): Inject specialist arbiters ‚îÄ‚îÄ
    const steve = system.steveArbiter || system.executiveCortex;
    if (steve) {
        if (!steve.toolCreator && ext.toolCreator) steve.toolCreator = ext.toolCreator;
        if (!steve.codeObserver && ext.codeObserver) steve.codeObserver = ext.codeObserver;
        if (!steve.learningPipeline && ext.learningPipeline) steve.learningPipeline = ext.learningPipeline;
        if (!steve.ideaCapture && ext.ideaCapture) steve.ideaCapture = ext.ideaCapture;
        if (!steve.knowledge && system.knowledgeGraph) steve.knowledge = system.knowledgeGraph;
        if (!steve.selfImprovement && ext.selfImprovement) steve.selfImprovement = ext.selfImprovement;

        // Fix Steve's orchestrator ‚Äî it gets an empty Map() stub during boot.
        // Populate it with the real system arbiters so Steve can find the brain.
        if (steve.orchestrator && system.quadBrain) {
            const pop = steve.orchestrator.population || new Map();
            if (pop.size === 0 && system.quadBrain) {
                pop.set('quadBrain', system.quadBrain);
                if (system.somArbiter) pop.set('somArbiter', system.somArbiter);
                steve.orchestrator.population = pop;
                steve.orchestrator.transmitters = system.hybridSearchArbiter || system.hybridSearch || null;
            }
        }
        // Also give Steve direct brain access as a fallback
        if (!steve.quadBrain && system.quadBrain) steve.quadBrain = system.quadBrain;

        console.log('    üîó STEVE ‚Üê QuadBrain, ToolCreator, CodeObserver, LearningPipeline, Knowledge');
    }

    // Count what loaded
    const loaded = Object.values(ext).filter(v => v !== null).length;
    const total = Object.keys(ext).length;
    const heapMB = (process.memoryUsage().heapUsed / 1024 / 1024).toFixed(0);
    console.log(`\n[Extended] ‚ïê‚ïê‚ïê ${loaded}/${total} specialist arbiters activated (heap: ${heapMB}MB) ‚ïê‚ïê‚ïê\n`);

    return ext;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// AUTOPILOT CONTROLLER
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

export function toggleAutopilot(enabled, system) {
    const results = { goals: false, rhythms: false, social: false };

    // GoalPlannerArbiter
    if (system.goalPlanner) {
        if (enabled) { system.goalPlanner.resumeAutonomous?.(); }
        else { system.goalPlanner.pauseAutonomous?.(); }
        results.goals = system.goalPlanner.isAutonomousActive?.() ?? enabled;
    }

    // TimekeeperArbiter
    if (system.timekeeper) {
        if (enabled) { system.timekeeper.resumeAutonomousRhythms?.(); }
        else { system.timekeeper.pauseAutonomousRhythms?.(); }
        results.rhythms = system.timekeeper.isAutonomousActive?.() ?? enabled;
    }

    // SocialAutonomyArbiter
    if (system.socialAutonomy) {
        if (enabled) { system.socialAutonomy.activate?.(); }
        else { system.socialAutonomy.deactivate?.(); }
        results.social = system.socialAutonomy.isActive ?? enabled;
    }

    console.log(`[Autopilot] ${enabled ? '‚ñ∂Ô∏è  ENABLED' : '‚è∏Ô∏è  PAUSED'} ‚Äî Goals: ${results.goals}, Rhythms: ${results.rhythms}, Social: ${results.social}`);
    return { enabled, components: results };
}

export function getAutopilotStatus(system) {
    return {
        enabled: (system.goalPlanner?.isAutonomousActive?.() ?? true) &&
                 (system.timekeeper?.isAutonomousActive?.() ?? true),
        components: {
            goals: system.goalPlanner?.isAutonomousActive?.() ?? false,
            rhythms: system.timekeeper?.isAutonomousActive?.() ?? false,
            social: system.socialAutonomy?.isActive ?? false
        }
    };
}
